|*
 *  user.cicada
 *  This file contains a set of useful definitions that are
 *  loaded by start.cicada when Cicada is run interactively.
 *  
 *  Cicada
 *  Copyright (C) 2017 Brian C. Ross
 *  
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *  
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *|



| *******  Variable & constant definitions  *******


passed := 0

e := 2.718281828459045235360287471352662497757247093699959574966

pi := 3.141592653589793238462643383

trap( inf := 1/0 )      | suppress the warning messages on these
trap( nan := 0/0 )

root := @this

(where :: string) = "root"

filePaths :: [1] string
filePaths[1] = ""          | used by run(), Load()  (but not load()!)




| definitions for a user-defined compiler

compiledCommandType :: {
    cmdString :: string         | the written character sequence of the operator, including arguments
    precedence :: int           | the order-of-operations precedence level of the operator
    rtrnTypeString :: string    | contains the allowed return types of the operator
    bytecodeString :: string    | the bytecode translation of the operator
}

l_to_r := 1     | left-to-right grouped operator precedence level:  e.g. (a+b)+c
r_to_l := 2     | right-to-left grouped operator precedence level:  e.g. a=(b=c)

type0arg := "\10"
type1arg := "\11"
type2arg := "\12"
type3arg := "\13"
type4arg := "\14"
type5arg := "\15"
type6arg := "\16"
type7arg := "\17"
type8arg := "\18"
type9arg := "\19"
typeXarg := "\1A"
chararg := "\1B"
stringarg := "\1C"
commentarg := "\1D"
optionalargs := "\1E"

type0arg_adapter := "\f0"
type1arg_adapter := "\f1"
type2arg_adapter := "\f2"
type3arg_adapter := "\f3"
type4arg_adapter := "\f4"
type5arg_adapter := "\f5"
type6arg_adapter := "\f6"
type7arg_adapter := "\f7"
type8arg_adapter := "\f8"
type9arg_adapter := "\f9"
noarg_adapter := "\fa"

int_constant := "\fb"
double_constant := "\fc"
variable_name := "\fd"

argXtype := "\fe"

arg1 := "\11"
arg2 := "\12"
arg3 := "\13"
arg4 := "\14"
arg5 := "\15"
arg6 := "\16"
arg7 := "\17"
arg8 := "\18"
arg9 := "\19"

anonymousmember := " \1a "
removedexpression := "\1b"
inbytecode := "\1c"






| **************  Functions  **************

| variables:     new()
| file I/O:      Load(), Save(), cd(), pwd()
| strings:       lowercase(), uppercase(), C_string(), cat()
| printing:      printl(), sprint(), mprint()
| tables:        writeTable(), saveTable(), readTable(), readInput(), readFile()
| running code:  do_in(), compile_and_do_in(), run()
| workspace:     go(), jump(), what()
| numeric:       min(), max(), sum(), mean(), round(), sort(), binsearch()
| misc:          disassemble()



| new(var) creates a new object using var as a template;
| used for creating new return objects for functions

new :: {
    rtrn :: *
    copy_err :: int
    
    code
    
    rtrn =@ *
    if top(args) > 2  then (
        printl("usage:  new_object = new(template [, data variable] [; code to modify new variable])")
        return      )
    
    rtrn @:: args[1]
    
    if type(rtrn) >= 5  then (rtrn<<args)()
    
    if top(args) == 1  then &
        copy_err = trap( rtrn = args[1] )
    else if trap(type(args[2])) == passed  then &
        copy_err = trap( rtrn = args[2] )
    else  copy_err = passed
    
    if copy_err /= passed  then &
        printl("new():  could not copy template data (error ", copy_err, ")")
    
    return rtrn
}






| fileStr = Load(filename) and Save(filename, fileStr) extend Cicada's load() and save() (no caps)
| by searching all paths in the filePaths[] array

doInAllDirectories :: {
    
    fileName :: fileString :: fullPathName :: myname :: myusage :: string
    counter :: errCode :: int
    params :: { printError :: bool }
    
    code
    
    if trap( myargs = args ) /= 0  then (
        printl("usage:  ", myusage)
        return          )
    
    params.printError = true
    (params<<args)()
    
    errCode = counter = 1
    while errCode /= passed and counter <= top(filePaths)  do (
        print_string(fullPathName, filePaths[counter], fileName)
        errCode = trap(myfunction(fullPathName, fileString))
        counter = that + 1      )
    
    if errCode /= passed  then (
        if params.printError  then printl(myname, "() error:  file \"", fileName, "\" could not be opened\n")
        return          )
    
    return myrtrn()
}

Load :: doInAllDirectories : {
        myname = "Load", myusage = "file_string = Load(file_name)",
        myargs :: { fileName },
        myfunction :: { ; args[2] = load(args[1]) },
        myrtrn :: { ; return new(fileString) }          }

Save :: doInAllDirectories : {
        myname = "Save", myusage = "Save(file_name, file_string)",
        myargs :: { fileName, fileString },
        myfunction :: { ; save(args[1], args[2]) },
        myrtrn :: { ; return * }        }



| cd(newDir) changes the working directory

cd :: {
    
    newDirectory :: string
    
    code
    
    if trap({ newDirectory } = args) /= passed  then &
        print("usage:  cd(directory name)")
    
    else  filePaths[^1] = newDirectory
}



| pwd() prints all working directories

pwd :: {
    
    loopDir :: int
    
    code
    
    for loopDir in <1, top(filePaths)>  printl(filePaths[loopDir])
}



| lowercase(str), uppercase(str) change the case of all characters in the string 'str'

lowercase :: {
    
    (A_char :: int) = 'A'
    (Z_char :: int) = 'Z'
    (ASCII_diff :: int) = 'a'
    ASCII_diff = that - A_char
    
    myname := "lowercase"
    
    
    str :: string
    clu :: str_top :: int
    
    code
    
    if trap(
        { str } = args
    ) /= passed  then (
        printl("usage:  ", myname, "(my_string)")
        return      )
    
    str_top = top(str)
    
    for clu in <1, str_top>  (
    if (str[clu] >= A_char and str[clu] <= Z_char)  then (
        str[clu] = that + ASCII_diff
    ))
    
    return new(str)
}

uppercase :: lowercase : { A_char = 'a', Z_char = 'z', ASCII_diff = -that }



| C_string(str) creates a byte block containing the provided string 'str' in C-string format

C_string :: {
    
    str :: string
    
    code
    
    if trap(
        { str } = args
    ) /= passed  then (
        printl("usage:  byte-block-string = call_string((string) my_string")
        return      )
    
    if str[top] /= '\00'  then str = cat(str, "\00")
    
    return new(str)
}




| cat(a, b, ...) returns the concatenation of its arguments as a string

cat :: {
    
    str :: string
    
    code
    
    print_string(str, args)
    
    return new(str)
}



| for use with compiledCommandType[] strings

compilerString :: {  return cat(args, '\00')  }



| printl(a, b, ...) prints its arguments with a following end-of-line

printl :: {  code, print(args, "\n")  }



| mprint(M) prints M as a matrix; also works with tables and lists

mprint :: {
    
    mprintArgs :: *
    
    code
    
    mprintArgs = @args
    print(writeTable(args[1]; (this<<mprintArgs)()))
    mprintArgs = @nothing
}



| sprint(a, b, ...) prints its arguments as a set -- good for printing variables, structures, etc.

sprint :: {
    argCounter :: argTop :: int
    firstTime :: bool
    argsToPrint :: *
    
    code
    
    if firstTime  then (
        if trap(size(args)) /= passed  then (
            printl("sprint() error:  self-reference")
            return      )
        argsToPrint = @args   )    | don't use args in the arguments
    else  argsToPrint = @args[1]
    
    argTop = top(argsToPrint)
    for argCounter in <1, argTop>  (
        if (argsToPrint[argCounter] /=@ *)  then (
            if (type(argsToPrint[argCounter]) >= 5)  then (
                print("{ ")
                (ncclib_sprint::sprint).firstTime = false
                ncclib_sprint(argsToPrint[argCounter])
                print(" }")     )
            else  (
                print(argsToPrint[argCounter])
        )   )
        else  print("*")
        if argCounter < argTop  then print(", ")
        else if firstTime  then print("\n")
    )
    
    argsToPrint =@ *        | to prevent jamming
}
sprint.firstTime = true

calculator = @sprint





| tableString = writeTable(table) outputs table data as a string

writeTable :: {
    
    c1 :: idx1 :: int
    fileWriteString :: string
    theTable :: *
    
    params :: { fieldWidth :: maxDigits :: int, voidString :: string }
    
    
    code
    
    (params << { ; fieldWidth = 14, maxDigits = 6, voidString = "*" })()
    
    if trap(
        if top(args) /= 1  then throw(1)
        theTable = @args[1]
        top(theTable)       | check that it's composite
        
        (params<<args)()    
    ) /= passed  then (
        printl("usage:  writeTable(table [; fieldWidth/maxDigits/voidString = ...])")
        theTable =@ *
        return          )
    
    if top(theTable) == 0  then (
        theTable =@ *
        return ""      )
    
    idx1 = top(theTable)
    stringsTable :: [idx1] string
    
    
        | store each row of our table as an array of strings containing either a) a void symbol,
        | or b) an array whose elements are separated by a defined number of spaces 
    
    for c1 in <1, idx1>  (
        if theTable[c1] == @nothing  then stringsTable[c1] = "*\n"
        else  print_string(params.fieldWidth, params.maxDigits, stringsTable[c1], theTable[c1], "\n")       )
    
    
        | copy the array of strings into a final big string, unlink our alias and return
    
    fileWriteString =! stringsTable
    
    theTable = @nothing        | so we don't jam it
    remove stringsTable
    
    return new(fileWriteString)
}



| saveTable(filename, table) outputs table data to a file

saveTable :: {
    
    saveTableArgs :: *
    
    code
    
    saveTableArgs = @args
    Save(args[1], writeTable(args[2]; (this<<saveTableArgs)()))
    saveTableArgs = @nothing
}




| readTable(table, tableString) fills in a table (1st argument) from text data stored in a string (2nd argument);
| readInput(table) and readFile(table, fileName) are variations of this

readTable :: {
    
    tableString :: string
    theTable :: *
    defaults :: { ifHeader :: resizeColumns :: resizeRows :: bool }
    numLines :: beginningFirstRow :: numColumns :: endFirstRow :: loopChar :: errCode :: int
    
    code
    
    (defaults<<{ ; ifHeader = false, resizeColumns = resizeRows = true })()
    errCode = passed
    
    if trap(
        if top(args) /= 2  then throw(1)
        theTable = @args[1]
        tableString = args[2]
        (defaults<<args)()
    ) /= passed  then (
        print("usage:  readTable(theTable, sourceString [, code, ifHeader/resizeColumns/resizeRows = true/false])\n")
        errCode = 1
        theTable =@ *, return       )
    
    if top(theTable) > 0  then (
        if type(theTable[1]) <= 4  then (
            defaults.resizeColumns = that or defaults.resizeRows
            defaults.resizeRows = false
    )   )
    
    else if trap(theTable[*][*]) /= passed  then defaults.resizeRows = false
    
    
        | handle resizing of the table here..
    
    beginningFirstRow = 1
    if defaults.resizeColumns or defaults.resizeRows  then (
        
        
            | first calculate the number of rows in the table, by counting the number of '\n's
            | (this should work on both UNIX machines and PCs, since they each have one \n per line break)
        
        if tableString == ""  then numLines = 0
        else  (
            numLines = find(tableString, "\n", 0) + 1
            if tableString[top] == '\n' or tableString[top] == '\r'  then numLines = that-1
            
            if defaults.ifHeader  then (
                numLines = that - 1
                beginningFirstRow = max(1, find(tableString, "\n", 1)+1)     )
            
            
                | if we're resizing each row, then calculate number of columns by examining the first row
            
            endFirstRow = find(tableString, "\n", 1, beginningFirstRow)
            if endFirstRow == 0  then endFirstRow = top(tableString)+1
            
            if loopChar <= size(tableString)  then (
            if defaults.resizeRows  then (
                numColumns = 0, loopChar = beginningFirstRow
                while loopChar < endFirstRow  do (
                    if tableString[loopChar] > 32 and tableString[loopChar] < 127  then (
                        numColumns = that+1
                        {  loop  (
                            if tableString[loopChar] <= 32 or tableString[loopChar] >= 127  then return
                            loopChar = that+1
                        ) until loopChar >= endFirstRow   }
                    )
                    
                    {  while loopChar < endFirstRow  do  (
                        if tableString[loopChar] > 32 and tableString[loopChar] < 127  then return
                        loopChar = that+1
        )   })) )   )
        
        if numLines < 0  then numLines = 0
        
        
            | now do the resize(s) (how we do this efficiently depends on which dimensions are being resized)
        
        if not defaults.resizeRows  then (
        if trap(theTable[^numLines]) /= passed  then (
            print("readTable():  number of rows could not be changed -- mismatched read will result\n")
            errCode = 2
        ))
        
        else if not defaults.resizeColumns  then (
        if trap(theTable[*][^numColumns]) /= passed  then (
            print("readTable():  number of columns could not be changed -- mismatched read will result\n")
            errCode = 2
        ))
        
        else  (
        if trap( theTable[^0], theTable[*][^numColumns], theTable[^numLines] ) /= passed  then (
            print("readTable():  number of rows & columns could not be changed -- mismatched read will result\n")
            errCode = 2
        ))
    )
    
    if tableString /= ""  then tableString = that[<beginningFirstRow, top>]
    if trap( ; read_string(tableString, theTable)  ) /= passed  then (
        print("readTable():  table not read properly\n")
        if errCode == passed  then errCode = 3      )
    
    theTable =@ *
}

readInput :: {  holdArgs :: *; holdArgs = @args, readTable(holdArgs[1], str:=input(); (this<<holdArgs)()), holdArgs = @nothing  }
readFile :: {  holdArgs :: *; holdArgs = @args, readTable(holdArgs[1], Load(holdArgs[2]); (this<<holdArgs)()), holdArgs = @nothing  }




| do_in(location [, searchPath [, toRun_args [, bytecodeWordsMod_args]]]; toRun [; bytecodeWordsMod code])
| compile_and_do_in(location [, searchPath [, toRun_args [, bytecodeWordsMod_args]]]; toRun [; bytecodeWordsMod code])
| - these run the compiled code / uncompiled string 'toRun' in a designated location with an optional search path;
|   2nd coding section allows changes to the bytecode after compilation of the script

do_in :: {
    params :: *
    bytecodeString :: scriptString :: string
    rtrn :: c1 :: bytecode_word :: bytecode_words_num :: bc0 :: bcf :: int
    target :: searchPath :: *
    no_path :: { * }, default_path :: { }
    myname := "do_in"
    compiledCode :: {}
    
    
    code
    
    if (myname == "compile_and_do_in")  then (
        trap(remove scriptSpace)
        scriptSpace :: {}
        (scriptSpace<<args)()       )
    
    if trap(
        if top(args) > 4  then throw(1)
        
        if top(args) == 0  then target = @root
        else  target = @args[1]
        
        if top(args) >= 2  then (
            if (trap(if args[2] == @nothing then throw(1)) /= passed)  then searchPath = @no_path
            else  searchPath = @args[2]       )
        
        else  searchPath = @default_path
        
        if myname == "compile_and_do_in"  then (
            { scriptString } = scriptSpace
            remove scriptSpace      )
    ) /= passed  then (
        print("usage:  ", myname, "(target [, { search path } [, { script args } [, { bytecode_mod args }]]]; ")
        printl("script to run [; script to modify BytecodeArray[]])")
        target = @searchPath = @nothing
        return      )
    
    remove params           | the user may want to work in this variable, so clean it out
    params :: { bytecodeWords :: [1] int }
    
    
        | do_in() extracts the compiled code from the args..
    
    if myname == "do_in"  then (
        
        params.bytecodeWords[*] =! (bytecodeString = bytecode(args))
        bytecode_words_num = top(params.bytecodeWords)
        bytecode_word = 1
        
        bc0 = bcf = 0
        {
            while bytecode_word <= bytecode_words_num  do (
                if (params.bytecodeWords[bytecode_word] == 4 or params.bytecodeWords[bytecode_word] == 0)  then (
                    if bc0 == 0  then (
                        bc0 = bytecode_word
                        if params.bytecodeWords[bytecode_word] == 0  then return     )
                    else  (
                        bcf = bytecode_word
                        return
                )   )
                disassemble(bytecodeString, *, bytecode_word)
            )
        }
        
        if bcf /= 0  then &
            remove params.bytecodeWords[<bcf, top(params.bytecodeWords)>]
        remove params.bytecodeWords[<1, bc0>]
        params.bytecodeWords[+top+1] = 0
    )
    
    
        | .. whereas compile_and_do_in() compiles the script string
    
    else  (
        
        rtrn = trap( ; bytecodeString = compile(scriptString))
        if rtrn /= passed  then return
        
        params.bytecodeWords[*] =! bytecodeString
    )
    
    
        | allow the user to modify the compiled bytecode
    
    if (trap(if args[4] == @nothing  then throw(1)) == passed)  then &
        (params<<args#2)(args[4])
    
    else  (params<<args#2)()
    
    
        | run the bytecode
    
    bytecodeString =! params.bytecodeWords
    
    if trap( ; transform(bytecodeString, compiledCode, searchPath)) == passed  then (
        if top(args) >= 3   then (
        if trap(if args[3] == @nothing then throw(1)) == passed  then (
            return (target<<compiledCode#0)(args[3])
        ))
        return (target<<compiledCode#0)()      )
    
    searchPath = @target = @nothing
}

compile_and_do_in :: do_in : { myname = "compile_and_do_in" }




| errCode = run(file_name [, location]) runs the code stored in a file, in the workspace or optionally in 'location' 

run :: {
    
    (doCleanUp :: bool) = true
    (caseSensitive :: bool) = false
    
    scriptGlobalVars :: { }
    
    getvarlist :: {
        
        c1 :: int
        varlistarray :: [] int
        
        code
        
        varlistarray[^top(args[1])]
        for c1 in <1, top(args[1])>  &
            varlistarray[c1] = member_ID(args[1], c1)
        
            | next line:  must be careful not to cause one of sort()'s trap()s to fail
            | that means:  pass 2nd arg, and provide a table that can be copied using :=
        
        sort(varlistarray, 1)
        
        return new(varlistarray)              }
    
    
    code
    
    return new(run_template)(args)      | new() since the new script might also call run()
}

run.run_template :: {
    
        | define everything using this.var :: .. -- otherwise there can be conflict w/ global vars
        | when making new copies of run_template() at the end of run()
    
    loopID :: loopNewVar :: numNewVars :: ID_array_top :: SGV_ID :: rtrn :: int
    opPositions :: nameComparison :: fileName :: scriptString :: bytecodeString :: string
    targetVariable :: ID_array :: scriptReturnValue :: oldvarlist :: newvarlist :: *
    bytecodeContainer :: removeContainer :: {}
    
    remove_member_code :: [] int, rmc_string :: string
    remove_member_code[*] =! compile("code, remove x")
    
    runLoad :: Load : { myname = "run" }
    
    
    code
    
    self := @this       | do this inside the coding section; otherwise new() won't work (self-reference error)
    
    if trap(
        fileName = args[1][1]
        if trap(targetVariable = @args[1][2]) /= passed  then targetVariable = @root
    ) /= passed  then (
        printl("usage:  error_number = run((string) fileName [, variable to run in])\n")
        targetVariable =@ *
        return          )
    
    
        | load, compile and transform the code
    
    if trap(scriptString = runLoad(cat(fileName, ".cicada"); printError = false)) /= passed  then (
    if trap(scriptString = runLoad(fileName)) /= passed  then (
        return
    ))
    
    if trap( ; bytecodeString = compile(scriptString, fileName, opPositions)) == passed  then (
    if trap( ; transform(bytecodeString, bytecodeContainer, { }, fileName, scriptString, opPositions)) == passed  then (
        
        
            | optionally, remove any variables defined by the script so that if the script redefines them
            | there won't be a type-mismatch error (this happens with composite variables even if the definitions
            | haven't changed)
        
        if run.doCleanUp  then (
            
            if not run.caseSensitive  then fileName = lowercase(that)
            
            {   for SGV_ID in <1, top(run.scriptGlobalVars)>  (
                    nameComparison = run.scriptGlobalVars[SGV_ID].filename
                    if not run.caseSensitive  then nameComparison = lowercase(that)
                    
                    if nameComparison == fileName  then return  )
                
                run.scriptGlobalVars[top+1] :: { filename :: string, newvars :: [0] int }
                run.scriptGlobalVars[top].filename = fileName
            }
            
            ID_array = @run.scriptGlobalVars[SGV_ID].newvars
            ID_array_top = top(ID_array)
            
            for loopID in <1, ID_array_top>  (
                remove_member_code[4] = ID_array[loopID]
                rmc_string =! remove_member_code
                transform(rmc_string, removeContainer)
                trap((targetVariable<<removeContainer)())      )       | might not exist (e.g. start.cicada removes tokens)
            
            oldvarlist = @run.getvarlist(targetVariable)
        )
        
        
            | (try to) run the code, and store the return result
        
        if trap( ; scriptReturnValue = @(targetVariable<<bytecodeContainer#0)()  ) /= passed  then scriptReturnValue =@ *
        
        
            | mark variables that were created by the script, so that if we run it again we can remove them
        
        if run.doCleanUp  then (
            
            newvarlist = @run.getvarlist(targetVariable)
            
            ID_array[^0]
            numNewVars = top(newvarlist)
            for loopNewVar in <1, numNewVars>  (
                if binsearch(oldvarlist, newvarlist[loopNewVar]) == @nothing  then (
                    ID_array[+top+1] = newvarlist[loopNewVar]
        )   )   )
    ))
    
    targetVariable = @nothing
    ID_array =@ *
    
    return scriptReturnValue
}




| go([; ] path) the workspace variable to path.  Syntax:  go([code, ] path).  go() goes back to path=="root".
| jump([; ] path) is the same as go() except that the new path gets appended onto the current path

go :: {
    
    go_args :: [] int
    pathstart :: pathword :: numOldSteps :: numMembers :: pathStep :: numNewSteps :: memberNo :: whereIndex :: rtrn :: int
    newSteps :: [0] { path_start :: path_end :: int }
    whereWords :: [1] string
    ga_string :: string
    goBack := true
    name := "go"
    
    whereWords[1] = "root"
    
    
    code
    
    if top(go_path) == 0  then go_path[1] := @root            | in case someone monkeyed w/ go_path
    
    
        | get the int words of the arguments & skip the code markers
    
    go_args[*] =! ga_string = bytecode(args)
    
    pathstart = 1
    while go_args[pathstart] == 4  do pathstart = that + 1
    
    
        | go() just sets the search path back to { root }
    
    if (go_args[pathstart] == 0)  then (
        
        if goBack  then (
            go_path[^1] = @root
            where = whereWords[^1] = "root"        )
        
        return      )
    
    
        | bytecode should begin w/ "dg [flags] sm -$xx [path]" or "dg [flags] s* sm -$xx [path]"; get to the path
    
    if go_args[pathstart] == 8  then (          | (8, x, 10, ...) = define, search member, ... 
        if go_args[pathstart+2] == 10  then pathstart = that + 4
        else  (
            printl("usage:  ", name, "([code, ] path)")
            return
    )   )
    
    else if go_args[pathstart] < 15 or go_args[pathstart] > 17  then (      | 15-17 = resize, insert index/indices
        printl("usage:  ", name, "([code, ] path)")
        return      )
    
    
        | find the start and end+1 of each step in the path, using disassemble() to find the end of each expression
    
    newSteps[^0]
    pathword = pathstart
    while (go_args[pathword] >= 11 and go_args[pathword] <= 15) or go_args[pathword] == 6  do (
        newSteps[+top+1] = { pathword, pathword }
        disassemble(ga_string, *, newSteps[top].path_end)
        if go_args[pathword] == 11  then pathword = that + 2
        else  pathword = that + 1           )
    
    newSteps[+top+1] = { pathword, pathword }
    disassemble(ga_string, *, newSteps[top].path_end)
    
    
        | find the first step in our path
        
        | CASE 1:  it's a search-member, so we want to go back through prior steps and see where that member is
    
    numNewSteps = top(newSteps)
    if go_args[pathword] == 10  then ( {
        pathStep = top(go_path)
        while pathStep >= 1  do (
            if go_path[pathStep] /= @nothing  then (
            if type(go_path[pathStep]) == 5  then (
                numMembers = top(go_path[pathStep])
                for memberNo in <1, numMembers>  (
                    if member_ID(go_path[pathStep], memberNo) == go_args[pathword+1]  then (
                        numOldSteps = pathStep
                        return      )
            ))  )
            pathStep = that - 1
        ) }
        
        if pathStep == 0  then (
            printl(name, "() error:  could not find beginning of path")
            return      )
        
        if not goBack  then numOldSteps = top(go_path)
        
        go_path[^numOldSteps+numNewSteps]
        go_path[numOldSteps+1] = @go_path[pathStep][memberNo]
        
        whereWords[^numOldSteps+numNewSteps]
        if goBack  then (
            print_string(whereWords[numOldSteps+1], ".", allNames[go_args[pathword+1]])       )
        else  (
            print_string(whereWords[numOldSteps+1], "-->", allNames[go_args[pathword+1]])
    )   )
    
    
        | CASE 2:  the first step is a 'this' command
    
    else if go_args[pathword] == 41 or go_args[pathword] == 43  then (
        numOldSteps = top(go_path) - 1
        if go_args[pathword] == 43  then (
            numOldSteps = that - 1
            while go_args[pathword+1] == 43  do (
                numOldSteps = that - 1
                pathword = that + 1
        )   )
        go_path[^numOldSteps+numNewSteps]
        whereWords[^numOldSteps+numNewSteps]        )
    
    
    else  (  printl(name, "() error:  illegal path"), return  )
    
    
        | now add a step in go_path[] for each successive step-to-member or step-to-index, etc. command
    
    pathStep = numNewSteps-1
    while pathStep >= 1  do (
        
        whereIndex = numOldSteps+numNewSteps+1-pathStep
        
        rtrn = trap(do_in(
            
            go_path[whereIndex-1]
            *
            {  go_path, whereIndex }
            {  go_args[<newSteps[pathStep].path_start, newSteps[pathStep+1].path_start-1>],
               go_args[<newSteps[pathStep+1].path_end, newSteps[pathStep].path_end-1>]      }
            
            code
            
            args[1][1][args[1][2]] = @dummy
            
            code
            
            bytecodeWords[*] =! { bytecodeWords[<1, top-3>], args[1][1], 41, args[1][2], 0 }
        ))
        
        if rtrn == passed  then (
            if go_args[newSteps[pathStep].path_start] == 11  then
                print_string(whereWords[whereIndex], ".", allNames[go_args[newSteps[pathStep].path_start+1]])
            else if go_args[newSteps[pathStep].path_start] == 6  then
                print_string(whereWords[whereIndex], "()")
            else if go_args[newSteps[pathStep].path_start] == 14  then
                print_string(whereWords[whereIndex], "[*]")
            else  (
                print_string(whereWords[whereIndex], "[..]")
        )   )
        
        else  (
            go_path[^numOldSteps+numNewSteps-pathStep]
            whereWords[^numOldSteps+numNewSteps-pathStep]
            where =! whereWords
            
            print(name, "() error: invalid path (")
            if rtrn == 31  then print("cannot step through multiple indices\n")
            else  print("redo error handling\n")
            printl("Falling back to ", where)
            return
        )
        
        pathStep = that - 1
    )
    
    where =! whereWords
}

jump :: go : {  name = "jump", whereWords = @go.whereWords, goBack = false  }

go_path :: go_path : {  code, where = "root"  }    | in case start.cicada has to reset the path





| what([location]) displays the list of variables in the current workspace, or in 'location'

what :: {
    
    var_strings :: [] string
    comma_string :: string
    loopVar :: varID :: maxID :: int
    whatVars :: *
    
    code
    
    if trap(
        if top(args) == 0  then &
            whatVars = @go_path[top]
        else  whatVars = @args[1]
    ) /= passed  then (
        printl("usage:  what([variable name])")
        whatVars = @nothing
        return      )
    
    maxID = top(allNames)
    comma_string = ""
    
    var_strings[^0]
    for loopVar in <1, top(whatVars)>  (
        varID = member_ID(whatVars, loopVar)
        if varID > 0 and varID < maxID  then (
            var_strings[+top+1] = cat(comma_string, allNames[varID])
            comma_string = ", "
    )   )
    
    whatVars = @nothing
    return cat(var_strings)         | cat() makes a new() string
}






| max(list; rtrn = value/index/both)
| min(list; rtrn = value/index/both)
| - these return the maximum/minimum value of a list

numArrayOp *:: {
    
    name :: string
    the_list *:: [] double
    listTop :: int
    params :: {}
    
    code
    
    if top(args) == 0  then return
    
    params(), (params<<args)()
    
    if trap(the_list = @args[1]) /= passed then  (
        the_list @:: the_list
        if trap(
            the_list[^top(args[1])]
            the_list = args[1]
        ) /= passed then (
            if trap(
                the_list[^top(args)]
                the_list = args
            ) /= passed  then (
                printl("usage: ", name, "(numeric list [; rtrn = index/value/both])")
                the_list =@ *
                return
    )   )   )
    
    listTop = top(the_list)
}


maxmin_template :: numArrayOp : {
    
    mult :: max_index :: int
    max_val :: double
    
    params :: params : {  rtrn := value := 1, index := 2, both := 3;  rtrn = value  }
    
    code
    
    if listTop == 0  then (  printl(name, "() error:  list cannot be of length zero"), the_list =@ *, return  )
    
    $minmax(the_list, mult, max_index, max_val)
    
    the_list = @nothing
    if params.rtrn == params.value  then return new(mult*max_val)
    else if params.rtrn == params.index  then return new(max_index)
    else if params.rtrn == params.both  then return new({ mult*max_val, max_index })
    else  return *
}

min :: maxmin_template : { name = "min", mult = -1 }
max :: maxmin_template : { name = "max", mult = 1 }





| sum(list) and mean(list) return the sum/arithmetic mean of elements of a numeric list

sum :: numArrayOp : {
    
    the_sum :: double
    
    code
    
    $sum(the_list, the_sum)
    
    the_list = @nothing
}

mean :: sum : {  name = "mean"; return new(the_sum/listTop)  }
sum :: sum : {  name = "sum"; return new(the_sum)  }



| round(num) rounds off a num to the nearest integer

round :: { ; return floor(args[1] + 0.5) }


| sort(list [, whichColumn] [; direction = increasing/decreasing]) sorts a table
| by one of its (numerical) columns or by another list

sort :: {
    tableToSort :: sortingList :: sortedTable :: *
    c1 :: totalIndices :: oneIndex :: sortIndex :: int
    slowSort :: bool
    sortingListFloat :: [] double
    linklist :: [] int
    
    params :: { direction :: increasing :: decreasing :: int }
    
    code
    
    (params << {
        code
        direction = increasing = 1
        decreasing = -1
    })()
    
    if trap(
        if top(args) /= 1 and top(args) /= 2  then throw(1)
        tableToSort = @args[1]
        totalIndices = top(tableToSort)
        
        if totalIndices > 0  then (
            if trap(sortIndex = args[2]) == passed or top(args) == 1  then (
                if type(tableToSort[1]) < 5  then (
                    sortingList @:: [totalIndices] tableToSort[1]
                    sortingList = tableToSort       )
                else  (
                    if top(args) == 1  then throw(2)
                    sortingList @:: [totalIndices] tableToSort[1][sortIndex]
                    for c1 in <1, totalIndices>  (
                        sortingList[c1] = tableToSort[c1][sortIndex]
            )   )   )
            
            else  (
                sortingList = @args[2]
        )   )
        
        (params<<args)()
        if params.direction /= params.increasing and params.direction /= params.decreasing  then throw(2)
    ) /= passed  then (
        printl("usage:  sort(my_list) or sort(my_table, sortIndex/sort-by_list [, code, direction = increasing/decreasing])")
        tableToSort =@ sortingList =@ *
        return      )
    
    if totalIndices == 0  then return
    
    if totalIndices /= top(sortingList)  then (
        printl("sort() error:  tableToSort, sort-by_list have the same number of rows")
        tableToSort =@ sortingList =@ *
        return          )
    
    remove sortedTable
    if trap(
        sortedTable @:: tableToSort
        sortedTable = tableToSort
    ) /= passed  then (
        if trap(
            sortedTable =@ *
            sortedTable @:: [totalIndices] tableToSort[1]
            sortedTable = tableToSort
        ) /= passed  then (
            if trap(
                sortedTable =@ *
                sortedTable @:: [totalIndices][top(tableToSort[1])] tableToSort[1][1]
                sortedTable = tableToSort
            ) /= passed  then (
                printl("sort() error:  tableToSort differs from its original definition; could not be sorted")
                tableToSort =@ sortingList =@ *
                return
    )   )   )
    
    linklist[^totalIndices]
    if trap(sortingListFloat = @sortingList) /= passed  then (
        sortingListFloat @:: sortingListFloat
        sortingListFloat[^totalIndices] = sortingList[]     )
    
    oneIndex = $makeLinkList(sortingListFloat, linklist, params.direction)
    
    slowSort = ($sort(linklist, oneIndex, tableToSort, sortedTable) /= passed)              | use autoNN's C-coded sort() if possible
    if slowSort  then (
        oneIndex = that + 1
        for c1 in <1, totalIndices>  (
            sortedTable[c1] = tableToSort[oneIndex]
            oneIndex = linklist[oneIndex]
    )   )
    
    tableToSort = sortedTable
    tableToSort =@ sortingList =@ sortingListFloat =@ *
}



| binsearch(list [; direction = increasing/decreasing]) searches a sorted list for a given value,
| and returns the index in the list of that value (or * if not found)

binsearch :: {
    
    theList :: *
    left :: right :: mid :: int
    theVal :: difference :: double
    
    params :: { direction :: int, increasing := 1, decreasing := -1 }
    
    code
    
    if trap(
        theList = @args[1]
        theVal = args[2]
        if top(args) > 2  then throw(1)
        
        params.direction = params.increasing
        if top(theList) > 1  then (
        if theList[top]-theList[1] < 0  then (
            params.direction = params.decreasing
        ))
        (params<<args)()
    ) /= passed  then (
        printl("usage:  index = binsearch(list, value)")
        return
    )
    
    left = 1
    right = top(theList)
    while left <= right  do (
        mid = round((left+right)/2)
        difference = (theVal - theList[mid]) * params.direction
        
        if difference < 0.  then right = mid-1
        else if difference > 0.  then left = mid+1
        else if difference == 0.  then return mid
        else  return *                      | if we're looking for a NAN
    )
    
    return *
}



| The so-called 'disassembler' takes in Cicada bytecode code (NOT real machine code)
| and outputs a text version that is somewhat more readable.  Reads the compiled code string, optionally from startFrom,
| using nameSpace if given.  The return value is the disassembly string.  The optional flag marks the nth bytecode word.

| disassembly = disassemble(compiledCodeString [, nameSpace [, startFrom]] [; expandFunctions = true/false, flagPosition = #])


disassembler :: {
    
    compiledNames *:: [] string

    instructionWords :: {
            "j", "jt", "jf", "code", "ret", "f", "CCf", "dg", "feq", "sm",
            "sID", "sti", "stis", "s*", "rsz", "+i", "+is", "rm", "eq", "ne",
            "gt", "ge", "lt", "le", "eq@", "ne@", "add", "sub", "mul", "div",
            "pow", "mod", "not", "and", "or", "xor", "c#", "sub", "app", "args", 
            "this", "that", "back", "top", "*", "arr", "bool", "char", "int", "dbl",
            "str", "cb", "cc", "ci", "cdb", "cst", ""  }

    instructionArguments :: {
            0, 1, 1, 0, 1, 2, 2, 2, 2, 0, 
            1, 2, 3, 1, 2, 2, 3, 1, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 0,
            0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0      }

    extraWords :: {
            1, 1, 1, 0, 0, 0, 0, 1, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 1, 1, 1, size(double)/size(int), 1, 0      }

    dgWords :: [] { ID :: int, abbr :: string }
    dgWords[*] = {
            { 1, "equ" }, { 6, "mdf"}, { 16, "eqa"}, { 22, "dqa"}, { 44, "vdf"}, { 46, "def" }, { 47, "deq"},
            { 148, "dqa*"}, { 172, "def*"}, { 173, "deq*"}, { 236, "def**"}, { 237, "deq**"}, { 204, "def-c**"} }

    CicadaFunctionWords :: {
            "call", "", "compile", "transform", "load", "save", "input", "print", "read_string", "print_string",
            "trap", "throw", "top", "size", "abs", "floor", "ceil", "log", "cos", "sin",
            "tan", "acos", "asin", "atan", "random", "find", "type", "member_ID", "bytecode", "springCleaning"  }
    
    returnDisassembly :: expandFunctions :: bool
    bytecodeWords :: [] int
    numCompiledNames :: numWords :: disasmStartPos :: flagPosition :: int
    namespace :: bytecodeString :: output :: string
    wordSize := size(int)
    doubleSizeInInts := size(double)/size(int)
    
    
    runDisAsm :: {
        varStart :: varEnd :: CN_counter :: wordCounter :: argsError :: int
        rtrn :: *
        
        params :: {  expandFunctions := @\.\.expandFunctions, flagPosition := @\.\.flagPosition  }
        
        code
        
        params = {  true, 0  }
        
        if trap(
            returnDisassembly = (top(args) <= 2)
            if returnDisassembly  then ( { bytecodeString } = args, disasmStartPos = 1 )
            else  { bytecodeString, disasmStartPos } = { args[1], args[3] }
            
            if top(args) >= 2  then (
                compiledNames = @args[2]
                if compiledNames ==@ *  then compiledNames = @allNames    )
            else  compiledNames = @allNames
            
            (params<<args)()
        ) /= passed  then (
            print("usage: [bytecode string = ] disassemble((string) compiled_code [ , (string array) namespace ")
            printl("[, (int) disassemble_start_position ]] [ ; expandFunctions/flagPosition = ... ]")
            compiledNames = @nothing
            return      )
        
        if size(bytecodeString) mod wordSize /= 0 or size(bytecodeString) == 0  then (
            printl("disassemble() error:  code size is not N*size(int) > 0")
            compiledNames = @nothing
            return      )
        
        numWords = size(bytecodeString)/wordSize
        if disasmStartPos > numWords  then (
            printl("disassemble() error:  start_pos > # of words")
            compiledNames = @nothing
            return      )
        
        numCompiledNames = top(compiledNames)
        
        bytecodeWords[^numWords]
        bytecodeWords =! bytecodeString
        output = ""
        
        if trap(
            if returnDisassembly  then (
                wordCounter = 1
                output = RecursionPackage.writeSentences(wordCounter)
                if wordCounter /= numWords+1  then (
                    cat(output, "[Not the correct end-of-code]\n")
            )   )
            else  (
                wordCounter = disasmStartPos
                output = RecursionPackage.writeExpression(wordCounter)
                args[3] = wordCounter        )
        ) /= passed  then (
            printl("disassemble() error:  problem with the bytecode")
            compiledNames = @nothing
            return       )
        
        compiledNames = @nothing
        
        if not returnDisassembly  then return
        else  return ((rtrn =@ *) = @output)
    }
    
    
    RecursionPackage :: {
        
        doWrite :: bool
        expressionString := ""
        
        writeSentences :: {
            
            WSexpressionTop :: *
            bottomLevel := false
            sentenceString :: string
            
            
            code
            
            WSexpressionTop = @args[1]
            
            sentenceString = ""
            while bytecodeWords[WSexpressionTop] /= 0  do (
                sentenceString = cat(sentenceString, writeExpression(WSexpressionTop))
                if bytecodeWords[WSexpressionTop] /= 0 and returnDisassembly  then (
                    if bottomLevel  then sentenceString = cat(sentenceString, "\n")
                    else if doWrite  then sentenceString = cat(sentenceString, ", ")
            )   )
            
            if WSexpressionTop > flagPosition and flagPosition /= 0 and returnDisassembly  then (
                cat(output, "<-- *****   ")
                flagPosition = 0            )
            if bottomLevel and returnDisassembly  then cat(output, "\n")
            
            WSexpressionTop =@ *
            return sentenceString
        }
        
        
        writeExpression :: {
            
            constBool :: bool
            constChar :: char
            constInt :: numChars :: charCounter :: instructionArgs :: argCounter :: int
            constDouble :: double
            constString :: theCmd :: string
            
            WEcat_fulloutput :: {  ; theCmd = cat(theCmd, args, " ")  }
            WEcat_linesonly :: { }
            WEcat *:: *
            
            currentCommand :: extraSkip :: mID :: int
            
            expressionTop *:: *
            
            
            code
            
            theCmd = ""
            
            if returnDisassembly and doWrite  then WEcat = @WEcat_fulloutput
            else WEcat = @WEcat_linesonly
            
            expressionTop = @args[1]
            
            currentCommand = bytecodeWords[expressionTop]
            if currentCommand == 0  then return
            
            WEcat(instructionWords[currentCommand])
            extraSkip = extraWords[currentCommand]
            
            instructionArgs = instructionArguments[currentCommand]
            
            
                | some commands get special treatment
            
                | jump commands -- we write out the jump offset
            
            if currentCommand >= 1 and currentCommand <= 3  then (
                constInt =! bytecodeWords[expressionTop+1]
                WEcat(constInt)
                extraSkip = 1       )
            
            
                | Cicada library functions -- substitute the name of the specific library (if it's obvious)
            
            else if currentCommand == 7  then (
                if bytecodeWords[expressionTop+1] == 54  then (
                    theCmd = ""
                    WEcat(CicadaFunctionWords[bytecodeWords[expressionTop+2]+1])
                    extraSkip = 2
                    instructionArgs = that-1
            )   )
            
            
                | define-equate-etc. operators -- write in the name of the specific operator if it's a common one
            
            else if currentCommand == 8  then (
                theCmd = ""
                if trap(WEcat(dgWords[binsearch(dgWords[*].ID, bytecodeWords[expressionTop+1])].abbr)) /= passed  then (
                    WEcat(instructionWords[currentCommand], " ", bytecodeWords[expressionTop+1])
            )   )
            
            
                | search-member or step-to-member -- write in the member name
            
            else if currentCommand == 10 or currentCommand == 11  then (
                mID = bytecodeWords[expressionTop+1]
                if compiledNames == @nothing   then WEcat(mID)
                else if mID < 0   then WEcat("$", -mID)
                else if mID > numCompiledNames or mID == 0   then WEcat("??")
                else  WEcat("$", compiledNames[mID])
                extraSkip = 1       )
            
            
                | constant:  bool, char, int, double, string -- just write out the constant in the disassembly
            
            else if currentCommand == 52  then (
                constBool = (bytecodeWords[expressionTop+1] /= 0)
                theCmd = ""
                if constBool  then WEcat("true")
                else  WEcat("false")
                extraSkip = 1       )
            
            else if currentCommand == 53  then (
                theCmd = ""
                constChar = bytecodeWords[expressionTop+1]
                WEcat("'", constChar, "'")
                extraSkip = 1       )
            
            else if currentCommand == 54  then (
                theCmd = ""
                constInt = bytecodeWords[expressionTop+1]
                WEcat(constInt)
                extraSkip = 1       )
            
            else if currentCommand == 55  then (
                theCmd = ""
                constDouble =! bytecodeWords[<expressionTop+1, expressionTop+doubleSizeInInts>]
                WEcat(constDouble)
                extraSkip = doubleSizeInInts        )
            
            else if currentCommand == 56  then (
                theCmd = ""
                numChars = bytecodeWords[expressionTop+1]
                constString =! bytecodeWords[<expressionTop+2, expressionTop+ceil(numChars/wordSize)+1>]
                constString = constString[<1, numChars>]
                
                for (charCounter::int) in <1, numChars>  (
                if constString[charCounter] < 32 or constString[charCounter] > 127 then (
                    constString[charCounter] = 35
                ))
                
                WEcat("\"", constString, "\"")
                extraSkip = ceil(numChars/wordSize)+1     )
            
            
                | code block -- write it in {}
            
            else if currentCommand == 57  then (
                theCmd = ""
                expressionTop = that + 1
                subExpression :: RecursionPackage
                subExpression.doWrite = doWrite and expandFunctions
                
                if doWrite and not subExpression.doWrite  then theCmd = "{ ... "
                else  theCmd = "{ "
                WEcat(subExpression.writeSentences(expressionTop), "}")        )
            
            
                | if we're trying to mark a spot in the code, write out a marker there
            
            expressionTop = that + 1 + extraSkip
            if expressionTop > flagPosition and flagPosition /= 0   then (
                command = cat(command, "<-- ***** ")
                flagPosition = 0            )
            
            
                | now write out each of the arguments of the operator
            
            if instructionArgs > 0  then (
                subExpression::RecursionPackage
                WEcat("(")
                for (argCounter::int) in <1, instructionArgs>  (
                    if argCounter /= 1  then WEcat(",")
                    subExpression.doWrite = doWrite
                    WEcat(subExpression.writeExpression(expressionTop))        )
                WEcat(")")
            )
            
            expressionTop =@ *
            
            if top(theCmd) > 0  then theCmd[^top-1]
            return theCmd
        }
    }
    RecursionPackage.writeSentences.bottomLevel = true
    RecursionPackage.doWrite = true
}

disassemble := @disassembler.runDisAsm





| **************** USER DEFINITIONS **************** |
