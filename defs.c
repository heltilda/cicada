"|*\n"
" *  defs.cicada\n"
" *  This file contains a set of useful definitions that are\n"
" *  loaded by the terminal when Cicada is run interactively.\n"
" *  \n"
" *  Cicada\n"
" *  Copyright (C) 2017 Brian C. Ross\n"
" *  \n"
" *  Permission is hereby granted, free of charge, to any person obtaining a copy\n"
" *  of this software and associated documentation files (the \"Software\"), to deal\n"
" *  in the Software without restriction, including without limitation the rights\n"
" *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
" *  copies of the Software, and to permit persons to whom the Software is\n"
" *  furnished to do so, subject to the following conditions:\n"
" *  \n"
" *  The above copyright notice and this permission notice shall be included in all\n"
" *  copies or substantial portions of the Software.\n"
" *  \n"
" *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
" *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
" *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
" *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
" *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
" *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
" *  SOFTWARE.\n"
" *|\n"
"\n"
"\n"
"\n"
"| *******  Variable & constant definitions  *******\n"
"\n"
"\n"
"passed := 0\n"
"\n"
"e := 2.718281828459045235360287471352662497757247093699959574966\n"
"\n"
"pi := 3.141592653589793238462643383\n"
"\n"
"trap( inf := 1/0 )      | suppress the warning messages on these\n"
"trap( nan := 0/0 )\n"
"\n"
"root := @this\n"
"\n"
"(where :: string) = \"root\"\n"
"\n"
"filePaths :: [1] string\n"
"filePaths[1] = \"\"          | used by run(), Load()  (but not load()!)\n"
"\n"
"\n"
"\n"
"\n"
"| definitions for a user-defined compiler\n"
"\n"
"compiledCommandType :: {\n"
"    cmdString :: string         | the written character sequence of the operator, including arguments\n"
"    precedence :: int           | the order-of-operations precedence level of the operator\n"
"    rtrnTypeString :: string    | contains the allowed return types of the operator\n"
"    bytecodeString :: string    | the bytecode translation of the operator\n"
"}\n"
"\n"
"l_to_r := 1     | left-to-right grouped operator precedence level:  e.g. (a+b)+c\n"
"r_to_l := 2     | right-to-left grouped operator precedence level:  e.g. a=(b=c)\n"
"\n"
"type0arg := \"\\10\"\n"
"type1arg := \"\\11\"\n"
"type2arg := \"\\12\"\n"
"type3arg := \"\\13\"\n"
"type4arg := \"\\14\"\n"
"type5arg := \"\\15\"\n"
"type6arg := \"\\16\"\n"
"type7arg := \"\\17\"\n"
"type8arg := \"\\18\"\n"
"type9arg := \"\\19\"\n"
"typeXarg := \"\\1A\"\n"
"chararg := \"\\1B\"\n"
"stringarg := \"\\1C\"\n"
"commentarg := \"\\1D\"\n"
"optionalargs := \"\\1E\"\n"
"\n"
"type0arg_adapter := \"\\f0\"\n"
"type1arg_adapter := \"\\f1\"\n"
"type2arg_adapter := \"\\f2\"\n"
"type3arg_adapter := \"\\f3\"\n"
"type4arg_adapter := \"\\f4\"\n"
"type5arg_adapter := \"\\f5\"\n"
"type6arg_adapter := \"\\f6\"\n"
"type7arg_adapter := \"\\f7\"\n"
"type8arg_adapter := \"\\f8\"\n"
"type9arg_adapter := \"\\f9\"\n"
"noarg_adapter := \"\\fa\"\n"
"\n"
"int_constant := \"\\fb\"\n"
"double_constant := \"\\fc\"\n"
"variable_name := \"\\fd\"\n"
"\n"
"argXtype := \"\\fe\"\n"
"\n"
"arg1 := \"\\11\"\n"
"arg2 := \"\\12\"\n"
"arg3 := \"\\13\"\n"
"arg4 := \"\\14\"\n"
"arg5 := \"\\15\"\n"
"arg6 := \"\\16\"\n"
"arg7 := \"\\17\"\n"
"arg8 := \"\\18\"\n"
"arg9 := \"\\19\"\n"
"\n"
"anonymousmember := \" \\1a \"\n"
"removedexpression := \"\\1b\"\n"
"inbytecode := \"\\1c\"\n"
"\n"
"\n"
"\n"
"\n"
"| *******  Wrappers for predefined C functions  *******\n"
"\n"
"\n"
"newCompiler :: {\n"
"    \n"
"    commandDefinitions :: [] compiledCommandType\n"
"    precedenceLevelAssociativity :: [] int\n"
"    compilerID :: int\n"
"    \n"
"    code\n"
"    \n"
"    commandDefinitions = @args[1]\n"
"    precedenceLevelAssociativity = @args[2]\n"
"    $newCompiler(commandDefinitions, precedenceLevelAssociativity, compilerID)\n"
"    \n"
"    return compilerID\n"
"}\n"
"\n"
"\n"
"compile :: {\n"
"    \n"
"    scriptStr :: bytecodeStr :: opPositionString :: string\n"
"    memberNames :: [] string\n"
"    numMemberNames :: prevNumNames :: int\n"
"    params :: { compilerID :: int, filename :: string; compilerID = 1, filename = \"\" }\n"
"    \n"
"    code\n"
"    \n"
"    scriptStr = args[1]\n"
"    memberNames =@ opPositionString =@ *\n"
"    if top(args) >= 2  then (\n"
"        opPositionString = @args[2]\n"
"        if top(args) == 3  then (\n"
"            memberNames = @args[3]\n"
"    )   )\n"
"    else  opPositionString @:: string\n"
"    \n"
"    params(), (params<<args)()\n"
"    \n"
"    $compile(params.compilerID, scriptStr, params.filename, opPositionString, numMemberNames, bytecodeStr)\n"
"    \n"
"    if memberNames /= @nothing  then (\n"
"        prevNumNames = top(memberNames)\n"
"        memberNames[^numMemberNames]\n"
"        $getMemberNames(params.compilerID, memberNames, prevNumNames)\n"
"        memberNames =@ *        )\n"
"    \n"
"    return bytecodeStr\n"
"}\n"
"\n"
"\n"
"transform :: {\n"
"    \n"
"    bytecode :: string\n"
"    target :: *\n"
"    newTarget :: bool\n"
"    params :: { codePath :: *, errInfo :: { filename :: sourceCode :: opCharPositions :: string } ;\n"
"                remove codePath, codePath :: *, errInfo = { \"\", \"\", \"\" } }\n"
"    \n"
"    code\n"
"    \n"
"    bytecode = args[1]\n"
"    newTarget = trap(target = @args[2]) /= passed or target == @nothing\n"
"    if newTarget  then (target =@ *) @:: {}\n"
"    \n"
"    params(), (params<<args)()\n"
"    \n"
"    $transform(bytecode, target, params.codePath, params.errInfo)\n"
"    \n"
"    if newTarget  then return target\n"
"    else  target =@ *\n"
"}\n"
"\n"
"\n"
"throw :: {\n"
"    \n"
"    errCode :: errScriptNo :: errIndex :: int\n"
"    params :: { doWarning::bool; doWarning=false }\n"
"    \n"
"    code\n"
"    \n"
"    errCode = args[1]\n"
"    params(), (params<<args)()\n"
"    \n"
"    if top(args) == 1  then $throw(errCode, params.doWarning, args, 1, 1)       | throw error in the calling script\n"
"    else  (\n"
"        { errScriptNo, errIndex } = { args[3], args[4] }\n"
"        $throw(errCode, params.doWarning, args[2], errScriptNo, errIndex)       | don't alias args[2] since we won't have a chance to unlink it\n"
"    )\n"
"}\n"
"\n"
"\n"
"size :: {\n"
"    \n"
"    theSize :: int\n"
"    params :: { storageSize::bool; storageSize = false }\n"
"    \n"
"    code\n"
"    \n"
"    params(), (params<<args)()\n"
"    \n"
"    (theSize =@ *) :: int\n"
"    $size(args[1], params.storageSize, theSize)\n"
"    \n"
"    return theSize\n"
"}\n"
"\n"
"\n"
"var_member_property :: {\n"
"    \n"
"    f :: rtrn :: rtrnType :: *\n"
"    params :: { memberNumber::int; memberNumber = 0 }\n"
"    \n"
"    code\n"
"    \n"
"    params(), (params<<args)()\n"
"    \n"
"    (rtrn =@ *) :: rtrnType\n"
"    f(args[1], params.memberNumber, rtrn)\n"
"    \n"
"    return rtrn\n"
"}\n"
"\n"
"type :: var_member_property : { rtrnType :: int, f :: { ; $type(args[1], args[2], args[3]) } }\n"
"bytecode :: var_member_property : { rtrnType :: string, f :: { ; $bytecode(args[1], args[2], args[3]) } }\n"
"\n"
"\n"
"member_ID :: {\n"
"    \n"
"    theID :: memberNumber :: int\n"
"    \n"
"    code\n"
"    \n"
"    memberNumber = args[2]\n"
"    \n"
"    (theID =@ *) :: int\n"
"    $member_ID(args[1], memberNumber, theID)\n"
"    \n"
"    return theID\n"
"}\n"
"\n"
"\n"
"load :: {\n"
"    \n"
"    scriptID :: int\n"
"    fileName :: fileStr :: string\n"
"    \n"
"    code\n"
"    \n"
"    if trap( {fileName} = args ) == passed  then $load(fileName, fileStr)\n"
"    else  ( { scriptID } = args, $load(scriptID, fileStr) )\n"
"    \n"
"    return fileStr\n"
"}\n"
"\n"
"save :: { fileName :: fileStr :: string; trap(args;;; {fileName, fileStr} = args), $save(fileName, fileStr) }\n"
"\n"
"input :: { str::string; $input(args, str), return str }\n"
"print :: { ; $print(args) }\n"
"\n"
"read_string :: { ; return $read_string(args)  }\n"
"\n"
"print_string :: {\n"
"    \n"
"    str :: string\n"
"    params :: { maxFloatingDigits :: int; maxFloatingDigits = 6 }\n"
"    \n"
"    code\n"
"    \n"
"    params(), (params<<args)()\n"
"    $print_string(str, params.maxFloatingDigits, args)\n"
"    \n"
"    return str\n"
"}\n"
"\n"
"\n"
"find :: {\n"
"    \n"
"    str :: substr :: string\n"
"    position :: int\n"
"    params :: { mode :: startPosition :: int; mode = 1; if mode == -1  then startPosition = size(str), else  startPosition = 1 }\n"
"    \n"
"    code\n"
"    \n"
"    { str, substr } = args\n"
"    params(), (params<<args)()\n"
"    params#2(), (params<<args#2)()\n"
"    \n"
"    $find(str, substr, params.mode, params.startPosition, position)\n"
"    \n"
"    return position\n"
"}\n"
"\n"
"\n"
"random :: {\n"
"    \n"
"    array :: [] double\n"
"    num :: double\n"
"    \n"
"    code\n"
"    \n"
"    if top(args) == 0  then ( $random(num), return num )\n"
"    else  ( array = @args[1], $random(array) )\n"
"}\n"
"\n"
"mathUnaryOp :: {\n"
"    \n"
"    source :: dest :: [] double\n"
"    sourceNum :: destNum :: double\n"
"    doF :: *\n"
"    \n"
"    code\n"
"    \n"
"    if trap({sourceNum} = args) == passed  then ( doF(sourceNum, destNum), return destNum )\n"
"    else  ( source[^top(args[1])], source = args[1], dest[^top(source)], doF(source, dest), return dest )\n"
"}\n"
"\n"
"abs :: mathUnaryOp : { doF :: { ; $abs(args[1], args[2]) } }\n"
"floor :: mathUnaryOp : { doF :: { ; $floor(args[1], args[2]) } }\n"
"ceil :: mathUnaryOp : { doF :: { ; $ceil(args[1], args[2]) } }\n"
"exp :: mathUnaryOp : { doF :: { ; $exp(args[1], args[2]) } }\n"
"log :: mathUnaryOp : { doF :: { ; $log(args[1], args[2]) } }\n"
"cos :: mathUnaryOp : { doF :: { ; $cos(args[1], args[2]) } }\n"
"sin :: mathUnaryOp : { doF :: { ; $sin(args[1], args[2]) } }\n"
"tan :: mathUnaryOp : { doF :: { ; $tan(args[1], args[2]) } }\n"
"acos :: mathUnaryOp : { doF :: { ; $acos(args[1], args[2]) } }\n"
"asin :: mathUnaryOp : { doF :: { ; $asin(args[1], args[2]) } }\n"
"atan :: mathUnaryOp : { doF :: { ; $atan(args[1], args[2]) } }\n"
"\n"
"mathBinaryOp :: {\n"
"    \n"
"    source1 :: source2 :: dest :: [] double\n"
"    sourceNum1 :: sourceNum2 :: destNum :: double\n"
"    arrayTop :: int\n"
"    isScalar :: bool\n"
"    doF :: arg1 :: arg2 :: *\n"
"    \n"
"    code\n"
"    \n"
"    arrayTop = 1, isScalar = true\n"
"    if trap(sourceNum1 = args[1]) == passed  then arg1 = @sourceNum1\n"
"    else  (  source1[^arrayTop = top(args[1])], source1 = args[1], arg1 = @source1, isScalar = false  )\n"
"    if trap(sourceNum2 = args[2]) == passed  then arg2 = @sourceNum2\n"
"    else  (  source2[^arrayTop = top(args[2])], source2 = args[2], arg2 = @source2, isScalar = false  )\n"
"    \n"
"    if isScalar  then (  doF(arg1, arg2, destNum), return destNum  )\n"
"    else (  dest[^arrayTop], doF(arg1, arg2, dest), return dest  )\n"
"}\n"
"\n"
"add :: mathBinaryOp : { doF :: { ; $add(args[1], args[2], args[3]) } }\n"
"subtract :: mathBinaryOp : { doF :: { ; $subtract(args[1], args[2], args[3]) } }\n"
"multiply :: mathBinaryOp : { doF :: { ; $multiply(args[1], args[2], args[3]) } }\n"
"divide :: mathBinaryOp : { doF :: { ; $divide(args[1], args[2], args[3]) } }\n"
"pow :: mathBinaryOp : { doF :: { ; $pow(args[1], args[2], args[3]) } }\n"
"\n"
"springCleaning :: { ; $springCleaning(args) }\n"
"\n"
"if trap(this_is_the_terminal) == passed  then return          | don't load more than we have to\n"
"\n"
"\n"
"\n"
"\n"
"| **************  Other functions  **************\n"
"\n"
"| variables:     new()\n"
"| file I/O:      Load(), Save(), cd(), pwd()\n"
"| strings:       lowercase(), uppercase(), C_string(), cat()\n"
"| printing:      printl(), sprint(), mprint()\n"
"| tables:        writeTable(), saveTable(), readTable(), readInput(), readFile()\n"
"| running code:  do_in(), compile_and_do_in(), run()\n"
"| workspace:     go(), jump(), what()\n"
"| numeric:       min(), max(), sum(), mean(), round(), sort(), binsearch()\n"
"| misc:          disassemble()\n"
"\n"
"\n"
"\n"
"| new(var) creates a new object using var as a template;\n"
"| used for creating new return objects for functions\n"
"\n"
"new :: {\n"
"    rtrn :: *\n"
"    copy_err :: int\n"
"    \n"
"    code\n"
"    \n"
"    rtrn =@ *\n"
"    if top(args) > 2  then (\n"
"        printl(\"usage:  new_object = new(template [, data variable] [; code to modify new variable])\")\n"
"        return      )\n"
"    \n"
"    rtrn @:: args[1]\n"
"    \n"
"    if type(rtrn) >= 5  then (rtrn<<args)()\n"
"    \n"
"    if top(args) == 1  then &\n"
"        copy_err = trap( rtrn = args[1] )\n"
"    else if trap(type(args[2])) == passed  then &\n"
"        copy_err = trap( rtrn = args[2] )\n"
"    else  copy_err = passed\n"
"    \n"
"    if copy_err /= passed  then &\n"
"        printl(\"new():  could not copy template data (error \", copy_err, \")\")\n"
"    \n"
"    return rtrn\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"| fileStr = Load(filename) and Save(filename, fileStr) extend Cicada's load() and save() (no caps)\n"
"| by searching all paths in the filePaths[] array\n"
"\n"
"doInAllDirectories :: {\n"
"    \n"
"    fileName :: fileString :: fullPathName :: myname :: myusage :: string\n"
"    counter :: errCode :: int\n"
"    params :: { printError :: bool }\n"
"    \n"
"    code\n"
"    \n"
"    if trap( myargs = args ) /= 0  then (\n"
"        printl(\"usage:  \", myusage)\n"
"        return          )\n"
"    \n"
"    params.printError = true\n"
"    (params<<args)()\n"
"    \n"
"    errCode = counter = 1\n"
"    while errCode /= passed and counter <= top(filePaths)  do (\n"
"        fullPathName = print_string(filePaths[counter], fileName)\n"
"        errCode = trap(myfunction(fullPathName, fileString))\n"
"        counter = that + 1      )\n"
"    \n"
"    if errCode /= passed  then (\n"
"        if params.printError  then printl(myname, \"() error:  file \\\"\", fileName, \"\\\" could not be opened\\n\")\n"
"        return          )\n"
"    \n"
"    return myrtrn()\n"
"}\n"
"\n"
"Load :: doInAllDirectories : {\n"
"        myname = \"Load\", myusage = \"file_string = Load(file_name)\",\n"
"        myargs :: { fileName },\n"
"        myfunction :: { ; args[2] = load(args[1]) },\n"
"        myrtrn :: { ; return new(fileString) }          }\n"
"\n"
"Save :: doInAllDirectories : {\n"
"        myname = \"Save\", myusage = \"Save(file_name, file_string)\",\n"
"        myargs :: { fileName, fileString },\n"
"        myfunction :: { ; save(args[1], args[2]) },\n"
"        myrtrn :: { ; return * }        }\n"
"\n"
"\n"
"\n"
"| cd(newDir) changes the working directory\n"
"\n"
"cd :: {\n"
"    \n"
"    newDirectory :: string\n"
"    \n"
"    code\n"
"    \n"
"    if trap({ newDirectory } = args) /= passed  then &\n"
"        print(\"usage:  cd(directory name)\")\n"
"    \n"
"    else  filePaths[^1] = newDirectory\n"
"}\n"
"\n"
"\n"
"\n"
"| pwd() prints all working directories\n"
"\n"
"pwd :: {\n"
"    \n"
"    loopDir :: int\n"
"    \n"
"    code\n"
"    \n"
"    for loopDir in <1, top(filePaths)>  printl(filePaths[loopDir])\n"
"}\n"
"\n"
"\n"
"\n"
"| lowercase(str), uppercase(str) change the case of all characters in the string 'str'\n"
"\n"
"lowercase :: {\n"
"    \n"
"    (A_char :: int) = 'A'\n"
"    (Z_char :: int) = 'Z'\n"
"    (ASCII_diff :: int) = 'a'\n"
"    ASCII_diff = that - A_char\n"
"    \n"
"    myname := \"lowercase\"\n"
"    \n"
"    \n"
"    str :: string\n"
"    clu :: str_top :: int\n"
"    \n"
"    code\n"
"    \n"
"    if trap(\n"
"        { str } = args\n"
"    ) /= passed  then (\n"
"        printl(\"usage:  \", myname, \"(my_string)\")\n"
"        return      )\n"
"    \n"
"    str_top = top(str)\n"
"    \n"
"    for clu in <1, str_top>  (\n"
"    if (str[clu] >= A_char and str[clu] <= Z_char)  then (\n"
"        str[clu] = that + ASCII_diff\n"
"    ))\n"
"    \n"
"    return new(str)\n"
"}\n"
"\n"
"uppercase :: lowercase : { A_char = 'a', Z_char = 'z', ASCII_diff = -that }\n"
"\n"
"\n"
"\n"
"| C_string(str) creates a byte block containing the provided string 'str' in C-string format\n"
"\n"
"C_string :: {\n"
"    \n"
"    str :: string\n"
"    \n"
"    code\n"
"    \n"
"    if trap(\n"
"        { str } = args\n"
"    ) /= passed  then (\n"
"        printl(\"usage:  byte-block-string = call_string((string) my_string\")\n"
"        return      )\n"
"    \n"
"    if str[top] /= '\\00'  then str = cat(str, \"\\00\")\n"
"    \n"
"    return new(str)\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"| cat(a, b, ...) returns the concatenation of its arguments as a string; same as print_string\n"
"\n"
"cat :: { ; return new(print_string(args)) }\n"
"\n"
"\n"
"\n"
"| printl(a, b, ...) prints its arguments with a following end-of-line\n"
"\n"
"printl :: {  code, print(args, \"\\n\")  }\n"
"\n"
"\n"
"\n"
"| mprint(M) prints M as a matrix; also works with tables and lists\n"
"\n"
"mprint :: {\n"
"    \n"
"    mprintArgs :: *\n"
"    \n"
"    code\n"
"    \n"
"    mprintArgs = @args\n"
"    print(writeTable(args[1]; (this<<mprintArgs)()))\n"
"    mprintArgs = @nothing\n"
"}\n"
"\n"
"\n"
"\n"
"| sprint(a, b, ...) prints its arguments as a set -- good for printing variables, structures, etc.\n"
"\n"
"sprint :: {\n"
"    argCounter :: argTop :: int\n"
"    firstTime :: bool\n"
"    argsToPrint :: *\n"
"    \n"
"    code\n"
"    \n"
"    if firstTime  then (\n"
"        if trap(size(args)) /= passed  then (\n"
"            printl(\"sprint() error:  self-reference\")\n"
"            return      )\n"
"        argsToPrint = @args   )    | don't use args in the arguments\n"
"    else  argsToPrint = @args[1]\n"
"    \n"
"    argTop = top(argsToPrint)\n"
"    for argCounter in <1, argTop>  (\n"
"        if (argsToPrint[argCounter] /=@ *)  then (\n"
"            if (type(argsToPrint[argCounter]) >= 5)  then (\n"
"                print(\"{ \")\n"
"                (ncclib_sprint::sprint).firstTime = false\n"
"                ncclib_sprint(argsToPrint[argCounter])\n"
"                print(\" }\")     )\n"
"            else  (\n"
"                print(argsToPrint[argCounter])\n"
"        )   )\n"
"        else  print(\"*\")\n"
"        if argCounter < argTop  then print(\", \")\n"
"        else if firstTime  then print(\"\\n\")\n"
"    )\n"
"    \n"
"    argsToPrint =@ *        | to prevent jamming\n"
"}\n"
"sprint.firstTime = true\n"
"\n"
"trap(calculator = @sprint)\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"| tableString = writeTable(table) outputs table data as a string\n"
"\n"
"writeTable :: {\n"
"    \n"
"    c1 :: c2 :: idx1 :: int\n"
"    fileWriteString :: string\n"
"    fields :: [] string\n"
"    theTable :: *\n"
"    \n"
"    params :: { fieldWidth :: maxFloatingDigits :: int, voidString :: string }\n"
"    \n"
"    \n"
"    code\n"
"    \n"
"    (params << { ; fieldWidth = 14, maxFloatingDigits = 6, voidString = \"*\" })()\n"
"    \n"
"    if trap(\n"
"        if top(args) /= 1  then throw(1)\n"
"        theTable = @args[1]\n"
"        top(theTable)       | check that it's composite\n"
"        \n"
"        (params<<args)()    \n"
"    ) /= passed  then (\n"
"        printl(\"usage:  writeTable(table [; fieldWidth/maxFloatingDigits/voidString = ...])\")\n"
"        theTable =@ *\n"
"        return          )\n"
"    \n"
"    if top(theTable) == 0  then (\n"
"        theTable =@ *\n"
"        return \"\"      )\n"
"    \n"
"    idx1 = top(theTable)\n"
"    stringsTable :: [idx1] string\n"
"    \n"
"    \n"
"        | store each row of our table as an array of strings containing either a) a void symbol,\n"
"        | or b) an array whose elements are separated by a defined number of spaces \n"
"    \n"
"    for c1 in <1, idx1>  (\n"
"        if theTable[c1] == @nothing  then stringsTable[c1] = \"*\\n\"\n"
"        else  (\n"
"            fields[^top(theTable[c1])]\n"
"            backfor c2 in <1, top(fields)>  (\n"
"                fields[c2] = print_string(theTable[c1][c2]; maxFloatingDigits = params.maxFloatingDigits)\n"
"                if top(fields[c2]) < params.fieldWidth  then fields[c2][+<top+1, params.fieldWidth>] = ' '\n"
"                fields[c2][^params.fieldWidth]  )\n"
"            stringsTable[c1] = print_string(fields, \"\\n\")\n"
"    )   )\n"
"    \n"
"    \n"
"        | copy the array of strings into a final big string, unlink our alias and return\n"
"    \n"
"    fileWriteString =! stringsTable\n"
"    \n"
"    theTable = @nothing        | so we don't jam it\n"
"    remove stringsTable\n"
"    \n"
"    return new(fileWriteString)\n"
"}\n"
"\n"
"\n"
"\n"
"| saveTable(filename, table) outputs table data to a file\n"
"\n"
"saveTable :: {\n"
"    \n"
"    saveTableArgs :: *\n"
"    \n"
"    code\n"
"    \n"
"    saveTableArgs = @args\n"
"    Save(args[1], writeTable(args[2]; (this<<saveTableArgs)()))\n"
"    saveTableArgs = @nothing\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"| readTable(table, tableString) fills in a table (1st argument) from text data stored in a string (2nd argument);\n"
"| readInput(table) and readFile(table, fileName) are variations of this\n"
"\n"
"readTable :: {\n"
"    \n"
"    tableString :: string\n"
"    theTable :: *\n"
"    defaults :: { ifHeader :: resizeColumns :: resizeRows :: bool }\n"
"    numLines :: beginningFirstRow :: numColumns :: endFirstRow :: loopChar :: errCode :: int\n"
"    \n"
"    code\n"
"    \n"
"    (defaults<<{ ; ifHeader = false, resizeColumns = resizeRows = true })()\n"
"    errCode = passed\n"
"    \n"
"    if trap(\n"
"        if top(args) /= 2  then throw(1)\n"
"        theTable = @args[1]\n"
"        tableString = args[2]\n"
"        (defaults<<args)()\n"
"    ) /= passed  then (\n"
"        print(\"usage:  readTable(theTable, sourceString [, code, ifHeader/resizeColumns/resizeRows = true/false])\\n\")\n"
"        errCode = 1\n"
"        theTable =@ *, return       )\n"
"    \n"
"    if top(theTable) > 0  then (\n"
"        if type(theTable[1]) <= 4  then (\n"
"            defaults.resizeColumns = that or defaults.resizeRows\n"
"            defaults.resizeRows = false\n"
"    )   )\n"
"    \n"
"    else if trap(theTable[*][*]) /= passed  then defaults.resizeRows = false\n"
"    \n"
"    \n"
"        | handle resizing of the table here..\n"
"    \n"
"    beginningFirstRow = 1\n"
"    if defaults.resizeColumns or defaults.resizeRows  then (\n"
"        \n"
"        \n"
"            | first calculate the number of rows in the table, by counting the number of '\\n's\n"
"            | (this should work on both UNIX machines and PCs, since they each have one \\n per line break)\n"
"        \n"
"        if tableString == \"\"  then numLines = 0\n"
"        else  (\n"
"            numLines = find(tableString, \"\\n\", 0) + 1\n"
"            if tableString[top] == '\\n' or tableString[top] == '\\r'  then numLines = that-1\n"
"            \n"
"            if defaults.ifHeader  then (\n"
"                numLines = that - 1\n"
"                beginningFirstRow = max(1, find(tableString, \"\\n\", 1)+1)     )\n"
"            \n"
"            \n"
"                | if we're resizing each row, then calculate number of columns by examining the first row\n"
"            \n"
"            endFirstRow = find(tableString, \"\\n\", 1, beginningFirstRow)\n"
"            if endFirstRow == 0  then endFirstRow = top(tableString)+1\n"
"            \n"
"            if loopChar <= size(tableString)  then (\n"
"            if defaults.resizeRows  then (\n"
"                numColumns = 0, loopChar = beginningFirstRow\n"
"                while loopChar < endFirstRow  do (\n"
"                    if tableString[loopChar] > 32 and tableString[loopChar] < 127  then (\n"
"                        numColumns = that+1\n"
"                        {  loop  (\n"
"                            if tableString[loopChar] <= 32 or tableString[loopChar] >= 127  then return\n"
"                            loopChar = that+1\n"
"                        ) until loopChar >= endFirstRow   }\n"
"                    )\n"
"                    \n"
"                    {  while loopChar < endFirstRow  do  (\n"
"                        if tableString[loopChar] > 32 and tableString[loopChar] < 127  then return\n"
"                        loopChar = that+1\n"
"        )   })) )   )\n"
"        \n"
"        if numLines < 0  then numLines = 0\n"
"        \n"
"        \n"
"            | now do the resize(s) (how we do this efficiently depends on which dimensions are being resized)\n"
"        \n"
"        if not defaults.resizeRows  then (\n"
"        if trap(theTable[^numLines]) /= passed  then (\n"
"            print(\"readTable():  number of rows could not be changed -- mismatched read will result\\n\")\n"
"            errCode = 2\n"
"        ))\n"
"        \n"
"        else if not defaults.resizeColumns  then (\n"
"        if trap(theTable[*][^numColumns]) /= passed  then (\n"
"            print(\"readTable():  number of columns could not be changed -- mismatched read will result\\n\")\n"
"            errCode = 2\n"
"        ))\n"
"        \n"
"        else  (\n"
"        if trap( theTable[^0], theTable[*][^numColumns], theTable[^numLines] ) /= passed  then (\n"
"            print(\"readTable():  number of rows & columns could not be changed -- mismatched read will result\\n\")\n"
"            errCode = 2\n"
"        ))\n"
"    )\n"
"    \n"
"    if tableString /= \"\"  then tableString = that[<beginningFirstRow, top>]\n"
"    if trap( ; read_string(tableString, theTable)  ) /= passed  then (\n"
"        print(\"readTable():  table not read properly\\n\")\n"
"        if errCode == passed  then errCode = 3      )\n"
"    \n"
"    theTable =@ *\n"
"}\n"
"\n"
"readInput :: {  holdArgs :: *; holdArgs = @args, readTable(holdArgs[1], str:=input(); (this<<holdArgs)()), holdArgs = @nothing  }\n"
"readFile :: {  holdArgs :: *; holdArgs = @args, readTable(holdArgs[1], Load(holdArgs[2]); (this<<holdArgs)()), holdArgs = @nothing  }\n"
"\n"
"\n"
"\n"
"\n"
"| do_in(location [, searchPath [, toRun_args [, bytecodeWordsMod_args]]]; toRun [; bytecodeWordsMod code])\n"
"| compile_and_do_in(location [, searchPath [, toRun_args [, bytecodeWordsMod_args]]]; toRun [; bytecodeWordsMod code])\n"
"| - these run the compiled code / uncompiled string 'toRun' in a designated location with an optional search path;\n"
"|   2nd coding section allows changes to the bytecode after compilation of the script\n"
"\n"
"do_in :: {\n"
"    params :: *\n"
"    bytecodeString :: scriptString :: string\n"
"    rtrn :: c1 :: bytecode_word :: bytecode_words_num :: bc0 :: bcf :: int\n"
"    target :: searchPath :: *\n"
"    no_path :: { * }, default_path :: { }\n"
"    myname := \"do_in\"\n"
"    compiledCode :: {}\n"
"    \n"
"    \n"
"    code\n"
"    \n"
"    if (myname == \"compile_and_do_in\")  then (\n"
"        trap(remove scriptSpace)\n"
"        scriptSpace :: {}\n"
"        (scriptSpace<<args)()       )\n"
"    \n"
"    if trap(\n"
"        if top(args) > 4  then throw(1)\n"
"        \n"
"        if top(args) == 0  then target = @root\n"
"        else  target = @args[1]\n"
"        \n"
"        if top(args) >= 2  then (\n"
"            if (trap(if args[2] == @nothing then throw(1)) /= passed)  then searchPath = @no_path\n"
"            else  searchPath = @args[2]       )\n"
"        \n"
"        else  searchPath = @default_path\n"
"        \n"
"        if myname == \"compile_and_do_in\"  then (\n"
"            { scriptString } = scriptSpace\n"
"            remove scriptSpace      )\n"
"    ) /= passed  then (\n"
"        print(\"usage:  \", myname, \"(target [, { search path } [, { script args } [, { bytecode_mod args }]]]; \")\n"
"        printl(\"script to run [; script to modify BytecodeArray[]])\")\n"
"        target = @searchPath = @nothing\n"
"        return      )\n"
"    \n"
"    remove params           | the user may want to work in this variable, so clean it out\n"
"    params :: { bytecodeWords :: [1] int }\n"
"    \n"
"    \n"
"        | do_in() extracts the compiled code from the args..\n"
"    \n"
"    if myname == \"do_in\"  then (\n"
"        \n"
"        params.bytecodeWords[*] =! (bytecodeString = bytecode(args))\n"
"        bytecode_words_num = top(params.bytecodeWords)\n"
"        bytecode_word = 1\n"
"        \n"
"        bc0 = bcf = 0\n"
"        {\n"
"            while bytecode_word <= bytecode_words_num  do (\n"
"                if (params.bytecodeWords[bytecode_word] == 4 or params.bytecodeWords[bytecode_word] == 0)  then (\n"
"                    if bc0 == 0  then (\n"
"                        bc0 = bytecode_word\n"
"                        if params.bytecodeWords[bytecode_word] == 0  then return     )\n"
"                    else  (\n"
"                        bcf = bytecode_word\n"
"                        return\n"
"                )   )\n"
"                disassemble(bytecodeString, *, bytecode_word)\n"
"            )\n"
"        }\n"
"        \n"
"        if bcf /= 0  then &\n"
"            remove params.bytecodeWords[<bcf, top(params.bytecodeWords)>]\n"
"        remove params.bytecodeWords[<1, bc0>]\n"
"        params.bytecodeWords[+top+1] = 0\n"
"    )\n"
"    \n"
"    \n"
"        | .. whereas compile_and_do_in() compiles the script string\n"
"    \n"
"    else  (\n"
"        \n"
"        rtrn = trap( ; bytecodeString = compile(scriptString))\n"
"        if rtrn /= passed  then return\n"
"        \n"
"        params.bytecodeWords[*] =! bytecodeString\n"
"    )\n"
"    \n"
"    \n"
"        | allow the user to modify the compiled bytecode\n"
"    \n"
"    if (trap(if args[4] == @nothing  then throw(1)) == passed)  then &\n"
"        (params<<args#2)(args[4])\n"
"    \n"
"    else  (params<<args#2)()\n"
"    \n"
"    \n"
"        | run the bytecode\n"
"    \n"
"    bytecodeString =! params.bytecodeWords\n"
"    \n"
"    if trap( ; transform(bytecodeString, compiledCode, searchPath)) == passed  then (\n"
"        if top(args) >= 3   then (\n"
"        if trap(if args[3] == @nothing then throw(1)) == passed  then (\n"
"            return (target<<compiledCode#0)(args[3])\n"
"        ))\n"
"        return (target<<compiledCode#0)()      )\n"
"    \n"
"    searchPath = @target = @nothing\n"
"}\n"
"\n"
"compile_and_do_in :: do_in : { myname = \"compile_and_do_in\" }\n"
"\n"
"\n"
"\n"
"\n"
"| errCode = run(file_name [, location]) runs the code stored in a file, in the workspace or optionally in 'location' \n"
"\n"
"run :: {\n"
"    \n"
"    (doCleanUp :: bool) = true\n"
"    (caseSensitive :: bool) = false\n"
"    \n"
"    scriptGlobalVars :: { }\n"
"    \n"
"    getvarlist :: {\n"
"        \n"
"        c1 :: int\n"
"        varlistarray :: [] int\n"
"        \n"
"        code\n"
"        \n"
"        varlistarray[^top(args[1])]\n"
"        for c1 in <1, top(args[1])>  &\n"
"            varlistarray[c1] = member_ID(args[1], c1)\n"
"        \n"
"            | next line:  must be careful not to cause one of sort()'s trap()s to fail\n"
"            | that means:  pass 2nd arg, and provide a table that can be copied using :=\n"
"        \n"
"        sort(varlistarray, 1)\n"
"        \n"
"        return new(varlistarray)              }\n"
"    \n"
"    \n"
"    code\n"
"    \n"
"    return new(run_template)(args)      | new() since the new script might also call run()\n"
"}\n"
"\n"
"run.run_template :: {\n"
"    \n"
"        | define everything using this.var :: .. -- otherwise there can be conflict w/ global vars\n"
"        | when making new copies of run_template() at the end of run()\n"
"    \n"
"    loopID :: loopNewVar :: numNewVars :: ID_array_top :: SGV_ID :: rtrn :: int\n"
"    nameComparison :: fileName :: scriptString :: bytecodeString :: opPositions :: string\n"
"    targetVariable :: ID_array :: scriptReturnValue :: oldvarlist :: newvarlist :: *\n"
"    bytecodeContainer :: removeContainer :: {}\n"
"    \n"
"    remove_member_code :: [] int, rmc_string :: string\n"
"    remove_member_code[*] =! compile(\"code, remove x\")\n"
"    \n"
"    runLoad :: Load : { myname = \"run\" }\n"
"    \n"
"    \n"
"    code\n"
"    \n"
"    self := @this       | do this inside the coding section; otherwise new() won't work (self-reference error)\n"
"    \n"
"    if trap(\n"
"        fileName = args[1][1]\n"
"        if trap(targetVariable = @args[1][2]) /= passed  then targetVariable = @root\n"
"    ) /= passed  then (\n"
"        printl(\"usage:  error_number = run((string) fileName [, variable to run in])\\n\")\n"
"        targetVariable =@ *\n"
"        return          )\n"
"    \n"
"    \n"
"        | load, compile and transform the code\n"
"    \n"
"    if trap(scriptString = runLoad(cat(fileName, \".cicada\"); printError = false)) /= passed  then (\n"
"    if trap(scriptString = runLoad(fileName)) /= passed  then (\n"
"        return\n"
"    ))\n"
"    \n"
"    if trap( ; bytecodeString = compile(scriptString, opPositions; filename=fileName)) == passed  then (\n"
"    if trap( ; transform(bytecodeString, bytecodeContainer, { }, fileName, scriptString, opPositions)) == passed  then (\n"
"        \n"
"        \n"
"            | optionally, remove any variables defined by the script so that if the script redefines them\n"
"            | there won't be a type-mismatch error (this happens with composite variables even if the definitions\n"
"            | haven't changed)\n"
"        \n"
"        if run.doCleanUp  then (\n"
"            \n"
"            if not run.caseSensitive  then fileName = lowercase(that)\n"
"            \n"
"            {   for SGV_ID in <1, top(run.scriptGlobalVars)>  (\n"
"                    nameComparison = run.scriptGlobalVars[SGV_ID].filename\n"
"                    if not run.caseSensitive  then nameComparison = lowercase(that)\n"
"                    \n"
"                    if nameComparison == fileName  then return  )\n"
"                \n"
"                run.scriptGlobalVars[top+1] :: { filename :: string, newvars :: [0] int }\n"
"                run.scriptGlobalVars[top].filename = fileName\n"
"            }\n"
"            \n"
"            ID_array = @run.scriptGlobalVars[SGV_ID].newvars\n"
"            ID_array_top = top(ID_array)\n"
"            \n"
"            for loopID in <1, ID_array_top>  (\n"
"                remove_member_code[4] = ID_array[loopID]\n"
"                rmc_string =! remove_member_code\n"
"                transform(rmc_string, removeContainer)\n"
"                trap((targetVariable<<removeContainer)())      )       | might not exist (e.g. the terminal removes tokens)\n"
"            \n"
"            oldvarlist = @run.getvarlist(targetVariable)\n"
"        )\n"
"        \n"
"        \n"
"            | (try to) run the code, and store the return result\n"
"        \n"
"        if trap( ; scriptReturnValue = @(targetVariable<<bytecodeContainer#0)()  ) /= passed  then scriptReturnValue =@ *\n"
"        \n"
"        \n"
"            | mark variables that were created by the script, so that if we run it again we can remove them\n"
"        \n"
"        if run.doCleanUp  then (\n"
"            \n"
"            newvarlist = @run.getvarlist(targetVariable)\n"
"            \n"
"            ID_array[^0]\n"
"            numNewVars = top(newvarlist)\n"
"            for loopNewVar in <1, numNewVars>  (\n"
"                if binsearch(oldvarlist, newvarlist[loopNewVar]) == @nothing  then (\n"
"                    ID_array[+top+1] = newvarlist[loopNewVar]\n"
"        )   )   )\n"
"    ))\n"
"    \n"
"    targetVariable = @nothing\n"
"    ID_array =@ *\n"
"    \n"
"    return scriptReturnValue\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"| go([; ] path) the workspace variable to path.  Syntax:  go([code, ] path).  go() goes back to path==\"root\".\n"
"| jump([; ] path) is the same as go() except that the new path gets appended onto the current path\n"
"\n"
"if trap(go_path) == passed  then (\n"
"\n"
"    go :: {\n"
"        \n"
"        go_args :: [] int\n"
"        pathstart :: pathword :: numOldSteps :: numMembers :: pathStep :: numNewSteps :: memberNo :: whereIndex :: rtrn :: int\n"
"        newSteps :: [0] { path_start :: path_end :: int }\n"
"        whereWords :: [1] string\n"
"        ga_string :: string\n"
"        goBack := true\n"
"        name := \"go\"\n"
"        \n"
"        whereWords[1] = \"root\"\n"
"        \n"
"        \n"
"        code\n"
"        \n"
"        if top(go_path) == 0  then go_path[1] := @root            | in case someone monkeyed w/ go_path\n"
"        \n"
"        \n"
"            | get the int words of the arguments & skip the code markers\n"
"        \n"
"        go_args[*] =! ga_string = bytecode(args)\n"
"        \n"
"        pathstart = 1\n"
"        while go_args[pathstart] == 4  do pathstart = that + 1\n"
"        \n"
"        \n"
"            | go() just sets the search path back to { root }\n"
"        \n"
"        if (go_args[pathstart] == 0)  then (\n"
"            \n"
"            if goBack  then (\n"
"                go_path[^1] = @root\n"
"                where = whereWords[^1] = \"root\"        )\n"
"            \n"
"            return      )\n"
"        \n"
"        \n"
"            | bytecode should begin w/ \"dg [flags] sm -$xx [path]\" or \"dg [flags] s* sm -$xx [path]\"; get to the path\n"
"        \n"
"        if go_args[pathstart] == 8  then (          | (8, x, 10, ...) = define, search member, ... \n"
"            if go_args[pathstart+2] == 10  then pathstart = that + 4\n"
"            else  (\n"
"                printl(\"usage:  \", name, \"([code, ] path)\")\n"
"                return\n"
"        )   )\n"
"        \n"
"        else if go_args[pathstart] < 15 or go_args[pathstart] > 17  then (      | 15-17 = resize, insert index/indices\n"
"            printl(\"usage:  \", name, \"([code, ] path)\")\n"
"            return      )\n"
"        \n"
"        \n"
"            | find the start and end+1 of each step in the path, using disassemble() to find the end of each expression\n"
"        \n"
"        newSteps[^0]\n"
"        pathword = pathstart\n"
"        while (go_args[pathword] >= 11 and go_args[pathword] <= 15) or go_args[pathword] == 6  do (\n"
"            newSteps[+top+1] = { pathword, pathword }\n"
"            disassemble(ga_string, *, newSteps[top].path_end)\n"
"            if go_args[pathword] == 11  then pathword = that + 2\n"
"            else  pathword = that + 1           )\n"
"        \n"
"        newSteps[+top+1] = { pathword, pathword }\n"
"        disassemble(ga_string, *, newSteps[top].path_end)\n"
"        \n"
"        \n"
"            | find the first step in our path\n"
"            \n"
"            | CASE 1:  it's a search-member, so we want to go back through prior steps and see where that member is\n"
"        \n"
"        numNewSteps = top(newSteps)\n"
"        if go_args[pathword] == 10  then ( {\n"
"            pathStep = top(go_path)\n"
"            while pathStep >= 1  do (\n"
"                if go_path[pathStep] /= @nothing  then (\n"
"                if type(go_path[pathStep]) == 5  then (\n"
"                    numMembers = top(go_path[pathStep])\n"
"                    for memberNo in <1, numMembers>  (\n"
"                        if member_ID(go_path[pathStep], memberNo) == go_args[pathword+1]  then (\n"
"                            numOldSteps = pathStep\n"
"                            return      )\n"
"                ))  )\n"
"                pathStep = that - 1\n"
"            ) }\n"
"            \n"
"            if pathStep == 0  then (\n"
"                printl(name, \"() error:  could not find beginning of path\")\n"
"                return      )\n"
"            \n"
"            if not goBack  then numOldSteps = top(go_path)\n"
"            \n"
"            go_path[^numOldSteps+numNewSteps]\n"
"            go_path[numOldSteps+1] = @go_path[pathStep][memberNo]\n"
"            \n"
"            whereWords[^numOldSteps+numNewSteps]\n"
"            if goBack  then (\n"
"                whereWords[numOldSteps+1] = print_string(\".\", allNames[go_args[pathword+1]])       )\n"
"            else  (\n"
"                whereWords[numOldSteps+1] = print_string(\"-->\", allNames[go_args[pathword+1]])\n"
"        )   )\n"
"        \n"
"        \n"
"            | CASE 2:  the first step is a 'this' command\n"
"        \n"
"        else if go_args[pathword] == 41 or go_args[pathword] == 43  then (\n"
"            numOldSteps = top(go_path) - 1\n"
"            if go_args[pathword] == 43  then (\n"
"                numOldSteps = that - 1\n"
"                while go_args[pathword+1] == 43  do (\n"
"                    numOldSteps = that - 1\n"
"                    pathword = that + 1\n"
"            )   )\n"
"            go_path[^numOldSteps+numNewSteps]\n"
"            whereWords[^numOldSteps+numNewSteps]        )\n"
"        \n"
"        \n"
"        else  (  printl(name, \"() error:  illegal path\"), return  )\n"
"        \n"
"        \n"
"            | now add a step in go_path[] for each successive step-to-member or step-to-index, etc. command\n"
"        \n"
"        pathStep = numNewSteps-1\n"
"        while pathStep >= 1  do (\n"
"            \n"
"            whereIndex = numOldSteps+numNewSteps+1-pathStep\n"
"            \n"
"            rtrn = trap(do_in(\n"
"                \n"
"                go_path[whereIndex-1]\n"
"                *\n"
"                {  go_path, whereIndex }\n"
"                {  go_args[<newSteps[pathStep].path_start, newSteps[pathStep+1].path_start-1>],\n"
"                   go_args[<newSteps[pathStep+1].path_end, newSteps[pathStep].path_end-1>]      }\n"
"                \n"
"                code\n"
"                \n"
"                args[1][1][args[1][2]] = @dummy\n"
"                \n"
"                code\n"
"                \n"
"                bytecodeWords[*] =! { bytecodeWords[<1, top-3>], args[1][1], 41, args[1][2], 0 }\n"
"            ))\n"
"            \n"
"            if rtrn == passed  then (\n"
"                if go_args[newSteps[pathStep].path_start] == 11  then\n"
"                    whereWords[whereIndex] = cat(\".\", allNames[go_args[newSteps[pathStep].path_start+1]])\n"
"                else if go_args[newSteps[pathStep].path_start] == 6  then\n"
"                    whereWords[whereIndex] = \"()\"\n"
"                else if go_args[newSteps[pathStep].path_start] == 14  then\n"
"                    whereWords[whereIndex] = \"[*]\"\n"
"                else  (\n"
"                    whereWords[whereIndex] = \"[..]\"\n"
"            )   )\n"
"            \n"
"            else  (\n"
"                go_path[^numOldSteps+numNewSteps-pathStep]\n"
"                whereWords[^numOldSteps+numNewSteps-pathStep]\n"
"                where =! whereWords\n"
"                \n"
"                print(name, \"() error: invalid path (\")\n"
"                if rtrn == 31  then print(\"cannot step through multiple indices\\n\")\n"
"                else  print(\"redo error handling\\n\")\n"
"                printl(\"Falling back to \", where)\n"
"                return\n"
"            )\n"
"            \n"
"            pathStep = that - 1\n"
"        )\n"
"        \n"
"        where =! whereWords\n"
"    }\n"
"\n"
"    jump :: go : {  name = \"jump\", whereWords = @go.whereWords, goBack = false  }\n"
"\n"
"    go_path :: go_path : {  code, where = \"root\"  }    | in case the terminal has to reset the path\n"
")\n"
"\n"
"\n"
"\n"
"\n"
"| what([location]) displays the list of variables in the current workspace, or in 'location'\n"
"\n"
"what :: {\n"
"    \n"
"    var_strings :: [] string\n"
"    comma_string :: string\n"
"    loopVar :: varID :: maxID :: int\n"
"    whatVars :: *\n"
"    \n"
"    code\n"
"    \n"
"    if trap(\n"
"        if top(args) == 0  then (\n"
"            if trap(whatVars = @go_path[top]) /= passed  then (\n"
"                printl(\"what():  I need the root-level 'go_path' alias if no arguments are given\")\n"
"                throw(1)\n"
"        )   )\n"
"        else  whatVars = @args[1]\n"
"    ) /= passed  then (\n"
"        printl(\"usage:  what([variable name])\")\n"
"        whatVars = @nothing\n"
"        return      )\n"
"    \n"
"    if trap(maxID = top(allNames)) /= passed  then (\n"
"        printl(\"what():  I need a 'root.allNames' alias to the compile()-generated namelist\")\n"
"        return\n"
"    )\n"
"    comma_string = \"\"\n"
"    \n"
"    var_strings[^0]\n"
"    for loopVar in <1, top(whatVars)>  (\n"
"        varID = member_ID(whatVars, loopVar)\n"
"        if varID > 0 and varID <= maxID  then (\n"
"            var_strings[+top+1] = cat(comma_string, allNames[varID])\n"
"            comma_string = \", \"\n"
"    )   )\n"
"    \n"
"    whatVars = @nothing\n"
"    return cat(var_strings)         | cat() makes a new() string\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"| max(list; rtrn = value/index/both)\n"
"| min(list; rtrn = value/index/both)\n"
"| - these return the maximum/minimum value of a list\n"
"\n"
"numArrayOp *:: {\n"
"    \n"
"    name :: string\n"
"    the_list *:: [] double\n"
"    listTop :: int\n"
"    params :: {}\n"
"    \n"
"    code\n"
"    \n"
"    if top(args) == 0  then return\n"
"    \n"
"    params(), (params<<args)()\n"
"    \n"
"    if trap(the_list = @args[1]) /= passed then  (\n"
"        the_list @:: the_list\n"
"        if trap(\n"
"            the_list[^top(args[1])]\n"
"            the_list = args[1]\n"
"        ) /= passed then (\n"
"            if trap(\n"
"                the_list[^top(args)]\n"
"                the_list = args\n"
"            ) /= passed  then (\n"
"                printl(\"usage: \", name, \"(numeric list [; rtrn = index/value/both])\")\n"
"                the_list =@ *\n"
"                return\n"
"    )   )   )\n"
"    \n"
"    listTop = top(the_list)\n"
"}\n"
"\n"
"\n"
"maxmin_template :: numArrayOp : {\n"
"    \n"
"    mult :: max_index :: int\n"
"    max_val :: double\n"
"    \n"
"    params :: params : {  rtrn := value := 1, index := 2, both := 3;  rtrn = value  }\n"
"    \n"
"    code\n"
"    \n"
"    if listTop == 0  then (  printl(name, \"() error:  list cannot be of length zero\"), the_list =@ *, return  )\n"
"    \n"
"    $minmax(the_list, mult, max_index, max_val)\n"
"    \n"
"    the_list = @nothing\n"
"    if params.rtrn == params.value  then return new(mult*max_val)\n"
"    else if params.rtrn == params.index  then return new(max_index)\n"
"    else if params.rtrn == params.both  then return new({ mult*max_val, max_index })\n"
"    else  return *\n"
"}\n"
"\n"
"min :: maxmin_template : { name = \"min\", mult = -1 }\n"
"max :: maxmin_template : { name = \"max\", mult = 1 }\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"| sum(list) and mean(list) return the sum/arithmetic mean of elements of a numeric list\n"
"\n"
"sum :: numArrayOp : {\n"
"    \n"
"    the_sum :: double\n"
"    \n"
"    code\n"
"    \n"
"    $sum(the_list, the_sum)\n"
"    \n"
"    the_list = @nothing\n"
"}\n"
"\n"
"mean :: sum : {  name = \"mean\"; return new(the_sum/listTop)  }\n"
"sum :: sum : {  name = \"sum\"; return new(the_sum)  }\n"
"\n"
"\n"
"\n"
"| round(num) rounds off a num to the nearest integer\n"
"\n"
"round :: { ; return floor(args[1] + 0.5) }\n"
"\n"
"\n"
"| sort(list [, whichColumn] [; direction = increasing/decreasing]) sorts a table\n"
"| by one of its (numerical) columns or by another list\n"
"\n"
"sort :: {\n"
"    tableToSort :: sortingList :: sortedTable :: *\n"
"    c1 :: totalIndices :: oneIndex :: sortIndex :: int\n"
"    slowSort :: bool\n"
"    sortingListFloat :: [] double\n"
"    linklist :: [] int\n"
"    \n"
"    params :: { direction :: increasing :: decreasing :: int }\n"
"    \n"
"    code\n"
"    \n"
"    (params << {\n"
"        code\n"
"        direction = increasing = 1\n"
"        decreasing = -1\n"
"    })()\n"
"    \n"
"    if trap(\n"
"        if top(args) /= 1 and top(args) /= 2  then throw(1)\n"
"        tableToSort = @args[1]\n"
"        totalIndices = top(tableToSort)\n"
"        \n"
"        if totalIndices > 0  then (\n"
"            if trap(sortIndex = args[2]) == passed or top(args) == 1  then (\n"
"                if type(tableToSort[1]) < 5  then (\n"
"                    sortingList @:: [totalIndices] tableToSort[1]\n"
"                    sortingList = tableToSort       )\n"
"                else  (\n"
"                    if top(args) == 1  then throw(2)\n"
"                    sortingList @:: [totalIndices] tableToSort[1][sortIndex]\n"
"                    for c1 in <1, totalIndices>  (\n"
"                        sortingList[c1] = tableToSort[c1][sortIndex]\n"
"            )   )   )\n"
"            \n"
"            else  (\n"
"                sortingList = @args[2]\n"
"        )   )\n"
"        \n"
"        (params<<args)()\n"
"        if params.direction /= params.increasing and params.direction /= params.decreasing  then throw(2)\n"
"    ) /= passed  then (\n"
"        printl(\"usage:  sort(my_list) or sort(my_table, sortIndex/sort-by_list [, code, direction = increasing/decreasing])\")\n"
"        tableToSort =@ sortingList =@ *\n"
"        return      )\n"
"    \n"
"    if totalIndices == 0  then return\n"
"    \n"
"    if totalIndices /= top(sortingList)  then (\n"
"        printl(\"sort() error:  tableToSort, sort-by_list have the same number of rows\")\n"
"        tableToSort =@ sortingList =@ *\n"
"        return          )\n"
"    \n"
"    remove sortedTable\n"
"    if trap(\n"
"        sortedTable @:: tableToSort\n"
"        sortedTable = tableToSort\n"
"    ) /= passed  then (\n"
"        if trap(\n"
"            sortedTable =@ *\n"
"            sortedTable @:: [totalIndices] tableToSort[1]\n"
"            sortedTable = tableToSort\n"
"        ) /= passed  then (\n"
"            if trap(\n"
"                sortedTable =@ *\n"
"                sortedTable @:: [totalIndices][top(tableToSort[1])] tableToSort[1][1]\n"
"                sortedTable = tableToSort\n"
"            ) /= passed  then (\n"
"                printl(\"sort() error:  tableToSort differs from its original definition; could not be sorted\")\n"
"                tableToSort =@ sortingList =@ *\n"
"                return\n"
"    )   )   )\n"
"    \n"
"    linklist[^totalIndices]\n"
"    if trap(sortingListFloat = @sortingList) /= passed  then (\n"
"        sortingListFloat @:: sortingListFloat\n"
"        sortingListFloat[^totalIndices] = sortingList[]     )\n"
"    \n"
"    $makeLinkList(sortingListFloat, linklist, params.direction, oneIndex)\n"
"    \n"
"    slowSort = (trap($sort(linklist, oneIndex, tableToSort, sortedTable)) /= passed)              | use autoNN's C-coded sort() if possible\n"
"    if slowSort  then (\n"
"        oneIndex = that + 1\n"
"        for c1 in <1, totalIndices>  (\n"
"            sortedTable[c1] = tableToSort[oneIndex]\n"
"            oneIndex = linklist[oneIndex]\n"
"    )   )\n"
"    \n"
"    tableToSort = sortedTable\n"
"    tableToSort =@ sortingList =@ sortingListFloat =@ *\n"
"}\n"
"\n"
"\n"
"\n"
"| binsearch(list [; direction = increasing/decreasing]) searches a sorted list for a given value,\n"
"| and returns the index in the list of that value (or * if not found)\n"
"\n"
"binsearch :: {\n"
"    \n"
"    theList :: *\n"
"    left :: right :: mid :: int\n"
"    theVal :: difference :: double\n"
"    \n"
"    params :: { direction :: int, increasing := 1, decreasing := -1 }\n"
"    \n"
"    code\n"
"    \n"
"    if trap(\n"
"        theList = @args[1]\n"
"        theVal = args[2]\n"
"        if top(args) > 2  then throw(1)\n"
"        \n"
"        params.direction = params.increasing\n"
"        if top(theList) > 1  then (\n"
"        if theList[top]-theList[1] < 0  then (\n"
"            params.direction = params.decreasing\n"
"        ))\n"
"        (params<<args)()\n"
"    ) /= passed  then (\n"
"        printl(\"usage:  index = binsearch(list, value)\")\n"
"        return\n"
"    )\n"
"    \n"
"    left = 1\n"
"    right = top(theList)\n"
"    while left <= right  do (\n"
"        mid = round((left+right)/2)\n"
"        difference = (theVal - theList[mid]) * params.direction\n"
"        \n"
"        if difference < 0.  then right = mid-1\n"
"        else if difference > 0.  then left = mid+1\n"
"        else if difference == 0.  then return mid\n"
"        else  return *                      | if we're looking for a NAN\n"
"    )\n"
"    \n"
"    return *\n"
"}\n"
"\n"
"\n"
"\n"
"| The so-called 'disassembler' takes in Cicada bytecode code (NOT real machine code)\n"
"| and outputs a text version that is somewhat more readable.  Reads the compiled code string, optionally from startFrom,\n"
"| using nameSpace if given.  The return value is the disassembly string.  The optional flag marks the nth bytecode word.\n"
"\n"
"| disassembly = disassemble(compiledCodeString [, nameSpace [, startFrom]] [; expandFunctions = true/false, flagPosition = #])\n"
"\n"
"\n"
"disassembler :: {\n"
"    \n"
"    compiledNames *:: [] string\n"
"\n"
"    instructionWords :: {\n"
"            \"j\", \"jt\", \"jf\", \"code\", \"ret\", \"f\", \"Cf\", \"dg\", \"feq\", \"sm\",\n"
"            \"sID\", \"sti\", \"stis\", \"s*\", \"rsz\", \"+i\", \"+is\", \"rm\", \"eq\", \"ne\",\n"
"            \"gt\", \"ge\", \"lt\", \"le\", \"eq@\", \"ne@\", \"add\", \"sub\", \"mul\", \"div\",\n"
"            \"pow\", \"mod\", \"not\", \"and\", \"or\", \"xor\", \"c#\", \"sub\", \"app\", \"args\", \n"
"            \"this\", \"that\", \"back\", \"top\", \"*\", \"arr\", \"bool\", \"char\", \"int\", \"dbl\",\n"
"            \"str\", \"cb\", \"cc\", \"ci\", \"cdb\", \"cst\", \"\"  }\n"
"\n"
"    instructionArguments :: {\n"
"            0, 1, 1, 0, 1, 2, 1, 2, 2, 0, \n"
"            1, 2, 3, 1, 2, 2, 3, 1, 2, 2,\n"
"            2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n"
"            2, 2, 2, 2, 2, 2, 2, 2, 2, 0,\n"
"            0, 0, 0, 0, 0, 2, 0, 0, 0, 0,\n"
"            0, 0, 0, 0, 0, 0, 0      }\n"
"\n"
"    extraWords :: {\n"
"            1, 1, 1, 0, 0, 0, 1, 1, 0, 1,\n"
"            1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n"
"            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n"
"            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n"
"            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n"
"            0, 1, 1, 1, size(double)/size(int), 1, 0      }\n"
"\n"
"    dgWords :: [] { ID :: int, abbr :: string }\n"
"    dgWords[*] = {\n"
"            { 1, \"equ\" }, { 6, \"mdf\"}, { 16, \"eqa\"}, { 22, \"dqa\"}, { 44, \"vdf\"}, { 46, \"def\" }, { 47, \"deq\"},\n"
"            { 148, \"dqa*\"}, { 172, \"def*\"}, { 173, \"deq*\"}, { 236, \"def**\"}, { 237, \"deq**\"}, { 204, \"def-c**\"} }\n"
"\n"
"    CicadaFunctionWords :: {\n"
"            \"newCompiler\", \"compile\", \"getMemberNames\", \"transform\", \"trap\", \"throw\",\n"
"            \"top\", \"size\", \"type\", \"member_ID\", \"bytecode\",\n"
"            \"load\", \"save\", \"input\", \"print\", \"read_string\", \"print_string\", \"find\",\n"
"            \"random\", \"abs\", \"floor\", \"ceil\", \"exp\", \"log\",\n"
"            \"cos\", \"sin\", \"tan\", \"acos\", \"asin\", \"atan\",\n"
"            \"add\", \"subtract\", \"multiply\", \"divide\", \"pow\",\n"
"            \"minmax\", \"sum\", \"makeLinkList\", \"sort\", \"springCleaning\"       }\n"
"    \n"
"    returnDisassembly :: expandFunctions :: bool\n"
"    bytecodeWords :: [] int\n"
"    numCompiledNames :: numWords :: disasmStartPos :: flagPosition :: int\n"
"    namespace :: bytecodeString :: output :: string\n"
"    wordSize := size(int)\n"
"    doubleSizeInInts := size(double)/size(int)\n"
"    \n"
"    \n"
"    runDisAsm :: {\n"
"        varStart :: varEnd :: CN_counter :: wordCounter :: argsError :: int\n"
"        rtrn :: *\n"
"        \n"
"        params :: {  expandFunctions := @\\.\\.expandFunctions, flagPosition := @\\.\\.flagPosition  }\n"
"        \n"
"        code\n"
"        \n"
"        params = {  true, 0  }\n"
"        \n"
"        if trap(\n"
"            returnDisassembly = (top(args) <= 2)\n"
"            if returnDisassembly  then ( { bytecodeString } = args, disasmStartPos = 1 )\n"
"            else  { bytecodeString, disasmStartPos } = { args[1], args[3] }\n"
"            \n"
"            if top(args) >= 2  then (\n"
"                compiledNames = @args[2]\n"
"                if compiledNames ==@ *  then (\n"
"                    if trap(compiledNames = @allNames) /= passed  then compiledNames = @nothing\n"
"            )   )\n"
"            else if trap(compiledNames = @allNames) /= passed  then compiledNames = @nothing\n"
"            \n"
"            (params<<args)()\n"
"        ) /= passed  then (\n"
"            print(\"usage: [bytecode string = ] disassemble((string) compiled_code [ , (string array) namespace \")\n"
"            printl(\"[, (int) disassemble_start_position ]] [ ; expandFunctions/flagPosition = ... ]\")\n"
"            compiledNames = @nothing\n"
"            return      )\n"
"        \n"
"        if size(bytecodeString) mod wordSize /= 0 or size(bytecodeString) == 0  then (\n"
"            printl(\"disassemble() error:  code size is not N*size(int) > 0\")\n"
"            compiledNames = @nothing\n"
"            return      )\n"
"        \n"
"        numWords = size(bytecodeString)/wordSize\n"
"        if disasmStartPos > numWords  then (\n"
"            printl(\"disassemble() error:  start_pos > # of words\")\n"
"            compiledNames = @nothing\n"
"            return      )\n"
"        \n"
"        numCompiledNames = top(compiledNames)\n"
"        \n"
"        bytecodeWords[^numWords]\n"
"        bytecodeWords =! bytecodeString\n"
"        output = \"\"\n"
"        \n"
"|        if trap(\n"
"            if returnDisassembly  then (\n"
"                wordCounter = 1\n"
"                output = RecursionPackage.writeSentences(wordCounter)\n"
"                if wordCounter /= numWords+1  then (\n"
"                    cat(output, \"[Not the correct end-of-code]\\n\")\n"
"            )   )\n"
"            else  (\n"
"                wordCounter = disasmStartPos\n"
"                output = RecursionPackage.writeExpression(wordCounter)\n"
"                args[3] = wordCounter        )\n"
"  |*      ) /= passed  then (\n"
"            printl(\"disassemble() error:  problem with the bytecode\")\n"
"            compiledNames = @nothing\n"
"            return       )*|\n"
"        \n"
"        compiledNames = @nothing\n"
"        \n"
"        if not returnDisassembly  then return\n"
"        else  return ((rtrn =@ *) = @output)\n"
"    }\n"
"    \n"
"    \n"
"    RecursionPackage :: {\n"
"        \n"
"        doWrite :: bool\n"
"        expressionString := \"\"\n"
"        \n"
"        writeSentences :: {\n"
"            \n"
"            WSexpressionTop :: *\n"
"            bottomLevel := false\n"
"            sentenceString :: string\n"
"            \n"
"            \n"
"            code\n"
"            \n"
"            WSexpressionTop = @args[1]\n"
"            \n"
"            sentenceString = \"\"\n"
"            while bytecodeWords[WSexpressionTop] /= 0  do (\n"
"                sentenceString = cat(sentenceString, writeExpression(WSexpressionTop))\n"
"                if bytecodeWords[WSexpressionTop] /= 0 and returnDisassembly  then (\n"
"                    if bottomLevel  then sentenceString = cat(sentenceString, \"\\n\")\n"
"                    else if doWrite  then sentenceString = cat(sentenceString, \", \")\n"
"            )   )\n"
"            \n"
"            if WSexpressionTop > flagPosition and flagPosition /= 0 and returnDisassembly  then (\n"
"                cat(output, \"<-- *****   \")\n"
"                flagPosition = 0            )\n"
"            if bottomLevel and returnDisassembly  then cat(output, \"\\n\")\n"
"            \n"
"            WSexpressionTop =@ *\n"
"            return sentenceString\n"
"        }\n"
"        \n"
"        \n"
"        writeExpression :: {\n"
"            \n"
"            constBool :: bool\n"
"            constChar :: char\n"
"            constInt :: numChars :: charCounter :: instructionArgs :: argCounter :: int\n"
"            constDouble :: double\n"
"            constString :: theCmd :: string\n"
"            \n"
"            WEcat_fulloutput :: {  ; theCmd = cat(theCmd, args, \" \")  }\n"
"            WEcat_linesonly :: { }\n"
"            WEcat *:: *\n"
"            \n"
"            currentCommand :: extraSkip :: mID :: int\n"
"            \n"
"            expressionTop *:: *\n"
"            \n"
"            \n"
"            code\n"
"            \n"
"            theCmd = \"\"\n"
"            \n"
"            if returnDisassembly and doWrite  then WEcat = @WEcat_fulloutput\n"
"            else WEcat = @WEcat_linesonly\n"
"            \n"
"            expressionTop = @args[1]\n"
"            \n"
"            currentCommand = bytecodeWords[expressionTop]\n"
"            if currentCommand == 0  then return\n"
"            \n"
"            WEcat(instructionWords[currentCommand])\n"
"            extraSkip = extraWords[currentCommand]\n"
"            \n"
"            instructionArgs = instructionArguments[currentCommand]\n"
"            \n"
"            \n"
"                | some commands get special treatment\n"
"            \n"
"                | jump commands -- we write out the jump offset\n"
"            \n"
"            if currentCommand >= 1 and currentCommand <= 3  then (\n"
"                constInt =! bytecodeWords[expressionTop+1]\n"
"                WEcat(constInt)\n"
"                extraSkip = 1       )\n"
"            \n"
"            \n"
"                | Cicada library functions -- substitute the name of the specific library (if it's obvious)\n"
"            \n"
"            else if currentCommand == 7  then (\n"
"                theCmd = \"\"\n"
"                WEcat(CicadaFunctionWords[bytecodeWords[expressionTop+1]+1])\n"
"                extraSkip = 1\n"
"|                instructionArgs = that-1\n"
"            )\n"
"            \n"
"            \n"
"                | define-equate-etc. operators -- write in the name of the specific operator if it's a common one\n"
"            \n"
"            else if currentCommand == 8  then (\n"
"                theCmd = \"\"\n"
"                if trap(WEcat(dgWords[binsearch(dgWords[*].ID, bytecodeWords[expressionTop+1])].abbr)) /= passed  then (\n"
"                    WEcat(instructionWords[currentCommand], \" \", bytecodeWords[expressionTop+1])\n"
"            )   )\n"
"            \n"
"            \n"
"                | search-member or step-to-member -- write in the member name\n"
"            \n"
"            else if currentCommand == 10 or currentCommand == 11  then (\n"
"                mID = bytecodeWords[expressionTop+1]\n"
"                if compiledNames == @nothing   then WEcat(mID)\n"
"                else if mID < 0   then WEcat(\"$\", -mID)\n"
"                else if mID > numCompiledNames or mID == 0   then WEcat(\"??\")\n"
"                else  WEcat(\"$\", compiledNames[mID])\n"
"                extraSkip = 1       )\n"
"            \n"
"            \n"
"                | constant:  bool, char, int, double, string -- just write out the constant in the disassembly\n"
"            \n"
"            else if currentCommand == 52  then (\n"
"                constBool = (bytecodeWords[expressionTop+1] /= 0)\n"
"                theCmd = \"\"\n"
"                if constBool  then WEcat(\"true\")\n"
"                else  WEcat(\"false\")\n"
"                extraSkip = 1       )\n"
"            \n"
"            else if currentCommand == 53  then (\n"
"                theCmd = \"\"\n"
"                constChar = bytecodeWords[expressionTop+1]\n"
"                WEcat(\"'\", constChar, \"'\")\n"
"                extraSkip = 1       )\n"
"            \n"
"            else if currentCommand == 54  then (\n"
"                theCmd = \"\"\n"
"                constInt = bytecodeWords[expressionTop+1]\n"
"                WEcat(constInt)\n"
"                extraSkip = 1       )\n"
"            \n"
"            else if currentCommand == 55  then (\n"
"                theCmd = \"\"\n"
"                constDouble =! bytecodeWords[<expressionTop+1, expressionTop+doubleSizeInInts>]\n"
"                WEcat(constDouble)\n"
"                extraSkip = doubleSizeInInts        )\n"
"            \n"
"            else if currentCommand == 56  then (\n"
"                theCmd = \"\"\n"
"                numChars = bytecodeWords[expressionTop+1]\n"
"                constString =! bytecodeWords[<expressionTop+2, expressionTop+ceil(numChars/wordSize)+1>]\n"
"                constString = constString[<1, numChars>]\n"
"                \n"
"                for (charCounter::int) in <1, numChars>  (\n"
"                if constString[charCounter] < 32 or constString[charCounter] > 127 then (\n"
"                    constString[charCounter] = 35\n"
"                ))\n"
"                \n"
"                WEcat(\"\\\"\", constString, \"\\\"\")\n"
"                extraSkip = ceil(numChars/wordSize)+1     )\n"
"            \n"
"            \n"
"                | code block -- write it in {}\n"
"            \n"
"            else if currentCommand == 57  then (\n"
"                theCmd = \"\"\n"
"                expressionTop = that + 1\n"
"                subExpression :: RecursionPackage\n"
"                subExpression.doWrite = doWrite and expandFunctions\n"
"                \n"
"                if doWrite and not subExpression.doWrite  then theCmd = \"{ ... \"\n"
"                else  theCmd = \"{ \"\n"
"                WEcat(subExpression.writeSentences(expressionTop), \"}\")        )\n"
"            \n"
"            \n"
"                | if we're trying to mark a spot in the code, write out a marker there\n"
"            \n"
"            expressionTop = that + 1 + extraSkip\n"
"            if expressionTop > flagPosition and flagPosition /= 0   then (\n"
"                command = cat(command, \"<-- ***** \")\n"
"                flagPosition = 0            )\n"
"            \n"
"            \n"
"                | now write out each of the arguments of the operator\n"
"            \n"
"            if instructionArgs > 0  then (\n"
"                subExpression::RecursionPackage\n"
"                WEcat(\"(\")\n"
"                for (argCounter::int) in <1, instructionArgs>  (\n"
"                    if argCounter /= 1  then WEcat(\",\")\n"
"                    subExpression.doWrite = doWrite\n"
"                    WEcat(subExpression.writeExpression(expressionTop))        )\n"
"                WEcat(\")\")\n"
"            )\n"
"            \n"
"            expressionTop =@ *\n"
"            \n"
"            if top(theCmd) > 0  then theCmd[^top-1]\n"
"            return theCmd\n"
"        }\n"
"    }\n"
"    RecursionPackage.writeSentences.bottomLevel = true\n"
"    RecursionPackage.doWrite = true\n"
"}\n"
"\n"
"disassemble := @disassembler.runDisAsm"
