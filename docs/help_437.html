<HTML>

<HEAD>
<TITLE>Cicada Help: Aliases</TITLE>

<a href="https://heltilda.github.io/cicada/index.html">Cicada</a> ---> <a href="https://heltilda.github.io/cicada/toc.html">Online Help Docs</a> ---> <a href="https://heltilda.github.io/cicada/help_4.html">Cicada scripting</a> ---> <a href="https://heltilda.github.io/cicada/help_43.html">Variables</a>

<H1> <CENTER> Aliases </CENTER> </H1>
</HEAD>

<BODY>

 

<P> Aliases in Cicada are a sort of memory-safe alternative to pointers.  An alias is a member that shares its data with some other member:  in other words those two members share a variable.  In Cicada a member and an alias made to it are <i>exactly</i> on equal footing:  the interpreter doesn&rsquo;t know or care which came first.

<P> Here is how aliases are defined:

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; a := 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| will default to an int

<br>&nbsp;&nbsp;&nbsp; b :=@ a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| alias #1

<br>&nbsp;&nbsp;&nbsp; c :=@ b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| alias #2

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P>  &lsquo;<tt>b</tt>&rsquo; is now an alias to &lsquo;<tt>a</tt>&rsquo;, and &lsquo;<tt>c</tt>&rsquo; is now an alias to &lsquo;<tt>b</tt>&rsquo; and therefore also to &lsquo;<tt>a</tt>&rsquo;.  If we were to now <tt>print(a)</tt>, <tt>print(b)</tt> or <tt>print(c)</tt>, we would get back the number 2.  If we were to set any of the three variables to a different value:

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; c = 3

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P>  then printing any of <tt>a</tt>, <tt>b</tt> or <tt>c</tt> would then cause the new number 3 to be printed.

<P> Any variable can become an alias for any other variable <i>of the same type</i> (or a derived/inherited type), by means of the equate-at operator &lsquo;<tt>=@</tt>&rsquo;.

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; a :: b :: c :: int

<br>&nbsp;&nbsp;&nbsp; { a, b, c } = { 1, 2, 3 }

<br>&nbsp;&nbsp;&nbsp; a =@ b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 'a' now points to the variable storing '2'

<br>&nbsp;&nbsp;&nbsp; b =@ c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 'a' STILL points to the variable storing '2'

<br>&nbsp;&nbsp;&nbsp; c =@ b =@ a

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P>  The tricky bit is the fourth line:  since member &lsquo;<tt>a</tt>&rsquo; has been aliased to member &lsquo;<tt>b</tt>&rsquo;, does the command <tt>b =@ c</tt> now drag member <tt>a</tt> along with it?  The answer is no:  aliasing binds one member to another member&rsquo;s variable, not to the other member itself.  If we follow through all the acrobatics, we find that members <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> all end up referring to same the variable storing the number 2, as shown in Figure 2.  The other two variables are now permanently inaccessible and will eventually be cleared from memory.

<P> <br><center><div class="image"><img src="https://heltilda.github.io/cicada/aliases.jpg"<div><br><br>Figure 2:  Aliasing of members (letters) to variables (boxes)</div></div></center><br>

<P> Cicada clearly makes an important distinction between members and variables.  A member is a named object in Cicada:  the name of a variable, or a field in a composite variable.  The variable itself is the data that the member refers to.  In Cicada these two objects are entirely separate, and there is no reason to require a one-to-one correspondence between them, as Figure 2 shows.

<P> Just as the data-copying operator &lsquo;<tt>=</tt>&rsquo; or &lsquo;<tt>&lt;-</tt>&rsquo; has a data-comparison counterpart &lsquo;<tt>==</tt>&rsquo;, so the reference-copying operator &lsquo;<tt>=@</tt>&rsquo;  is mirrored in a reference-comparison operator &lsquo;<tt>==@</tt>&rsquo; which tests to see whether two members point to the same object.  (If the left side spans a range of array elements, then the right side must also span exactly those same elements in order for the test to return true).  Finally, the are-references-not-equal operator &lsquo;<tt>/=@</tt>&rsquo; is just the logical negation of &lsquo;<tt>==@</tt>&rsquo;.  Whitespace just before the &lsquo;@&rsquo; is allowed:

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; if a == @b&nbsp;then c := @b

<br>&nbsp;&nbsp;&nbsp; if a /= @b&nbsp;then a = @b

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P>  and can help make clearer the analogy with the data-copying operators.  Both <tt>a = @b</tt> and <tt>a = b</tt> cause member &lsquo;<tt>a</tt>&rsquo; to equal member &lsquo;<tt>b</tt>&rsquo;, though by different means.

<P> 

<br><P><b>Jamming</b></b>
<P> 

<P> Arrays can also be involved in aliasing.  For example, scalar members can alias single array elements, and array members can alias other array members having compatible types.

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; array_1 :: [5] double

<br>&nbsp;&nbsp;&nbsp; array_2 :: [10] double

<br>&nbsp;&nbsp;&nbsp; oneEl :: double

<br>&nbsp;&nbsp;&nbsp; 

<br>&nbsp;&nbsp;&nbsp; oneEl = @array_1[4]

<br>&nbsp;&nbsp;&nbsp; oneEl = @array_2[top]

<br>&nbsp;&nbsp;&nbsp; array_1 = @array_2

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P>  It gets a little more complicated when aliasing array <i>elements</i>.  This is different from aliasing arrays:  <tt>a1[] = @a2[]</tt> is different from <tt>a1 = @a2</tt>.  Cicada doesn&rsquo;t let us re-alias only part of the source array, since doing so would fragment its storage, but we can alias all source array elements to a part of a target array.  For example, 

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; array_1[] = @array_2[&lt;4, 8&gt;]

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P>  is legal, as long as <tt>array_1</tt> had 5 elements to begin with (aliasing can&rsquo;t resize an array).  However, we <i>cannot</i> write

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; array_1[&lt;3, 5&gt;] = @array_2[&lt;4, 6&gt;]

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P> There&rsquo;s an additional complication: what happens if we try to resize one of those two arrays?  That could force a resize of another alias, which is not allowed.  The solution is that parts of an array having multiple members pointing to them can become &lsquo;jammed&rsquo;, meaning that they cannot be resized until all but one of the aliases is removed.  For example:

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; array_1 :: [3][10] int

<br>&nbsp;&nbsp;&nbsp; array_2 := @array_1[2][&lt;4, 7&gt;]&nbsp;&nbsp;| jams 4 indices of array_1

<br>&nbsp;&nbsp;&nbsp; 

<br>&nbsp;&nbsp;&nbsp; array_1[][^12]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| legal - indices 11-12 aren't aliased by array_2

<br>&nbsp;&nbsp;&nbsp; array_2[^12]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| no, this would cause problems

<br>&nbsp;&nbsp;&nbsp; remove array_1[][5]&nbsp;&nbsp;&nbsp;| not legal -- would remove 2nd column of array_2

<br>&nbsp;&nbsp;&nbsp; remove array_1[1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| legal

<br>&nbsp;&nbsp;&nbsp; 

<br>&nbsp;&nbsp;&nbsp; remove array_1

<br>&nbsp;&nbsp;&nbsp; array_2[+3]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| legal only because we removed the jamb

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P> Explicit aliases always jam arrays.  On the other hand, &lsquo;tokens&rsquo; or unnamed references to objects (such as elements of sets and function arguments) never jam arrays.

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; al := @my_array[&lt;4, 6&gt;]&nbsp;&nbsp;&nbsp;| jams elements 4-6

<br>&nbsp;&nbsp;&nbsp; my_array[&lt;4, 6&gt;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| does not jam

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P>  Tokens are &lsquo;unjammable&rsquo;, both in the sense that they cannot jam, and that they will become &lsquo;unjammed&rsquo;---i.e. permanently deactivated---if their referent is resized through another member.  An unjammed token becomes unusable until it is redefined, usually when the command defining the token is rerun.

<P> <br><P><div align="center"><a href="https://heltilda.github.io/cicada/help_436.html">Prev: This and that</a> &nbsp;&nbsp;
<a href="https://heltilda.github.io/cicada/help_438.html">Next: The void</a>
</div><br><br><P>Last update: November 12, 2025