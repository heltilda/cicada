<HTML>

<HEAD>
<TITLE>Cicada Help: A generic wrapper</TITLE>

<a href="https://heltilda.github.io/cicada/index.html">Cicada</a> ---> <a href="https://heltilda.github.io/cicada/toc.html">Online Help Docs</a> ---> <a href="https://heltilda.github.io/cicada/help_3.html">Calling Cicada from a C program</a>

<H1> <CENTER> A generic wrapper </CENTER> </H1>
</HEAD>

<BODY>



<P> To finish off, we&rsquo;ll write a pretty generic Cicada wrapper for <tt>myFunction()</tt> that can be adapted to wrap most other C functions.  One advantage of a wrapper is that it will let us run <tt>myFunction</tt> by typing something like

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; yf = f(x, y0)

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P>  rather than

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; $myFunction(param, x, y, calcData)

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P>  The wrapper will also allocate data storage for our function, and prevent us from crashing the C code by passing in bad arguments.  Don&rsquo;t ask me what this function does.<P>

<P>  <u>myFunctionWrapper.cicada</u>

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; f :: {

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;x :: string

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;y :: error_code :: int

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;calc_table :: [][] double

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;params :: {

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dim1 :: dim2 :: int

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doRecalc :: bool&nbsp;&nbsp;&nbsp;}

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;code

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;params = { 2, 5, true }

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;if trap(

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ x, y } = args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| mandatory arguments

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(params &lt;&lt; args)()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| optional arguments

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;) /= passed&nbsp;then (

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;usage:&nbsp;yf = f(xStr, y0 [; calcSize/doRecalc = ...])\n&quot;)

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;calc_table[^params.dim1][^params.dim2]

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;error_code = $myFunction(params.doRecalc, x, y, calc_table)

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;if error_code == 0&nbsp;then return y

<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;else&nbsp;print(&quot;Error &quot;, error_code, &quot; in function f()\n&quot;)

<br>&nbsp;&nbsp;&nbsp; }

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P> Our wrapper function has two parts.  The first part is everything before the <tt>code</tt> command, which defines the variables used by function <tt>f()</tt>.  These include the input and output arguments, optional parameters, and even a calculation table used internally by the C routine (because it&rsquo;s easier to pass storage into C than malloc/free it in C).  The most important thing is that the wrapper explicitly defines the type of each variable passed into C, thus ensuring proper communication between the two languages.  For example, when we write <tt>f(&quot;a&quot;, 5)</tt> the integer argument 5 will be converted to a <tt>double</tt> before handing it off to C, as required by <tt>myFunction()</tt>.

<P> The executable part of <tt>f()</tt> begins <i>after</i> the <tt>code</tt> marker.  First <tt>f()</tt> reads its arguments (within a <tt>trap()</tt> statement so that we can fail gracefully with an error message if the function wasn&rsquo;t called properly).  Notice that there are two sorts of function argument: mandatory arguments (<tt>x</tt> and <tt>y</tt>) which are copied straightforwardly from a predefined <tt>args</tt> variable, and optional arguments stored in <tt>params</tt> with default values.  The optional arguments be changed using a very peculiar Cicada trick:  <tt>f()</tt> <i>runs its own arguments</i>, as a function, inside of its own <tt>params</tt> variable.  Then it resizes <tt>calc_table</tt>, calls <tt>myFunction()</tt> and returns a result.<P>

<P> Load our wrapper by going to Cicada&rsquo;s command prompt and typing:

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; &gt; run(&quot;myFunctionWrapper&quot;)

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P>  Here are some examples of function calls we can make once we&rsquo;ve loaded our wrapper:

<P> 

<P><P><tt> 

<br>&nbsp;&nbsp;&nbsp; result := f(&quot;a&quot;, 5)

<br>&nbsp;&nbsp;&nbsp; print( f(&quot;z&quot;, 5.78; doRecalc = false) )

<br>&nbsp;&nbsp;&nbsp; result := f(&quot;a&quot;, 5; dim1 = that*2, doRecalc = false)

<br>&nbsp;&nbsp;&nbsp; </tt>

<P>

<P>  Make sure to separate the mandatory and optional parameters using a semicolon, and separate all other arguments or commands using commas.<P>

<P> Most prepackaged Cicada functions are actually Cicada wrappers around C functions, and their source files <tt>ciclib.c</tt> and <tt>defs.c</tt> are a rich source of further examples.

<P> 

<P> 

<P> <ul>
</ul><br><P><div align="center"><a href="https://heltilda.github.io/cicada/help_311.html">Prev: Passing strings and other lists</a> &nbsp;&nbsp;
<a href="https://heltilda.github.io/cicada/help_4.html">Next: Cicada scripting</a>
</div><br><br><P>Last update: November 12, 2025