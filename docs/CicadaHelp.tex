\documentclass{article}
\usepackage{alltt}
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
%\usepackage[margin=1.5in]{geometry}
\usepackage{mathrsfs}
\usepackage{upquote}

%
%\oddsidemargin = 0in
%\evensidemargin = 0in
%\textwidth = 6.5 in
%\topmargin = -.3 in
%\headheight = 0 in
%\headsep = 0 in
%\textheight = 9 in

\setlength{\topmargin}{0cm}
\setlength{\headheight}{0cm}
\setlength{\headsep}{0cm}
\setlength{\textheight}{9in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}


\newenvironment{code}{
       \begin{list}{}{
               \setlength{\leftmargin}{.4in}
               \setlength{\rightmargin}{0in}
               \setlength{\topsep}{.2in}
       }
       \small
       \item[] }
       { \end{list}   }

\newenvironment{longcode}{
       \begin{list}{}{
               \setlength{\leftmargin}{0in}
               \setlength{\rightmargin}{0in}
               \setlength{\topsep}{.2in}
       }
       \small
       \item[] }
       { \end{list}   }

%\newenvironment{code}{
%	\begin{list}{}{
%		\setlength{\evensidemargin}{1in}
%		\setlength{\oddsidemargin}{1in}
%		\small}
%	\item[]}
%	{ \end{list}   }

\title{Cicada Scripting Language}
\author{Brian Ross}
\makeindex

\begin{document}

\maketitle
\vspace{.5in}
\begin{centering}
\includegraphics[width=.4\textwidth]{cicadaLogo}\\
\end{centering}
\vspace{.5in}
\tableofcontents
\vspace{1.5in}
%\begin{centering}
%\includegraphics[width=.4\textwidth]{cicadaLogo}\\
%\end{centering}
\newpage




% --------------- SUMMARY --------------

\section{Summary}

Cicada is a {\bf small interpreted language} that plugs into C (or C++) code.  That gives you both:

\begin{itemize}
\item the conveniences of a scripting language (memory safety, allocation/deallocation, interactivity);
\item the speed and low-level functionality of C.\\
\end{itemize}

\noindent \underline{Embedding Cicada into a C program}:
\begin{enumerate}
\item Include the \verb#cicada.h# header file.
\item Run Cicada by making a C function call:  \verb#runCicada(f, s, r)#. Here \verb#f# is an array of C functions to expose to Cicada; \verb#s# is any script to run; and \verb#r# tells Cicada whether to run an interactive terminal.
\item Cicada can callback other C functions in your code.  \emph{This last step is how the two languages communicate}: the callback passes Cicada variables and arrays into the C code for fast processing.
\item It's recommended to write a Cicada wrapper for each C function, to ensure that the arguments get passed into C correctly.
\item Pass an \verb$-lcicada$ option to the linker.
\end{enumerate}

\vspace{.25in}
\begin{centering}
* * *\\
\end{centering}

\vspace{.3in} \noindent Here's an example:

\begin{code} \begin{verbatim}
#include <cicada.h>

ccInt countOddsF(argsType args)     // (for positive numbers)
{
    ccInt *n, *c, i;                // by default, ccInt = int
    getArgs(args, &n, &c);
    *c = 0;
    for (i = 0; i < args.indices[0]; i++)  *c += n[i] % 2;
    return 0;
}

const char *wrapperScript =
    "numOdd :: { n :: [] int, c :: int; n[] = args[1], $countOdds(n, c), return c }";

int main(int argc, char **argv)
{
    const Cfunction fs[] = { { "countOdds", &countOddsF } };
    return runCicada(fs, wrapperScript, true);
}
\end{verbatim} \end{code}
 
\noindent Running this program lets us interactively process any data we want.  And since the counting is done in C, it'll run fast even on a huge dataset.

\begin{code} \begin{verbatim}
> numOdd({ 3, 5, 6, 7, 8 })

3

> if numOdd(bigList) > 1e6  then ...
\end{verbatim} \end{code}

\newpage







% --------------- EXAMPLE --------------

\section{Example:  memory networks in Cicada}

Cicada originally aimed to be a neural network engine, missed by a mile, and ended up as a scripting language.  So let's use it to implement an \emph{associative neural network}:  a type of pattern-learning algorithm which will learn to associate inputs with desired outputs.\\

\noindent \underline{Algorithm}: We'll use a training algorithm for symmetric networks\footnote{J. R. Movellan, Contrastive Hebbian learning in interactive networks, 1990} which trains in two phases: \emph{clamped}, and \emph{free}.  In the \emph{clamped phase}, set the input neuron activities to the network input, and set the output neuron activities to the pattern we are trying to learn.  Then repeatedly adjust the other `hidden' neurons' activities $x_i$ using the formula:

\begin{align*}
x_i \leftarrow \frac1{1 + e^{-\sum_j w_{ij} x_j - b_i}}.
\end{align*}

\noindent Here $w_{ij}$ is the connection weight from neuron $j$ to neuron $i$, and $b_i$ is a bias.  Once the network settles into a steady state, apply the following training rule to the weights and biases:

\begin{align*}
w_{ij} &\leftarrow w_{ij} + \eta \cdot x_i x_j\\
b_i &\leftarrow b_i + \eta \cdot x_i.
\end{align*}

\noindent Next, repeat the process for the \emph{free phase} of operation, where that the activities of the output neurons update freely using the same rule as the hidden neurons.  After reaching steady state, a \emph{negative} weight/bias adjustment is applied.  The idea is to reinforce correlated firing patterns on the difference between what the network should vs. does currently compute.  As the saying goes, \emph{neurons that fire together, wire together}.

To use the network to recover a memory, run it in its `free' mode without applying any training.
%The learning rate parameter $\eta$ should be large enough to train quickly, but not so big that the algorithm overshoots and destabilizes the network.  



\subsection{C implementation}

The code that trains a network will be written in C, for speed.  Then we'll wrap Cicada functions around the C code so that we can easily call it from a script.\\

\noindent \underline{NN.c}

\begin{longcode} \begin{verbatim}
#include <math.h>
#include "NN.h"


// runNetwork():  evolves a neural network to a steady state
// Takes the params:  1 - weights; 2 - neuron activities; 3 - input; 4 - step size
// (& additionally, in training mode):  5 - target output; 6 - learning rate

int runNetwork()
{
    neural_network myNN;
    double *inputs, step_size, *target_outputs, learning_rate;
    int i, numInputs, numOutputs;
    
    
    /* ----- set up data types, etc. ----- */
    
    
    for (i = 0; i < numInputs; i++)
        myNN.activity[i] = inputs[i];
    for (i = numInputs; i < myNN.numNeurons; i++)
        myNN.activity[i] = 0;
    
    if ( args.num == 6 )    {      // i.e. if we're in training mode
        
        if (getSteadyState(myNN, numInputs, step_size) != 0)  return 1;
        trainNetwork(myNN, -learning_rate);
        
        for (i = 0; i < numOutputs; i++)
            myNN.activity[numInputs + i] = target_outputs[i];
        
        if (getSteadyState(myNN, numInputs+numOutputs, step_size) != 0)  return 1;
        trainNetwork(myNN, learning_rate);         }
    
    else if (getSteadyState(myNN, numInputs, step_size) != 0)  return 1;
    
    
    /* ----- save results ----- */
    
    
    return 0;         // no error
}


// getSteadyState() evolves a network to the self-consistent state x_i = f( W_ij x_j ).

int getSteadyState(neural_network NN, int numClamped, double StepSize)
{
    const double max_mean_sq_diff = 0.001;
    const long maxIterations = 1000;
    
    double diff, sq_diff, input, newOutput;
    int iteration, i, j;
    
    if (numClamped == NN.numNeurons)  return 0;
    
    
        // keep updating the network until it reaches a steady state
    
    for (iteration = 1; iteration <= maxIterations; iteration++)    {
        sq_diff = 0;
        
        for (i = numClamped; i < NN.numNeurons; i++)	{
            input = 0;
            for (j = 0; j < NN.numNeurons; j++)   {
            if (i != j)   {
                input += NN.activity[j] * NN.weights[i*NN.numNeurons + j];
            }}
            newOutput = 1./(1 + exp(-input));
            
            diff = newOutput - NN.activity[i];
            sq_diff += diff*diff;
            NN.activity[i] *= 1-StepSize;
            NN.activity[i] += StepSize * newOutput;
        }
        
        if (sq_diff < max_mean_sq_diff * (NN.numNeurons - numClamped))
            return 0;
    }
    
    return 1;
}


// trainNetwork() updates the weights and biases using the Hebbian rule.

void trainNetwork(neural_network NN, double learningRate)
{
    int i, j;
    
    for (i = 0; i < NN.numNeurons; i++)    {
    for (j = 0; j < NN.numNeurons; j++)    {
    if (i != j)    {
        NN.weights[i*NN.numNeurons + j] += learningRate * NN.activity[i] * NN.activity[j];
    }}}
}
\end{verbatim} \end{longcode}

\noindent \underline{NN.h}

\begin{longcode} \begin{verbatim}
typedef struct {
    int numNeurons;     // 'N'
    double *weights;    // N x N array of incoming synapses
    double *activity;   // length-N vector
} neural_network;

extern int runNetwork( ... );
extern int getSteadyState(neural_network, int, double);
extern void trainNetwork(neural_network, double);
\end{verbatim} \end{longcode}



\subsection{Putting the C in Cicada}

Our C code focuses on the training loops (where speed is crucial) but memory allocation/deallocation, dataset loading, saving of results, etc. are all more easily scripted.  In fact let's just have C immediately hand off control to the Cicada interpreter, and tell Cicada to callback \verb#runNetwork()# as needed.  To do this, include the Cicada header in \verb#NN.c# and \verb#NN.h#:

\begin{code} \begin{verbatim}
#include <cicada.h>
\end{verbatim} \end{code}

\noindent and add following to \verb#NN.c# (say, just before \verb#runNetwork#):

\begin{code} \begin{verbatim}
const Cfunction fs[] = { { "runNetwork", &runNetwork } };

int main(int argc, char **argv)
{
    return runCicada(fs, NULL, true);
}
\end{verbatim} \end{code}

\noindent We also need to adjust the definition of \verb#runNetwork()# so that Cicada can call it properly.  The new function prototype (in both \verb#NN.c# and \verb#NN.h#) is:

\begin{code} \begin{verbatim}
ccInt runNetwork(argsType args)
\end{verbatim} \end{code}

\noindent An \verb#argsType# variable holds a list of Cicada variables passed into a C function call.  The \verb#ccInt# return type is user-definable but defaults to just \verb#int#.

Finally, we need to set up our variables at the beginning of \verb#runNetwork()#, using Cicada's functions for a) checking and b) loading data/pointers from \verb#args#.  Since memory is shared between the two environments, any pointers we load can be used to send data back to Cicada.  Replace the `set up data types' block comment with the following code:

\begin{code} \begin{verbatim}
    myNN.numNeurons = args.indices[1];
    numInputs = args.indices[2];
    
    if (args.num < 4)  return 1;
    if (getArgs(args,
            arrayRef(double_type, &myNN.weights),
            arrayRef(double_type, &myNN.activity),
            arrayRef(double_type, &inputs),
            scalarValue(double_type, &step_size),
        endArgs) != 0)  return 2;
    
    if (args.num == 6)  {
        numOutputs = args.indices[4];
        if (getArgs(args, fromArg(4),
                arrayRef(double_type, &target_outputs),
                scalarValue(double_type, &learning_rate)
            ) != 0)  return 3;
    }
\end{verbatim} \end{code}

\noindent Our code loads pointers for \verb#myNN.weights#, \verb#myNN.activity# and \verb#inputs#.  There are two reasons to load these parameters by reference: 1) they are arrays not scalars, and 2) our C code will modify the values of \verb#activity# and \verb#weights# and we want those changes to persist outside of the function call.  However, \verb#step_size# and \verb#learning_rate# are constant scalar parameters, so we load their data by value using the \verb#scalarValue()# macro.

The C code doesn't need to save any results, since its data is shared with Cicada, and there are scripting functions for writing to files (e.g. \verb#save()# or  \verb#saveTable()#).  Just delete the ``save results" comment line in \verb#NN.c#.\\

It's time to build our program.  To link against the Cicada library use the linker flag \verb#-lcicada#.  (For example, using \verb#gcc# on a UNIX machine the command would be: \verb#gcc -lcicada -o NN NN.c#).  With luck, we'll end up with an executable which we can run from the command prompt (by typing `\verb#NN#' or `\verb#./NN#', depending on the system).  We should see:

\begin{code} \begin{verbatim}
> 
\end{verbatim} \end{code}





\subsection{Writing and debugging a Cicada wrapper}

Once inside Cicada, we can run our neural network C function by typing

\begin{code} \begin{verbatim}
> $runNetwork(...)
\end{verbatim} \end{code}

\noindent The main danger here is that we might pass the wrong datatypes, or arrays of the wrong sizes, into our C code, which will then promptly crash.  To do things properly, let's write a Cicada class that stores the neural network data and provides methods for initializing, running and training the network.

This will be a learning exercise.  It's our first time scripting so there will probably be a few bugs.\\\vspace{.2in}

\noindent \underline{NN.cicada}

\begin{longcode} \begin{verbatim}
neural_network :: {
    
    numNeurons :: int
    numInputs :: numOutputs :: numHiddens
    
    weights :: [][] double
    activity :: [] double
    
    
    init :: {
        
        if trap( { numInputs, numOutputs, numHiddens } = args ) /= passed  then (
            print("usage:  myNN.init(inputs, outputs, hidden neurons)\n")
            return 1        )
        
        numNeurons = numInputs + numOutputs + numHiddens + 1
        
        activity[^numNeurons]
        weights[^numNeurons][^numNeurons]
    }
    
    
    process :: {
        
        numArgs :: rtrn :: int
        step_size :: learning_rate :: double
        inputs :: outputs :: [] double
        
        inputs[^1] = 1       // the 'bias' input
        
        
        code
        
        numArgs = top(args)
        
        if trap(
            inputs[^numInputs + 1]
            inputs[<2, numInputs+1>] = args[1][]
            if numArgs == 4  then (
                outputs[^numOutputs]
                outputs[<1, numOutputs>] = args[2][]
                { step_size, learning_rate } = { args[3], args[4] }  )
            else if numArgs == 2  then &
                step_size = args[2]
            else  throw(1)
        ) /= passed  then (
            print("usage:  myNN.process(input, step_size OR ",
                  "input, target output, step_size, learning_rate)\n")
            return 1        )
        
        if numArgs == 2  then &
            rtrn = $runNetwork(weights, activity, inputs, step_size)
        else &
            rtrn = $runNetwork(weights, activity, inputs, step_size, outputs, learning_rate)
        
        if rtrn == 1  then print("process() did not converge; try lowering step size?\n")
    }
    
    
    init(0, 0, 0)
}
\end{verbatim} \end{longcode}

\noindent Save \verb#NN.cicada# in the same directory as our NN program.  Then, from Cicada's command prompt, let's try out our new wrapper by typing:

\begin{code} \begin{verbatim}
> run("NN")

Error:  left-hand argument expected in file NN

29:          inputs[^1] = 1       // the 'bias' input
                                   ^
\end{verbatim} \end{code}

What we see here is a `compile-time' error (i.e. it failed to produce bytecode).  Evidently we wrote a C-style comment `\verb#//#' in place of a Cicada comment `\verb#|#'.  Make the straightforward fix to \verb#NN.cicada#.

\begin{code} \begin{verbatim}
        inputs[1] = 1       | the 'bias' input
\end{verbatim} \end{code}

\noindent and try again.

\begin{code} \begin{verbatim}
> run("NN")

Error:  member 'numHiddens' not found in file NN

4:      numInputs :: numOutputs :: numHiddens
                                   ^
\end{verbatim} \end{code}

\noindent This is progress: at least \verb#NN.cicada# is syntactically correct.  Line 4 tried to define \verb#numInputs# and \verb#numOutputs# to be of type \verb#numHiddens#, rather than defining all three variables as type \verb#int#, so let's fix that:

\begin{code} \begin{verbatim}
    numInputs :: numOutputs :: numHiddens :: int
\end{verbatim} \end{code}

\noindent and re-run our script.

\begin{code} \begin{verbatim}
> run("NN")

usage:  myNN.init(inputs, outputs, hidden neurons)
\end{verbatim} \end{code}

This time the script successfully `compiled' and ran.. although \verb#init()# produced an odd usage message despite never having been run.  But at least a \verb#neural_network# object was constructed, so we can start looking around inside, using the command prompt as a sort of debugger.  \verb#init()# is suspicious so let's see if it works when we do run it.

\begin{code} \begin{verbatim}
> neural_network.init(3, 4, 5)


>
\end{verbatim} \end{code}

\noindent So far so good(?).  There should now be 13 neurons in our network (including the `bias' neuron).

\begin{code} \begin{verbatim}
> neural_network.activity

{  }
\end{verbatim} \end{code}

\noindent So something is definitely wrong.  To take a better look around, let's `go' inside our network.

\begin{code} \begin{verbatim}
> go(neural_network)


> weights

{  }


> numNeurons

0


> go()
\end{verbatim} \end{code}

\noindent The last line takes us back to our `root' workspace.

So our \verb#init()# call was a dud -- nothing happened.  Our next step might be to put a trace statement in the coding section of the \verb#init()# function.. hmm, wherever that is..  Looks like we forgot a \verb#code# marker separating the function variables from its executable code, which fully explains why it won't run.  The \verb#init()# method should begin:

\begin{code} \begin{verbatim}
    init :: {
        
        code
        
        if trap( { numInputs, numOutputs, numHiddens } = args ) /= passed  then (
\end{verbatim} \end{code}

\noindent Making that final change, let's go back and try

\begin{code} \begin{verbatim}
> run("NN"), neural_network.init(3, 4, 5)


> neural_network.activity

{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
\end{verbatim} \end{code}

\noindent Finally we see what we were hoping for:  an array of neurons, initialized to a resting state and ready to begin training.



\subsection{The Anagrambler}

After running a few more tests we eventually convince ourselves that \verb#NN.cicada# is working, so we open a new file in our Cicada directory and start thinking about how to put our networks to use.

The particular learning algorithm we are using is well suited to the task of pattern completion.  To demonstrate, let's build a network to unscramble anagrams.  The inputs to this network will be the number of times each of the 26 letters appears in a word, encoded in the activity levels of 26 input neurons.  The outputs will be the ordering of those letters relative to alphabetical, using $n$ output neurons for a maximum word length $n$.  (For example, a lowest-to-highest ranking of outputs of 3-2-4-1-5 for the input `ortob' would imply the ordering 3-2-4-1-5 of the characters `b-o-o-r-t', which spells `robot'.)\\\vspace{.2in}

\noindent \underline{anagrambler.cicada}

\begin{code} \begin{verbatim}
forEach :: {
    
    counter :: int
    
    code
    
    for counter in <1, top(args[1])>  &
        args(args[1][counter], counter)
}


anagrambler :: neural_network : {
    
    setupNN :: {
        
        ltr :: string
        params :: { step_size :: learning_rate :: double }
        
        
        code
        
        params = { .5, .1 }
        if trap(
            the_word = args[1]
            (params<<args)()
        ) /= passed  then (
            printl("Error: optional params are step_size, learning_rate")
            return      )
        
        forEach(NN_in;
            ltr =! alph[args[2]]
            args[1] = find(the_word, ltr; mode = 0)    )

        NN_out[^size(the_word)]
        NN_out[].letter =! the_word
    }
    
    
    ask :: setupNN : {
        
        outputString :: string
        
        
        code
        
        process(NN_in, params.step_size)
        
        sort(NN_out, 2)
        
        NN_out[^numOutputs]
        NN_out[].order = activity[<numInputs+2, numInputs+numOutputs+1>]
        if size(the_word) < numOutputs  then NN_out[^size(the_word)]
        
        sort(NN_out, 1)
        outputString =! NN_out[].letter
        
        print(outputString)
    }
    
    
    teach :: setupNN : {
        
        c1 :: int
        
        
        code
        
        forEach(NN_out; args[1].order = args[2]/size(the_word))
        sort(NN_out, 2)
        
        NN_out[^numOutputs]
        
        for c1 in <1, args[2]>  &
            process(NN_in, NN_out[].order, params.step_size, params.learning_rate)
    }
}


the_word :: string
NN_in :: [26] double
NN_out :: [anagrambler.numOutputs] { order :: double, letter :: char }

alph := "abcdefghijklmnopqrstuvwxyz"
\end{verbatim} \end{code}

At last, we're ready to build a digital brain and put it to the task of unscrambling anagrams.  We run Cicada, then load each of the two \verb#.cicada# source files.

\begin{code} \begin{verbatim}
> run("NN")


> run("anagrambler")
\end{verbatim} \end{code}

Next we specify how big of a brain we need.  Let's decide to work with words of 6 or fewer characters (so, 6 output neurons), and of course we expect a 26-character alphabet (lowercase only please).

\begin{code} \begin{verbatim}
> anagrambler.init(26, 6, 0)
\end{verbatim} \end{code}

With the custom brain built and ready, we can try

\begin{code} \begin{verbatim}
> anagrambler.ask("lleoh")

ehllo
\end{verbatim} \end{code}

\noindent Hardly a surprise; we haven't taught it its first word yet.

\begin{code} \begin{verbatim}
> anagrambler.teach("hello", 10)    | 10 = # training cycles


> anagrambler.ask("lleoh")

hello
\end{verbatim} \end{code}

\noindent Voil\`a---it successfully reconstructed a pattern.

A little bit of playing around shows that our little network can actually learn a few words at a time.  Next we might rebuild it to learn longer words, or see if adding more hidden neurons increases its vocabulary -- the experimental cycles are very short with a command prompt.  There are also the training parameters -- is 10 rounds of training on each word too many?  Will our network learn faster if we increase the learning rate, or will it become unstable?  It's simple to test.

\begin{code} \begin{verbatim}
> anagrambler.teach("hello", 5; learning_rate = that*2)
\end{verbatim} \end{code}

One final detail: it's annoying to have to type ``\verb#run("NN"), run("anagrambler")#" every time we start our program.  Going back to \verb#NN.c#, let's write a script that runs those commands and have \verb#runCicada()# run that script before presenting the command prompt.  \verb#NN.c#'s \verb#main()# function now reads:

\begin{code} \begin{verbatim}
int main(int argc, char **argv)
{
    const char *startupScript = "run(\"NN\"), run(\"anagrambler\")";
    return runCicada(fs, startupScript, true);
}
\end{verbatim} \end{code}

\noindent Now our compiled application is basically a version of Cicada that has a C-coded Anagrambler engine built into the language.




% --------------- CALLING CICADA FROM A C PROGRAM --------------

\newpage

\section{Calling Cicada from a C program}

Before we can use Cicada, we have to install it as a C library.  Go to the download directory and run:

\begin{code} \begin{verbatim}
./configure && make && make install
\end{verbatim} \end{code}

\noindent Once installed, Cicada can be called from any C program.  Here's how:

\begin{itemize}
\item Load the Cicada header file into any source file that needs it:
\begin{code} \begin{verbatim}
#include <cicada.h>
\end{verbatim} \end{code}
\item Add the following linker flag:
\begin{code} \begin{verbatim}
-lcicada
\end{verbatim} \end{code}
\item The actual function call to run Cicada is:
\begin{code} \begin{verbatim}
runCicada(fs, myScript, runTerminal);
\end{verbatim} \end{code}
\end{itemize}

\noindent The three arguments to \verb#runCicada()# are:

\begin{enumerate}

\item \verb#fs# is an array of \verb#const Cfunction# variables, each corresponding to a C function in our code that Cicada will need to call.  Each \verb#Cfunction# is 1) a string which is the function's name in Cicada, followed by 2) a pointer to a function in our C code of type \verb#ccInt f(argsType)#.  For example:
\begin{code} \begin{verbatim}
ccInt f1_in_C(argsType args)  { ... }
ccInt f2(argsType args)  { ... }
const Cfunction fs[] = { { "f1_in_Cicada", &f1_in_C }, { "f2", &f2 } };
\end{verbatim} \end{code}
\noindent The C/Cicada names may be the same or different.  \verb#Cfunction# and \verb#argsType# are defined in \verb#cicada.h#.

\item \verb#myScript# is a C string that gives a script to run when Cicada starts up.  For example:
\begin{code} \begin{verbatim}
char *myScript = "run(\"ThingsToDo\")";     // i.e. ThingsToDo.cicada
\end{verbatim} \end{code}
\noindent If we don't want to run a predefined script, we can just pass an empty string or \verb#NULL#.

\item \verb#runTerminal# is a \verb#bool# value and determines whether to run an interactive terminal.  If it's \verb#true#, Cicada will open an interactive prompt \emph{after} running \verb#myScript#.  If \verb#false#, Cicada will exit after running \verb#myScript#.

\end{enumerate}


\subsection{C function declaration}

A C/C++ function needs to be of type \verb#(ccInt)(argsType)# in order to be called from within Cicada.  \verb#ccInt# will just be C's basic \verb#int# type unless you go in and change it inside of \verb#cicada.h#.  The \verb#argsType# variable contains all the variables and arrays passed from Cicada into the C function, along with information about their datatypes and array sizes.  Each variable or array passed to the C function is a list of one or more Booleans (one per byte), characters, integers, floating-point numbers, or strings.  The number of elements in each argument is fixed; the only dynamic memory allocation intended for C is through resizable strings, as each string is stored in a linked list (see the reference section).

This is the structure of an \verb#argsType# variable named `\verb#a#':

\begin{code} \begin{verbatim}
a.num           // the number of arguments
a.p[i]          // a pointer to the i'th argument
a.type[i]       // an integer giving the primitive type of the i'th argument
a.indices[i]    // the number of array elements in the i'th argument (=1 if it is a scalar)
\end{verbatim} \end{code}

\noindent Table \ref{types_table} lists all of the Cicada types, although our C function will only ever see the primitive types (0-4).  Composite (aka structure) types are broken into their constituent primitive arrays before being passed into a C function, and multidimensional arrays are unrolled into 1D lists.\\

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
type \# (macro) & Cicada type name & C type name & default data type\\
\hline
0 (\verb#bool_type#) & \verb#bool# & \verb#bool# & \verb#bool#\index{bool@\texttt{bool}}\\
1 (\verb#char_type#) & \verb#char# & \verb#char# & \verb#char#\index{char@\texttt{char}}\\
2 (\verb#int_type#) & \verb#int# & \verb#ccInt# & \verb#int#\index{int@\texttt{int}}\\
3 (\verb#double_type#) & \verb#double# & \verb#ccFloat# & \verb#double#\index{double@\texttt{double}}\\
\hline
%4 (\verb#string_type#) & \verb#string# & \verb#linkedlist# & \verb#{ int; void *; int; int; }#\index{linkedlist@\texttt{linkedlist}}\\
%\hline
5 (\verb#composite_type#) & \verb#{ }# & N/A & N/A\\
6 (\verb#array_type#) & \verb#[ ]# & N/A & N/A\\
7 (\verb#list_type#) & \verb#[[]]# & N/A & N/A\\
\hline
\end{tabular}
\caption{Cicada data types.  Types 0 - 3 are primitive} \index{types|textbf}
\label{types_table}
\end{center}
\end{table}

Here is a Cicada-compatible C function that has one argument of each possible data type.  It also checks a) that the correct argument types are being passed, and b) that the first two arguments are scalars.

\begin{code} \begin{verbatim}
ccInt myFunction(argsType args)
{
    bool firstArg = *(bool *) args.p[0];
    char secondArg[2];
    ccInt *thirdArg = (ccInt *) args.p[2];
    ccFloat *fourthArg = (ccFloat *) args.p[3];
    
    secondArg[0] = ((char *) args.p[1])[0];        // copy array data manually here
    secondArg[1] = ((char *) args.p[1])[1];
    
    if (args.num != 4) return wrong_argument_count_err;
    if ((args.type[0][0] != 0) || (args.type[1][0] != 1)
                || (args.type[2][0] != 2) || (args.type[3][0] != 3))  return type_mismatch_err;
    if ((args.indices[0] != 1) || (args.indices[2] != 1))  return type_mismatch_err;
    
    ...
    
    return 0;         // no error
}
\end{verbatim} \end{code}

\noindent This function copies its first two arguments by value and the latter two arguments by reference.  We must pass an argument by reference if it might be changed in the C code.  Arrays are usually passed by reference for efficiency.

Our C function used two Cicada-defined types:  \verb#ccInt# and \verb#ccFloat#.  By default, these two types correspond to \verb#int# and \verb#double#; however these definitions can be changed in \verb#cicada.h#.  If we change \verb#ccInt# we should also make changes to \verb#ccIntMin#, \verb#ccIntMax#, \verb#printIntFormatString#, and \verb#readIntFormatString#; and if we change \verb#ccFloat# then we should also make corresponding changes to \verb#maxPrintableDigits#, \verb#printFloatFormatString#, \verb#print_stringFloatFormatString#, and \verb#readFloatFormatString#. 

There is a handy \verb#getArgs()#\index{getArgs@\texttt{getArgs}} function which simplifies the loading of C variables.\index{checkArgs@\texttt{checkArgs}}

\begin{code} \begin{verbatim}
ccInt myFunction(argsType args)
{
    ...
    if (args.num != 4) return wrong_argument_count_err;
    
    if ((args.type[0][0] != 0) || (args.type[1][0] != 1)
                || (args.type[2][0] != 2) || (args.type[3][0] != 3))  return type_mismatch_err;
    if ((args.indices[0] != 1) || (args.indices[2] != 1))  return type_mismatch_err;
    
    getArgs(args, byValue(&firstArg), byValue(secondArg), &thirdArg, &fourthArg);
    
    ...
}
\end{verbatim} \end{code}

\noindent The first argument of \verb#getArgs()# must be the argument variable; following that is the address of each variable to load, using the \verb#byValue()# macro for each C variable that is not a pointer variable.

Using a different set of macros, we can both load the arguments and perform type-checking:\index{checkArgs@\texttt{checkArgs}}.

\begin{code} \begin{verbatim}
ccInt myFunction(argsType args)
{
    ccInt errCode;
    
    ...
    
    if (args.num != 4) return wrong_argument_count_err;
    
    errCode = getArgs(args, scalarValue(bool_type, &firstArg), arrayValue(char_type, secondArg),
                scalarRef(int_type, &thirdArg), arrayRef(double_type, &fourthArg));
    if (errCode != 0)  return errCode;
    
    ...
}
\end{verbatim} \end{code}

\noindent This example uses all four macros that check-while-passing arguments.  The \verb#scalarValue()# and \verb#arrayValue()# macros copy data into their arguments; the other two copy references (pointers).  The \verb#scalarValue()# and \verb#scalarRef()# macros enforce that the number of indices should be one; the other two do not.

If we only want to load certain selected arguments, we can use \verb#getArgs()# to skip to an argument, and \verb#endArgs# to stop loading arguments\index{endArgs@\texttt{endArgs}}.  Here are some possibilities:

\begin{code} \begin{verbatim}
    getArgs(args, byValue(&firstArg), byValue(secondArg), endArgs);
    getArgs(args, fromArg(1), byValue(secondArg), &thirdArg, endArgs);
    getArgs(args, fromArg(1), byValue(secondArg), fromArg(3), &fourthArg);
\end{verbatim} \end{code}

\noindent Notice that \verb#fromArg()# uses \emph{C-style indexing}, so the next argument read after \verb#fromArg(1)# is \verb#args.p[1]# which is the \emph{second} argument.\\

Let's look an example script that calls `\verb#myFunction()#'.  A typical script first sets up variables and arrays to pass, and then calls the C routine using its Cicada name (the \verb#Cfunction# string passed into \verb#runCicada()#) prefaced by a dollar sign.  We'll assume the Cicada name is the same as the C function name.

\begin{code} \begin{verbatim}
(dbls :: [2][5] double) = { { 0, 1, 2, 3, 4 }, { 5, 6, 7, 8, 9} }
$myFunction(true, "hi", 5, dbls)
\end{verbatim} \end{code}

\noindent This is pretty straightforward:  two of the arguments are constants, \verb#``hi"# is a string of two characters, and \verb#dbls# is a two-dimensional array.  It should be noted that \verb#dbls# is effectively a one-dimensional list as far as the C routine is concerned, and that the order of elements in the list is [1][1], [1][2], ..., [1][5], [2][1], ..., [2][5] (in Cicada notation where indices begin at 1).  So, for example, the array variable written in Cicada as \verb#dbls[2][3]# is in memory slot \verb#fourthArg[7]# within our C code.  \verb#dbls# has 10 array elements in total, so \verb#args.indices[3]# will be 10.  The individual dimensions (2, 5) were \emph{not} passed into C, so if our function needs to know them, then we need to pass them as separate parameters.




\subsubsection{Passing strings and other lists}

A Cicada string is a `list' of characters, the list being a special datatype roughly analogous to an array.  Therefore we can read a string into C the same way we read in a character array, e.g. using the \verb#arrayRef()# macro, as in the examples above.  This method lets us both read and modify the characters in the string, since the characters were passed into C by reference.  However, it does not allow us to resize the string.

In order to pass a string (or other list) that our C function can resize, we have have to instruct Cicada to pass more information about the string than just the pointer to its first character.  This is done in the C function declaration passed to Cicada; for example:

\begin{code} \begin{verbatim}
const Cfunction fs[] = { { "myFunction:dadd", &myFunction } };
\end{verbatim} \end{code}

\noindent The argument styles are specified after the Cicada function name:  `\verb#d#' to pass argument data, and `\verb#a#' to pass a resizable argument.  `\verb#d#' is the default when argument styles are not specified.

Inside the C code, a resizable argument is represented by an \verb#arg# pointer, and requires special functions to access.  Here is how we might modify our example to convert the string to a C-style string with a null terminator.

\begin{code} \begin{verbatim}
    ...
    arg *secondArg;
    char *secondArgChars;
    ccInt numChars;
    ...
    
    getArgs(args, byValue(&firstArg), &secondArg, &thirdArg, &fourthArg);
    
    numChars = 1;
    stepArg(secondArg, 1, &numChars);
    setStringSize(secondArg, 1, numChars+1, &secondArgChars);
    secondArgChars[numChars] = 0;
\end{verbatim} \end{code}

\noindent We could have also written \verb#setMemberTop()# instead of \verb#setStringSize()# -- same arguments, identical functions, only a little bit clearer to write one or the other depending on context.

The other two functions that act on \verb#args#-type variables are \verb#getArgTop()# for obtaining the number of indices spanned by an argument, and \verb#argData()# for getting the data pointer.  For example, we could also obtain \verb#secondArgChars# by writing

\begin{code} \begin{verbatim}
secondArgChars = argData(secondArg);
\end{verbatim} \end{code}

\noindent as long as we call this function \emph{after} resizing \verb#secondArg# (because the pointer will change).

When we pass a whole argument we obtain an object that may have a more complex type than one or more \verb#bool#, \verb#char#, \verb#int#, or \verb#double# variables.  In the example above the argument was a list of characters, i.e. a list variable pointing to a character variable.  We can check these more elaborate datatypes in several ways:

\begin{code} \begin{verbatim}
bool passedCheck = false;
if (args.type[1][0] == list_type)  passedCheck = (args.type[1][1] == char_type);
if (!passedCheck)  return type_mismatch_err;
\end{verbatim} \end{code}

\noindent or

\begin{code} \begin{verbatim}
errCode = getArgs(args, fromArg(1), scalarRef(listOf(char_type), &secondArg), endArgs);
\end{verbatim} \end{code}

\noindent or

\begin{code} \begin{verbatim}
errCode = getArgs(args, fromArg(1), scalarRef(string_type, &secondArg), endArgs);
\end{verbatim} \end{code}

\noindent since \verb#string_type# is shorthand for a list of characters.

There is also a corresponding \verb#array_type# and an \verb#arrayOf()# macro for type-checking.  Although multidimensional arrays become effectively one-dimensional arrays when passing arguments as data, that is not true when a resizable argument is passed, so if we were to pass the fourth argument as an \verb#arg# pointer its desired type would be \verb#arrayOf(arrayOf(double_type))#.



\subsection{A generic wrapper}

To finish off, we'll write a pretty generic Cicada wrapper for \verb#myFunction()# that can be adapted to wrap most other C functions.  One advantage of a wrapper is that it will let us run \verb#myFunction# by typing something like

\begin{code} \begin{verbatim}
yf = f(x, y0)
\end{verbatim} \end{code}

\noindent rather than

\begin{code} \begin{verbatim}
$myFunction(param, x, y, calcData)
\end{verbatim} \end{code}

\noindent The wrapper will also allocate data storage for our function, and prevent us from crashing the C code by passing in bad arguments.  Don't ask me what this function does.\\\vspace{.2in}

\noindent \underline{myFunctionWrapper.cicada}

\begin{code} \begin{verbatim}
f :: {
    x :: string
    y :: error_code :: int
    calc_table :: [][] double
    
    params :: {
        dim1 :: dim2 :: int
        doRecalc :: bool    }
    
    
    code
    
    params = { 2, 5, true }
    if trap(
        { x, y } = args           | mandatory arguments
        (params << args)()        | optional arguments
    ) /= passed  then (
        print("usage:  yf = f(xStr, y0 [; calcSize/doRecalc = ...])\n")
        return      )
    
    calc_table[^params.dim1][^params.dim2]
    
    error_code = $myFunction(params.doRecalc, x, y, calc_table)
    
    if error_code == 0  then return y
    else  print("Error ", error_code, " in function f()\n")
}
\end{verbatim} \end{code}

Our wrapper function has two parts.  The first part is everything before the \verb#code# command, which defines the variables used by function \verb#f()#.  These include the input and output arguments, optional parameters, and even a calculation table used internally by the C routine (because it's easier to pass storage into C than malloc/free it in C).  The most important thing is that the wrapper explicitly defines the type of each variable passed into C, thus ensuring proper communication between the two languages.  For example, when we write \verb#f("a", 5)# the integer argument 5 will be converted to a \verb#double# before handing it off to C, as required by \verb#myFunction()#.

The executable part of \verb#f()# begins \emph{after} the \verb#code# marker.  First \verb#f()# reads its arguments (within a \verb#trap()# statement so that we can fail gracefully with an error message if the function wasn't called properly).  Notice that there are two sorts of function argument: mandatory arguments (\verb#x# and \verb#y#) which are copied straightforwardly from a predefined \verb#args# variable, and optional arguments stored in \verb#params# with default values.  The optional arguments be changed using a very peculiar Cicada trick:  \verb#f()# \emph{runs its own arguments}, as a function, inside of its own \verb#params# variable.  Then it resizes \verb#calc_table#, calls \verb#myFunction()# and returns a result.\\

Load our wrapper by going to Cicada's command prompt and typing:

\begin{code} \begin{verbatim}
> run("myFunctionWrapper")
\end{verbatim} \end{code}

\noindent Here are some examples of function calls we can make once we've loaded our wrapper:

\begin{code} \begin{verbatim}
result := f("a", 5)
print( f("z", 5.78; doRecalc = false) )
result := f("a", 5; dim1 = that*2, doRecalc = false)
\end{verbatim} \end{code}

\noindent Make sure to separate the mandatory and optional parameters using a semicolon, and separate all other arguments or commands using commas.\\

Most prepackaged Cicada functions are actually Cicada wrappers around C functions, and their source files \verb#ciclib.c# and \verb#defs.c# are a rich source of further examples.

\newpage




% --------------- Cicada Scripting --------------


\section{Cicada scripting}



% --------------- Getting started --------------

\subsection{Basic Cicada syntax}

Simple expressions---variable names, numbers, character/string constants---look pretty much the same in Cicada as they do in C.  Character constants\index{characters|textbf} are flanked by single quotes (\verb#'C'#), strings\index{strings|textbf} by double-quotes (\verb#"my_string"#), and numbers are read as either integer or floating-point depending on how they are written.  Likewise, the assignment and arithmetic operators are the same between C and Cicada, except that Cicada also provides an exponentiation operator `\verb#^#' (e.g. \verb#2^3# gives 8).

When we get to variable definitions, Cicada syntax starts to look significantly different from C.  In C, variables definitions are noncoding statements that tell the compiler how to manage the stack.  In Cicada, variable definitions are \emph{commands} that allocate memory on the heap.  The basic way to define a Cicada variable is to use the `\verb#::#' operator:

\begin{code} \begin{verbatim}
x :: int
\end{verbatim} \end{code}

\noindent Here \verb#x# is the variable and \verb#int# is the type.  The allowed primitive types are \verb#int#, \verb#double#, \verb#char#, \verb#string# and \verb#bool# (see Table \ref{types_table} on page \pageref{types_table}).  All Cicada variables \emph{must} be defined before they can be used, and this type cannot change unless the variable is deleted and redefined.

In order to define an array, write the size of each dimension in square brackets just before the type of the array elements.  For example,

\begin{code} \begin{verbatim}
myTable :: [5] [7] double
\end{verbatim} \end{code}

\noindent defines a two-dimensional (5x7) array of floating-point numbers.  Square brackets are also used to access array elements, in the same way as in C:

\begin{code} \begin{verbatim}
print(myTable[2][3])
\end{verbatim} \end{code}

\noindent However:  \emph{in Cicada, array indexing begins at 1}.

It's often convenient to define several variables or arrays of the same type together in one long command.  For example:

\begin{code} \begin{verbatim}
x :: y :: z :: int
table1 :: table2 :: [5] double
\end{verbatim} \end{code}

This example script shows basic usage of variables and arrays.  It's easiest to type this into a file: say, "pythagoras.cicada"..

\begin{code} \begin{verbatim}
| program to find the length of the hypotenuse of a right triangle

sides :: [2] double
hypotenuse :: double
response :: string

print("Side 1:  ")
response = input()
read_string(response, sides[1])

print("Side 2:  ")
response = input()
read_string(response, sides[2])

hypotenuse = (sides[1]^2 + sides[2]^2)^0.5
print("The hypotenuse has length ", hypotenuse, ".\n")
\end{verbatim} \end{code}

\noindent (The first line in this example is a comment, because of the vertical bar \verb#|#.  \verb#print()#, \verb#input()# and \verb#read_string()# are three of Cicada's 30-odd built-in functions.)  To run our script file from Cicada's command prompt, type

\begin{code} \begin{verbatim}
> run("pythagoras")
\end{verbatim} \end{code}

If we want to define our own functions we again use the \verb#::# operator, but with curly braces containing the function code in place of a variable type.  A standard Cicada function consists of three parts:  1) variable definitions; 2) a \verb#code# command; 3) the executable code of the function.  Unlike C functions, a Cicada function doesn't predefine either its arguments or its return value.  Its arguments are accessed through an \verb#args# variable, and the arguments themselves can be modified by the function.  The \verb#return# command works the same way as in C.  Finally, the basic syntax for \emph{calling} a function is the same as in C, although in Cicada fancier kinds of function calls are also possible.

Here is a more elaborate version of our previous example that uses functions, as well as \verb#if# statements and \verb#for# loops whose syntax is a bit different from C.

\begin{code} \begin{verbatim}
| program to find the length of the hypotenuse of a right triangle

GetSide :: {
    response :: string
    side_length :: double
    
    code
    
    side_length = 0
    print("Side ", args[1], ":  ")
    response = input()
    read_string(response, side_length)
    
    if side_length > 0  then (
        return side_length    )
    else  (
        print("Side length must be positive\n")
        exit    )
}

sides :: [2] double
hypotenuse :: double
counter :: int

for counter in <1, 2>  (
    sides[counter] = GetSide(counter)    )
hypotenuse = (sides[1]^2 + sides[2]^2)^0.5

print("The hypotenuse has length ", hypotenuse, ".\n")
\end{verbatim} \end{code}

Cicada also has \texttt{while ... do} and \verb#loop ... until# loops.  There is no `goto' statement.  The equality test `\verb#==#' is the same as in C, but the not-equal test uses the symbol `\verb#/=#' which is different from C.

To exit Cicada type ``\texttt{exit}" at the command prompt.  If there is no command prompt then Cicada is probably stuck and we need to force quit.




% --------------- Expressions --------------

\subsection{Expressions}

At its most basic level, a Cicada script consists of \emph{commands} which are usually written on separate lines:

\begin{code} \begin{verbatim}
a := 2*7 + 9
print(a)
\end{verbatim} \end{code}

\noindent although they may also be separated using commas:

\begin{code} \begin{verbatim}
a := 2*7 + 9, print(a)
\end{verbatim} \end{code}

Unlike in C, we don't need a semicolon at the end of each command -- the line break automatically does that for us.  If we don't want the line break to mark the end of the command, then we usually need to use the line-continuation symbol `\texttt{\&}':

\begin{code} \begin{verbatim}
a := 2* &
    7 + 9
\end{verbatim} \end{code}

\noindent This even works from the command prompt (just make sure that the \texttt{\&} is the \emph{very} last character on the line -- no trailing spaces).  A \verb#&# can appear between any two operators in a command, but not within an operator, name, symbol or string.

Each command consists of variables and constants glued together by operators.  For example, the command \verb#a := 2*7 + 9# contains the variable \verb#a#, three integer constants 2, 7, and 9, and three other operators:  \verb#+#, \verb#*#, and the define-equate operator \verb#:=#. The operators are grouped in the following way:

\begin{code} \begin{verbatim}
a := ( (2*7) + 9 )
\end{verbatim} \end{code}

\noindent That is to say, the multiplication has the highest \emph{precedence} (i.e. it is done first), followed by the addition, and lastly by the define-equate operation which sets \verb#a# to the final value.  If we want to change the default grouping of operators, we use parentheses just as in C:  for example \verb#a := 2*(7 + 9)# would do the addition first.

Table \ref{OoO_table} gives the precedence levels of all Cicada operators.  The final column determines how operators of the same precedence level are grouped.  For example, the division operator falls within precedence level 11 which has left-to-right grouping, meaning that \verb#8 / 4 / 2# is equivalent to \verb#(8 / 4) / 2#.  On the other hand, the define and equate operators all have right-to-left grouping, so \verb#a := b = c = 2# is equivalent to \verb#a := (b = (c = 2))#.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
precedence & commands & symbols & grouping\\
\hline
1 & command breaks & \verb#\n , ;# & right to left\\
\hline
2 & commands & \verb#return remove# & N/A\\
& & \verb#if for while loop# &\\
\hline
3 & define/equate & \texttt{:: ::@ := :=@ @:: *::} &\\
& & \texttt{= <- =@} & right to left\\
& forced equate & \texttt{=! <-!} &\\
\hline
4 & logical and, or, xor & \texttt{and or xor} & left to right\\
\hline
5 & logical not & \texttt{not} & right to left\\
\hline
6 & comparisons & \texttt{== /= > >= < <=} & N/A\\
\hline
7 & substitute code & \texttt{<<} & left to right\\
\hline
8 & array type & \texttt{[]} & right to left\\
\hline
9 & inheritance & \texttt{:} & left to right\\
\hline
10 & add, subtract & \texttt{+ -} & left to right\\
\hline
11 & multiply, divide, mod & \texttt{* / mod} & left to right\\
\hline
12 & negate & \texttt{-} & right to left\\
\hline
13 & raise to power & \verb#^# & left to right\\
\hline
14 & function calls & \texttt{()} &\\
& step to member & \texttt{.} & left to right\\
& step to index/indices & \verb#[] [<>] [+] [-] [^]# &\\
& code number & \verb@#@ &\\
\hline
15 & backstep & \verb#\ parent# & left to right\\
\hline
\end{tabular}
\caption{Order of operations} \index{operations, order of}
\label{OoO_table}
\end{center}
\end{table}

All of the information in Table \ref{OoO_table} comes from the \verb#cclang.c# source file.  That means that anyone can change the Cicada language by just editing that file (see Section 4).






% --------------- Variables --------------

\subsection{Variables}

Cicada variables are either: primitive variables which store data, composite (aka structure) variables which contain other variables, array variables which contain many identical copies of another variable, or lists which are like ragged arrays.  All variables must be be defined before they can be used.  Once created, any variable can have its data overwritten (since there are no constant types in Cicada) or its reference reassigned so that it `points' to another piece of data.  Several variables such as \verb#args# are predefined.


\subsubsection{Primitive variables and constants}

\index{types!primitive|(textbf} Cicada has four primitive variable types:  \verb#bool#\index{bool@\texttt{bool}|textbf}, \verb#char#\index{char@\texttt{char}|textbf}, \verb#int#\index{int@\texttt{int}|textbf}, and \verb#double#\index{double@\texttt{double}|textbf}.  Strings are lists of \verb#char#s.  Types \verb#bool# and \verb#char# each occupy one byte per datum, whereas the sizes of \verb#int# and \verb#double# depend on the definitions \verb#ccInt# and \verb#ccFloat# but default to C ints and doubles respectively.

In order to define a variable, use the define `\texttt{::}' operator.  Several variables of the same type can be defined on the same line.

\begin{code} \begin{verbatim}
height :: time :: g :: double
units :: string
\end{verbatim} \end{code}

\noindent All primitive variables get initialized to some starting value when first created.  That value is:  0 for numeric variables (\verb#int#s and \verb#double#s); the null character for \verb#char# variables; \verb#false# for Boolean variables; and an empty string for \verb#string# variables.

The assignment operator can be written either `\verb#=#' as in C or `\verb#<-#'.  We'll use the C convention.

\begin{code} \begin{verbatim}
g = -9.8
units = "m/s^2"
\end{verbatim} \end{code}

\noindent String constants are inside double quotes, character constants use single quotes, and Boolean constants are \verb#true# and \verb#false#.  Unlike in C, Boolean values are not interchangeable with integers:  \verb#(i::int) = true# is illegal.  However, characters can be treated as ints, so \verb#((c::char) = 'c') = 27# is allowed.

For convenience, we can define and set variables in a single step using the \verb#:=# operator.  So we could have written:

\begin{code} \begin{verbatim}
height :: time :: double
g := -9.8
units := "m/s^2"
\end{verbatim} \end{code}

\noindent Numeric types are assumed to be integers unless there's a decimal point, so if we had rounded to \verb#g := 10# and omitted the decimal point, then `\verb#g#' would have had an integer type.




\subsubsection{Composite variables}

\index{types!composite|(} \index{variables, composite|(} The second type of variable in Cicada is a composite variable, equivalent to a structure variable in C.  Composite variables are collections of \emph{members} defined inside of curly braces, just as in C.  Member definitions can go on their own lines, but make sure the opening brace is on the first line.

\begin{code} \begin{verbatim}
StreetAddress :: {
    number :: int
    street :: string
}
\end{verbatim} \end{code}

\noindent If we don't care about the member names we can leave them out.

\begin{code} \begin{verbatim}
StreetAddress :: { int, string }
\end{verbatim} \end{code}

\noindent \verb#StreetAddress# is a proper variable with its own storage, but we can also treat it as a data type.

\begin{code} \begin{verbatim}
PetersPlace :: StreetAddress
\end{verbatim} \end{code}

\noindent In general any Cicada variable \verb#A# can be used to define other variables \verb#B# and \verb#C#.  In a sense, the define operator copies `type', but not data.

We access members of a composite variable the same way in Cicada as we do in C, using a period\index{pathnames}.  For example (using the original definition with member names):

\begin{code} \begin{verbatim}
PetersPlace.number = 357
PetersPlace.street = "Bumbleberry Drive"
\end{verbatim} \end{code}

Composite variables may be nested inside one another, either using previously-defined types or by nesting curly braces.

\begin{code} \begin{verbatim}
FullAddress :: {
    first_line :: StreetAddress
    second_line :: {
        city :: state :: string
        zip :: int
    }
}
\end{verbatim} \end{code}

\noindent In this case, we need to use a `\texttt{.}' twice to access any of the primitive fields.

\begin{code} \begin{verbatim}
FullAddress.first_line.number = 357
\end{verbatim} \end{code}

\noindent Notice that members of composite variables can also serve as data types.

\begin{code} \begin{verbatim}
GeneralWhereabouts :: FullAddress.second_line
GeneralWhereabouts.city = "Detroit"
\end{verbatim} \end{code}

The type specification of a composite variable determines how it looks initially, but its internal structure can be rearranged later on.

\begin{code} \begin{verbatim}
PaulineAddress :: FullAddress

remove PaulineAddress.first_line.street    | it's a PO box
PaulineAddress.country :: string           | in another country
\end{verbatim} \end{code}

\noindent By the end \texttt{PaulineAddress} will have a three members including one named \verb#country#, and the \texttt{street} member of \verb#first_line# will be missing.  One potential pitfall is that these modifications did \emph{not} change the type specification, so if we ever try to copy its type and data in one operation, then we'll have problems.

\begin{code} \begin{verbatim}
> PaulinesDogAddress := PaulineAddress

Error:  type mismatch
\end{verbatim} \end{code}

Assignment and equality-testing work with whole composite variables just like they do with primitive variables:

\begin{code} \begin{verbatim}
Tom :: Bob :: StreetAddress
...
Tom = Bob
if Tom == Bob  then (      | yes, they will be equal
    print("They're sharing a room.\n")
)
\end{verbatim} \end{code}

\noindent We were allowed to assign and compare \verb#Tom# and \verb#Bob# because they have the same \{ number, string \} structure.

Numeric operations and comparisons do not work with composite variables, even if all their members are numeric.  Expressions like \verb#Tom+Bob# and \verb#Tom > Bob# will always cause an error.\index{types!composite|)} \index{variables, composite|)}



\subsubsection{Array variables}\index{arrays|(textbf}

The third type of Cicada variable is an array variable, which we define by writing the dimension inside square brackets \emph{before} the element type.  Multi-dimensional arrays are allowed.  Examples:

\begin{code} \begin{verbatim}
numDays :: [12] int
checkerboard :: [8][8] bool
coordinates :: [] { x :: y :: double }
\end{verbatim} \end{code}

\noindent If we omit the dimension, as we did in defining \verb#coordinates#, then a size-0 array is produced.  However, it's not quite the same as writing the \verb#[0]# dimension explicitly, because empty brackets tell Cicada that the array is likely to be resized often.  This array will then be given extra internal storage so that new elements can be added efficiently.

We access array elements using square brackets \emph{after} the array name, just as in C.  The last element can be accessed using the keyword \verb#top#.  To access a range of elements $a$ through $b$, write \verb#[<a, b>]#.  To access all elements we can simply write \verb#[]#.

\begin{code} \begin{verbatim}
numDays[1] = 31                                   | assign a single element
numDays[<2, 4>] = { 31, 31, 30 }                  | assign 3 elements
checkerboard[1][1] = checkerboard[1][3] = true    | assign 2 elements
checkerboard[3] = checkerboard[1]                 | assign a whole row of elements
checkerboard[top] = checkerboard[top-2]           | ditto for the 6th and 8th rows
coordinates[].x = coordinates[].y                 | assign all 'x's
coordinates[].y = -1                              | assign all 'y's (scalar-to-array copying)
\end{verbatim} \end{code}

Strings are effectively character arrays, and we can use array operators to access either single characters or ranges of characters.  The single-element operator \verb#[n]# returns a character, whereas the multi-index operator \verb#[<a, b>]# returns a character array (equivalent to a string).  Given two strings \verb#s1# and \verb#s2#, the following commands are legal:  \verb#s1 = s2[<3, 4>]#, \verb#s1 = s2[<4, 4>]#, \verb#s1 =! s2[4]#; however \verb#s1 = s2[4]# is illegal since Cicada does not allow \verb#char#-to-\verb#string# assignment.  Array operators only work on string variables, not string literals, so \verb#"abc"[2]# will cause an error.

Cicada has a technical restriction on the elements we can access simultaneously in multi-dimensional arrays:  their memory has to be \emph{contiguous}.  Internally, the \emph{last} index counts consecutive elements in memory; then the next-to-last index increments; etc.  So the elements of some 2-dimensional array \verb#A# elements are \texttt{[1][1]}, \texttt{[1][2]}, ..., \texttt{[2][1]}, \texttt{[2][2]}, ..., etc as shown in Figure \ref{arrayElementOrder}.  Here are some legal and illegal expressions involving a matrix \verb#A :: [3][4] { x :: ... }#:

\begin{code} \begin{verbatim}
A[<2, 3>]                | legal
A[<2, 3>][<1, 4>]        | legal
A[<2, 3>][2]             | will cause error
A[2][<2, 3>]             | legal
A[1][2]                  | legal of course
A[<2, 3>][].x            | legal -- x is stored separately from other members
\end{verbatim} \end{code}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{arrays}
\caption{Order of elements in a 2-dimensional array `\texttt{A}'}
\label{arrayElementOrder}
\end{figure}

When addressing part of an array using two or more \verb#[]# or \verb#[<...>]# operators, Cicada loses track of how many elements were in each dimension and thinks that it is looking at a one-dimensional list.  For example, if we define:

\begin{code} \begin{verbatim}
grid :: [5][5] int
\end{verbatim} \end{code}

\noindent then both \verb#grid# and \verb#grid[]# refer to a 2-dimensional array, but \verb#grid[][]# is effectively a single 1-dimensional list with 25 elements.



\subsubsection{Lists}\index{lists|(textbf}

Lists are very similar to one-dimensional arrays.  Define a list using double brackets:

\begin{code} \begin{verbatim}
intList :: [[ ]] int
\end{verbatim} \end{code}

\noindent There is no option to set an initial list size -- initially \verb#top(intList)# is zero.  However, if we try to copy data (\verb#intList = { 2, 3, 8 }#), then the list will automatically resize as needed.  At this point we can access the list elements using the normal array operators:  \verb#intList[2]#, \verb#intList[<1, 2>]#, \verb#intList[]#, etc.

The most important difference between lists and arrays is that an array of arrays is a multidimensional array, whereas in an array of lists each list may have a different size.  Therefore the following is legal:

\begin{code} \begin{verbatim}
twoIntLists :: [2] intList
twoIntLists[1] = { 3, 4 }
twoIntLists[2] = { 0, 1, 2 }
\end{verbatim} \end{code}

In Cicada a string is defined as a list of characters.  Therefore \verb#s :: string# is equivalent to \verb#s :: [[]] char#.


\subsubsection{Resizing arrays/lists (and composite variables)} \index{arrays!resizing|(}

All arrays in Cicada that are not `jammed' may be resized, and there are a number of ways to accomplish this.  The most straightforward method is to use the modified index operator \verb#[^...]# which sets the size of a single dimension of the array, as in

\begin{code} \begin{verbatim}
A[^9]
\end{verbatim} \end{code}

\noindent The effect can be either to increase or reduce the size of the array.

Another way to resize an array is to use the all-indices operator \verb#[]# for the \emph{last dimension} of an array that is being copied to.  The last dimension of the array will be resized only if necessary to prevent a mismatched-indices error.  So defining \verb#B :: A, B[^22]# then

\begin{code} \begin{verbatim}
A[] = B[]
\end{verbatim} \end{code}

\noindent should work by forcing a resize of \verb#A#, whereas

\begin{code} \begin{verbatim}
A[<1, 5>] = B[]
\end{verbatim} \end{code}

\noindent will not work.

Finally, we can insert an array index somewhere in the middle of an array using the \verb#[+...]# operator, or the \verb#[+<..., ...>]# operator for multiple indices.  We can also delete array indices using either the \verb#[-<..., ...>]# operator or the \verb#remove# command.  Here are some examples:

\begin{code} \begin{verbatim}
myArray[+5]                      | insert a new element before index 5
myArray[+<3, 6>]                 | insert 4 new elements before index 3
myArray[+<top+1, top+9>] = 17    | add 9 new elements at the end, and set them all to 17

myArray[-<2, 4>]                 | delete array elements 2, 3 and 4
remove myArray[<2, 4>]           | same -- nix elements 2, 3 and 4
\end{verbatim} \end{code}

\noindent New array elements are always initialized in the same way as new arrays are:  for example if it is a numeric array the new elements are set to zero.

All of the operators for accessing, adding and deleting array elements also work on composite variables.  The difference is that, with composite variables, these operators access, add or delete members instead of array elements.  For example, if we define

\begin{code} \begin{verbatim}
threeNums :: {
    a := 2
    b := 5
    c := pi
}
\end{verbatim} \end{code}

\noindent then \verb#threeNums.b# is the same as \verb#threeNums[2]#.  If we want to delete the third member we can type either \verb#remove threeNums.c# or \verb#remove threeNums[3]#.  And we can add two members \emph{between} \verb#a# and \verb#b# by typing \verb#threeNums[+<2, 3>]#.  Those two new members will have no name, and initially will also have no data (see the forthcoming section on the void).  If we enter `\verb#threeNums#' after all these operations Cicada will print \verb#{ 2, *, *, 5 }#, showing that \verb#threeNums.b# is now \verb#threeNums[4]#.  On the other hand, if we add a new member by name rather than by index (e.g. \verb#threeNums.d :: int#), that new member always goes at the end of the structure.

We can never reference multiple elements of a composite variable except when removing them.  So \verb#threeNums[<2, 3>]# is not allowed.



\subsubsection{This and that}

\index{this@\texttt{this}|(textbf}The keyword `\verb#this#' acts as a synonym for the current variable or function where code is being executed.  From the command prompt, \verb#this# typically refers to the entire workspace.  But when a function is running, `\verb#this#' refers to that function.  For example:

\begin{code} \begin{verbatim}
f :: {  int; this = args, return this  }
\end{verbatim} \end{code}

\noindent and type \verb#f(5)#, our function will set its internal integer variable to 5 and return itself:  \verb#{ 5 }#.  In fact, \verb#this# refers to the inside of \emph{any} curly braces it appears in.  For example, here:

\begin{code} \begin{verbatim}
myVar :: {  a := 2, b := this[1]  }
\end{verbatim} \end{code}

\noindent \verb#c# will be set to 2.

The really tricky situation is inside the arguments of a function call, where \verb#this# refers to the function arguments themselves.  For reasons explained elsewhere, if we write

\begin{code} \begin{verbatim}
f(2, 5, this[2])
\end{verbatim} \end{code}

\noindent then we are effectively calling \verb#f(2, 5, 5)#.  This means that, for example, we cannot print the number of workspace variables by typing

\begin{code} \begin{verbatim}
print(top(this))    | won't work
\end{verbatim} \end{code}

\noindent because that command will print `\verb#1#' which is the number of arguments passed to \verb#top()#.  What we really want to do is back out 2 levels, from the arguments of \verb#top()# to the arguments of \verb#print()# and then to the workspace, by typing\index{this@\texttt{this}|)textbf}

\begin{code} \begin{verbatim}
print(top(parent.parent))
\end{verbatim} \end{code}

\noindent \index{parent@\texttt{parent}|(textbf}\verb#parent# is the second predefined keyword, and refers to the object in the search path just before \verb#this#.  A shorthand for \verb#parent# is a backslash character, so the last example could also have been written\index{parent@\texttt{parent}|)textbf}

\begin{code} \begin{verbatim}
print(top(\.\))
\end{verbatim} \end{code}

\index{that@\texttt{that}|(textbf}A third keyword, which should appear only to the right of an assignment operator (\verb#=# or \verb#<-#), is called `\verb#that#', and it refers to whatever was on the left side of the assignment operator.  It can be used to abbreviate cumbersome expressions such as

\begin{code} \begin{verbatim}
facts.num.N = facts.num.N * log(facts.num.N) + facts.num.N
\end{verbatim} \end{code}

\noindent with something like

\begin{code} \begin{verbatim}
facts.num.N = that * log(that) + that
\end{verbatim} \end{code}\index{that@\texttt{that}|)textbf}

\index{args@\texttt{args}|(textbf}The final keyword, called \verb#args#, refers to a function's arguments, which is usually a composite variable.  Here's a quick example:

\begin{code} \begin{verbatim}
I :: {
    code
    return { args, args[2] }
}
\end{verbatim} \end{code}

\noindent If we call \verb#I(1, 2, 3)#, our function \verb#I# sends back \verb#{ { 1, 2, 3 }, 2 }#.\index{args@\texttt{args}|)textbf}




\subsubsection{Aliases} \index{aliases|(textbf}

Aliases in Cicada are a sort of memory-safe alternative to pointers.  An alias is a member that shares its data with some other member:  in other words those two members share a variable.  In Cicada a member and an alias made to it are \emph{exactly} on equal footing:  the interpreter doesn't know or care which came first.

Here is how aliases are defined:

\begin{code} \begin{verbatim}
a := 2       | will default to an int
b :=@ a      | alias #1
c :=@ b      | alias #2
\end{verbatim} \end{code}

\noindent `\verb#b#' is now an alias to `\verb#a#', and `\verb#c#' is now an alias to `\verb#b#' and therefore also to `\verb#a#'.  If we were to now \texttt{print(a)}, \texttt{print(b)} or \texttt{print(c)}, we would get back the number 2.  If we were to set any of the three variables to a different value:

\begin{code} \begin{verbatim}
c = 3
\end{verbatim} \end{code}

\noindent then printing any of \texttt{a}, \texttt{b} or \texttt{c} would then cause the new number 3 to be printed.

Any variable can become an alias for any other variable \emph{of the same type} (or a derived/inherited type), by means of the equate-at operator `\texttt{=@}'.

\begin{code} \begin{verbatim}
a :: b :: c :: int
{ a, b, c } = { 1, 2, 3 }
a =@ b                | 'a' now points to the variable storing '2'
b =@ c                | 'a' STILL points to the variable storing '2'
c =@ b =@ a
\end{verbatim} \end{code}

\noindent The tricky bit is the fourth line:  since member `\verb#a#' has been aliased to member `\verb#b#', does the command \verb#b =@ c# now drag member \verb#a# along with it?  The answer is no:  aliasing binds one member to another member's variable, not to the other member itself.  If we follow through all the acrobatics, we find that members \verb#a#, \verb#b#, and \verb#c# all end up referring to same the variable storing the number 2, as shown in Figure \ref{aliases}.  The other two variables are now permanently inaccessible and will eventually be cleared from memory.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{aliases}
\caption{Aliasing of members (letters) to variables (boxes)}
\label{aliases}
\end{figure}

Cicada clearly makes an important distinction between members and variables.  A member\index{members|textbf} is a named object in Cicada:  the name of a variable, or a field in a composite variable.  The variable itself is the data that the member refers to.  In Cicada these two objects are entirely separate, and there is no reason to require a one-to-one correspondence between them, as Figure \ref{aliases} shows.

Just as the data-copying operator `\verb#=#' or `\verb#<-#' has a data-comparison counterpart `\verb#==#', so the reference-copying operator `\verb#=@#'  is mirrored in a reference-comparison operator `\verb#==@#' which tests to see whether two members point to the same object.  (If the left side spans a range of array elements, then the right side must also span exactly those same elements in order for the test to return true).  Finally, the are-references-not-equal operator `\verb#/=@#' is just the logical negation of `\verb#==@#'.  Whitespace just before the `@' is allowed:

\begin{code} \begin{verbatim}
if a == @b  then c := @b
if a /= @b  then a = @b
\end{verbatim} \end{code}

\noindent and can help make clearer the analogy with the data-copying operators.  Both \verb#a = @b# and \verb#a = b# cause member `\verb#a#' to equal member `\verb#b#', though by different means.\index{aliases|)textbf}



\paragraph{Jamming} \index{arrays!jamming|(}

Arrays can also be involved in aliasing.  For example, scalar members can alias single array elements, and array members can alias other array members having compatible types.

\begin{code} \begin{verbatim}
array_1 :: [5] double
array_2 :: [10] double
oneEl :: double

oneEl = @array_1[4]
oneEl = @array_2[top]
array_1 = @array_2
\end{verbatim} \end{code}

\noindent It gets a little more complicated when aliasing array \emph{elements}.  This is different from aliasing arrays:  \verb#a1[] = @a2[]# is different from \verb#a1 = @a2#.  Cicada doesn't let us re-alias only part of the source array, since doing so would fragment its storage, but we can alias all source array elements to a part of a target array.  For example, 

\begin{code} \begin{verbatim}
array_1[] = @array_2[<4, 8>]
\end{verbatim} \end{code}

\noindent is legal, as long as \verb#array_1# had 5 elements to begin with (aliasing can't resize an array).  However, we \emph{cannot} write

\begin{code} \begin{verbatim}
array_1[<3, 5>] = @array_2[<4, 6>]
\end{verbatim} \end{code}

There's an additional complication: what happens if we try to resize one of those two arrays?  That could force a resize of another alias, which is not allowed.  The solution is that parts of an array having multiple members pointing to them can become `jammed', meaning that they cannot be resized until all but one of the aliases is removed.  For example:

\begin{code} \begin{verbatim}
array_1 :: [3][10] int
array_2 := @array_1[2][<4, 7>]   | jams 4 indices of array_1

array_1[][^12]         | legal - indices 11-12 aren't aliased by array_2
array_2[^12]           | no, this would cause problems
remove array_1[][5]    | not legal -- would remove 2nd column of array_2
remove array_1[1]      | legal

remove array_1
array_2[+3]            | legal only because we removed the jamb
\end{verbatim} \end{code}

Explicit aliases always jam arrays.\index{aliases}  On the other hand, `tokens' or unnamed references to objects (such as elements of sets and function arguments) never jam arrays.

\begin{code} \begin{verbatim}
al := @my_array[<4, 6>]    | jams elements 4-6
my_array[<4, 6>]           | does not jam
\end{verbatim} \end{code}

\noindent Tokens\index{tokens} are `unjammable', both in the sense that they cannot jam, and that they will become `unjammed'---i.e. permanently deactivated---if their referent is resized through another member.  An unjammed token becomes unusable until it is redefined, usually when the command defining the token is rerun.\index{arrays!jamming|)}





\subsubsection{The void}

\index{nothing@\texttt{nothing}|(textbf}\index{void, the|see{nothing}}There is one last variable `type', which is no type at all.  There are two ways of writing this:

\begin{code} \begin{verbatim}
var1 :: nothing
var2 :: *
\end{verbatim} \end{code}

\noindent \verb#nothing# and \verb#*# are synonyms for the void.  If \verb#var1# is defined as void then we will get a void-member error if we try to access its data.  In fact, one of the few things we can do with a void member is to test whether it is void or not, using the reference-comparison operator \verb#==@#.

\begin{code} \begin{verbatim}
if var1 == @nothing  then &
    print("out of order..\n")
\end{verbatim} \end{code}

One way to make use of a void member is to redefine it.

\begin{code} \begin{verbatim}
var1 :: nothing
var1 :: [1000] string
\end{verbatim} \end{code}

\noindent We could have redefined \verb#var1# as anything:  a primitive or composite variable, function, etc.  But now that it has a non-void type, \verb#var1# cannot be redefined again except to the same type or a derived type (see inheritance).

What is the use of having void-typed variables, if we can't use them while void?  The main reason is that members without no type are \emph{universal aliases} (because all other data types are daughters of the void).  Just make sure to alias using the \verb#=@# operator, not the \verb#:=@# operator as the latter will redefine its type.

\begin{code} \begin{verbatim}
any_var :: *
x :: int
y := "some string"
z :: { double, int }

any_var = @x
any_var = @y
any_var = @nothing
any_var = @z
\end{verbatim} \end{code}

The fact that the void is the universal parent type also explains why void members can be redefined to any other type.  Cicada always permits an existing member's type to be specialized---restricted to a subtype of its original type---but never changed back to a parent or sibling type.  Similar rules apply to aliasing---aliases can be made to variables having inherited types, but not parent types---except that any member is allowed to become unlinked by aliasing to the void.

There are actually two uses of the word `void' in this document that are important to keep logically separate.  A void member is one that has no storage space.  But a void-\emph{typed} member is one with essentially no type restriction on what it can point to.  A definition like \verb#a :: *# does \emph{two} things:  it defines a member `\verb#a#' having no type, and it therefore neglects to give `\verb#a#' any storage space.

Cicada also distinguishes between member types and variable types.  For example, after \texttt{any\_var} was aliased to \texttt{x}, did \texttt{any\_var} have a null type or was it an \verb#int#?  Well, that depends on whether you are asking about the member's type (which was void), or the type of the variable it points to (an integer).  Both members and variables have types, and in general they may be different.  A member's type specification\index{members!type|(} determines which variables it is allowed to point to, and if the two types are different then the member type must be a parent of the variable type.\\




\subsection{Other define and equate operators}

The distinction between member type and variable type motivates two further define operators.\\

The variable-define operator `\texttt{@::}' is identical to ordinary define (\texttt{::}), except that it only sets the target variable's type, while leaving the member's type unchanged.  That means that if it is used to define a brand new member, that member's type will be void.  For example, here we use this operator to define and then redefine a member with different types of storage, and then alias it to another variable of a different type.

\begin{code} \begin{verbatim}
theVar @:: int
...
theVar = @nothing    | need to unlink before creating a new variable
theVar @:: string
...
theBool :: bool
theVar = @theBool
\end{verbatim} \end{code}

\noindent Notice that the second \verb#@::# operator was forced to make a new variable because \verb#theVar# had been unlinked (aliased to the void) on the previous line.  Had we left out the unlinking command, Cicada would have tried to redefine the existing \verb#int# \emph{variable} as a \verb#string#, causing a type-mismatch error.

The member-define operator `\texttt{*::}' is the counterpart to variable-define:  it only acts upon the member, without affecting any variable currently aliased by this member.  Its symbol reflects the fact that, if one uses member-define to define a new member, it will indeed create a member of the desired type but it will not bother to create a variable for it:  the member will point into the void.  So the following code will cause an error:

\begin{code} \begin{verbatim}
myNum *:: int
myNum = 5      | will cause an error
\end{verbatim} \end{code}

\noindent which could have been avoided had we written \verb#myNum :: int# or \verb#myNum @:: int# between the two lines, in order to construct an integer variable for the member.\index{nothing@\texttt{nothing}|)textbf}\index{members!type|)}

There are actually 256 possible define/equate/alias operators, most of which cannot be scripted directly unless we modify the language.  See Section 5.\\

Finally, there is another assignment operator called `forced-equate', and given the symbol `\texttt{=!}' or `\verb#<-!#'.  While equate copies data between variables whose data structures match or are compatible (e.g. \verb#{ int, string }# to \verb#{ double, string }#), forced equate copies between variables having the same memory storage size.  (Having a string or other list in the destination variable makes the storage requirement somewhat elastic.)  A forced equate simply takes the data contained in its right-hand argument and stuffs those $N$ bytes in the same order into the left-hand variable, with no restrictions on how the storage space is parceled out within the destination variable.

When forcing an equate from data having numeric constants, remember that Cicada interprets each written number as either as \verb#int# or \verb#double#.  So for example, if long integers are 4 bytes and doubles are 8 bytes, \verb@a =! -4@ and \verb@a =! 2e5@ each copy 4 bytes while \verb@a =! 4.@ and \verb@a =! 2e10@ each copy 8 bytes.

Here are some examples showing the difference between these two operators:

\begin{code} \begin{verbatim}
var1 :: { int, bool }
var2 :: { double, bool }
var3 :: { int, string }

var1 = var2    | OK
var1 = var3    | type-mismatch error

var1 =! var2   | unequal data size error
var1 =! var3   | unequal data size error unless string has 1 character
var3 =! var1   | OK, surprisingly!
\end{verbatim} \end{code}

\noindent The last line works because forced-equate resizes \verb#var3#'s string as needed to soak up any extra bytes from \verb#var1#.




% --------------- Flow control --------------


\subsection{Loops and \texttt{if} blocks} \index{flow control|(}

Cicada has five commands for controlling the program flow:  \verb#if# statements, \verb#for# and \verb#backfor# loops, and \verb#while..do# and \verb#loop..until# loops.


\subsubsection{\texttt{if}} \index{if@\texttt{if}|(}

There are several differences in syntax between an \texttt{if} statement in Cicada and one in C.  Firstly, the logical test is between the \verb#if# and a \verb#then# keyword, rather than being inside parentheses.

\begin{code} \begin{verbatim}
if a == b  then print("They're equal.\n")
\end{verbatim} \end{code}

\noindent Secondly, some of the logical operators are different.  `\verb#and#'\index{and@\texttt{and}}, `\verb#or#'\index{or@\texttt{or}}, `\verb#xor#'\index{xor@\texttt{xor}} and `\verb#not#'\index{not@\texttt{not}} are all written out in words, and the is-not-equal operator is \verb#/=#, not \verb#!=#.  Cicada also has the reference-comparison operators `\verb#== @#' and `\verb#/= @#' (see \emph{aliases}).

\begin{code} \begin{verbatim}
if a == @nothing and b /= @nothing  then print("a, but not b, is void.")
\end{verbatim} \end{code}

\noindent Third, since the entire \verb#if# statement is one single command and (unlike in C) a line break \emph{ends} commands, if we want to break it over several lines we need to either use a `\verb#&#' which continues lines, or else parentheses \emph{beginning on the line} of the \verb#if# statement.

\begin{code} \begin{verbatim}
if a == b  then &
    print("They're equal.\n")

else if a /= b  then (
    print("They're different.\n")
)
\end{verbatim} \end{code}

\noindent Finally, the latter method shows how to write multi-line \verb#if# statements:  using parentheses instead of curly braces.  (Technical note:  while curly braces actually work for most \verb#if# statements, they also produce a new variable space, so new member definitions and use of the keyword \verb#this# won't do what you expect.)

\begin{code} \begin{verbatim}
if a /= @nothing and b /= @nothing  then (       | avoid a crash
    if a == @b  then print("They're the same variable!\n")
    else if a == b  then print("They're equal.\n")
    else  print("They're different.\n")      )

else  print("At least one of these members is VOID!")
\end{verbatim} \end{code}

\index{if@\texttt{if}|)}



\subsubsection{\texttt{while do} and \texttt{loop until}} \index{while@\texttt{while}|(} \index{loop@\texttt{loop}|(} \index{until@\texttt{until}|(}

Cicada's \verb#while...do# loop is pretty similar to C's \verb#while# loop, except that the logical condition goes between the \verb#while# keyword and a \verb#do# keyword instead of inside parentheses.  Also, the logical operators are somewhat different and we use parentheses to group multi-line commands, in the same way as with the \texttt{if} statement.

\begin{code} \begin{verbatim}
while input() /= "pleeez"  do print("what's the magic word?  ")
while input() == "thank you"  do (
    print("you are welcome!\n")
    print("anything else?  ")
)
\end{verbatim} \end{code}

There are two differences between Cicada's \texttt{loop} loop and its \verb#while# loop.  First, the break condition of a \texttt{loop} loop is evaluated at the end of the loop, so it always runs at least once.  Second, it is a \verb#loop...until# loop, not a \verb#loop...while# loop, so it keeps looping as long as the logical condition is \emph{not} satisfied.

\begin{code} \begin{verbatim}
attempt := 0
loop  (
    print("Thank you!\n")
    attempt = attempt+1
)  until input() == "you're welcome"

loop print("> ") until input() == "exit"
\end{verbatim} \end{code}

\index{while@\texttt{while}|)}\index{loop@\texttt{loop}|)}\index{until@\texttt{until}|)}



\subsubsection{\texttt{for}} \index{for@\texttt{for}|(}

Cicada's \texttt{for} loop is simpler and offers less control than C's.  Here is an example showing the syntax.

\begin{code} \begin{verbatim}
counter :: int
for counter in <1, 10-counter>  print(counter, " ")
\end{verbatim} \end{code}

\noindent Notice that we had to define the loop variable before the loop, as either an \verb#int# or a \verb#double#.  The loop itself will print the numbers 1 through 5; when \verb#counter# reaches 6 it will be greater than \verb#10-counter# and the loop will stop.

As always, we can break a loop over two lines using a `\verb#&#', and we can group several lines of code using parentheses beginning on the line of the \verb#for# command.  So we could have rewritten our code above in several different ways.

\begin{code} \begin{verbatim}
counter :: int

for counter in <1, 10-counter>  &
    print(counter, " ")

for counter in <1, 10-counter>  (
    print(counter)
    print(" ")
)
\end{verbatim} \end{code}

\noindent There is no \verb#step# argument to control the increment of the counter variable, due to limitations of the compiler.  If we need a non-1 step we have to use a \verb#while# loop instead:

\begin{code} \begin{verbatim}
counter := 1
while counter <= 10-counter  do (
    print(counter, " ")
    counter = that + 2
)
\end{verbatim} \end{code}

\index{for@\texttt{for}|)}


\subsubsection{\texttt{backfor}} \index{backfor@\texttt{backfor}|(}

This is a \verb$for$ loop that counts backwards (since \verb$for$ does not have this capability).  For example,

\begin{code} \begin{verbatim}
counter :: int
backfor counter in <1, 9>  print(counter, " ")
\end{verbatim} \end{code}

\noindent produces the output \verb$9 8 7 6 5 4 3 2 1$.

\index{backfor@\texttt{backfor}|)}




\subsubsection{\texttt{break}} \index{break equivalent|(}

There is no \verb#break# statement in Cicada.  But there is a way to jerry-rig something that does pretty much the same.  The trick is to put braces -- with no \verb#code# marker or semicolon -- around the code we eventually want to escape from.  Within those braces, a \verb#return# statement will simply escape from the bracketed code and continue with what follows.  For example:

\begin{code} \begin{verbatim}
{
    for counter in <1, 10>  (
        print(counter)
        if input() == "q"  then return    )
}
print("finished with counter = ", counter)
\end{verbatim} \end{code}

\noindent This works because the braces define a new composite variable, and the code inside the braces is actually running inside of this variable.  Be wary of pitfalls:  if we define a member, that member will be inside of this variable, which was probably not intended.  `\verb#this#' now refers to this newly-defined variable, while `\verb#parent#' now refers to the location outside the braces.  Also, if this is all inside of a function definition, we can't return from the function until we leave the braces block.  On the upside, we have a lot of latitude in choosing where to break from and to:  it doesn't have to escape from a loop, and we can jump out of several nested loops at once unlike in C where we always fall back to the enclosing loop.\index{break equivalent|)}

\index{flow control|)}





% -----------------  Sets  ----------------


\subsection{Sets} \index{sets|(}

Sets are like magical bags of objects that are also found somewhere else in the code:  variables, functions, classes, other sets, whatever.  To define a set we write curly braces around a list of objects separated by commas (or end-of-lines).  Here is an example where each object is in several places.

\begin{code} \begin{verbatim}
Alice :: Bob :: Christine :: Daniel :: Joe :: friend_of_mine

men :: { Daniel, Joe, Bob }
neighbors :: { Christine, Bob }
cleaning_schedule :: { Bob, Alice, Bob, Alice, Joe, Joe, Daniel }
\end{verbatim} \end{code}

\noindent We can access members of a set using square brackets (as if they were arrays).  So after running the code, \texttt{Bob}, \texttt{men[3]}, \texttt{neighbors[2]}, \texttt{cleaning\_schedule[1]} and \texttt{cleaning\_schedule[3]} are all the same thing.  If we set \verb#men[3].needsSleep = true# then \verb#Bob.needsSleep# and \verb#neighbors[2].needsSleep# will also be \verb#true#.  Notice how the same object can even appear in several places in a set.  Sets come handy when the objects have convoluted path names.

\begin{code} \begin{verbatim}
to_buy :: {
    food.produce.fruits.apples
    clothes.shoes.black
    clothes.socks.black
}
\end{verbatim} \end{code}

\noindent \verb#to_buy[1]# is much quicker than \texttt{food.produce.fruits.apples}.

Cicada sets are pretty flexible in what they can store.  Along with variables, we can throw constants, other sets (including inlined subsets), and even the void into the bag.

\begin{code} \begin{verbatim}
collections :: { men, neighbors, { Patty, Don }, "Herbert", 3.3, this[3], this, nothing }
\end{verbatim} \end{code}

\noindent Here \verb#collections[3]# is an inlined subset containing two objects.  The fourth and fifth items are inlined constants.  \verb#collections[6]# is basically an alias for the third item, the subset containing \verb#Patty# and \verb#Don#, and notice that it had to be listed after the third item because otherwise \texttt{this[3]} would not have existed yet.  \verb#collections[7]# is \verb#collections# itself -- so \verb#collections[7][7][7][2]# is just \verb#neighbors#.  Trying to print \verb#collections# from the command line won't work because of the infinite self reference.

The reason we access set elements by their index (as opposed to name) is that those set elements \emph{have no name}, at least the way we defined them in our examples.  In other words, \verb#collections[1]# is effectively an alias for \verb#men#, but that doesn't mean it has the name \verb#men#---typing \texttt{collection.men} will cause Cicada to draw a blank.  But there is actually a way to name certain elements of a set, and that is to manually define aliases for their respective objects.  To illustrate, here we give a different way of defining \texttt{collections} which assigns names to members 2, 3, 4, 7 and 8.

\begin{code} \begin{verbatim}
collections :: {
    men
    neighbors := @parent.neighbors      | use same name for convenience
    peeps :: { Patty, Don }
    Herby := "Herbert"
    3.3,  this[3]          | set elements 5 and 6
    myself := @this
    zilch := @nothing
}
\end{verbatim} \end{code}

\noindent With the verbose definition we can write \texttt{collections.Herby} in place of \texttt{collections[4]}, although \texttt{collections[4]} is still perfectly legal.

Just as with composite variables, items can be added to and removed from sets after they have been defined.  So if we want to shuffle ``\texttt{Herbert}'' to the end of the set we might write:

\begin{code} \begin{verbatim}
collections[top+1] := @collections.Herby
remove collections.Herby
\end{verbatim} \end{code}

As with variables, we can use one set to define another.  The following is legal:

\begin{code} \begin{verbatim}
newCollections :: collections
\end{verbatim} \end{code}

\noindent Importantly, \verb#newCollections# is defined using the old set \verb#collections#'s \emph{original} definition.  So even if we had rearranged the elements of \verb#collections#, in the new set \verb#Herbert# will be both at \verb#newCollections[4]# and \verb#newCollections.Herby#.  We might as well have defined both sets on the same line:

\begin{code} \begin{verbatim}
newCollections :: collections :: { ... }
\end{verbatim} \end{code}

Here is a tricky situation:

\begin{code} \begin{verbatim}
f :: ...
g :: { ; r :: {}, r[+1]:=args[1], return r }
rtrns :: { f(5), f(12), g(3) }
\end{verbatim} \end{code}

\noindent Each set element is a \emph{copy} of a function's return value, as if it was defined using a \verb#:=# operator.  Normally this is fine, but here \verb#g()#'s return value `\verb#r#' \emph{cannot be copied} using that operator, because its structure \verb#{int}# doesn't match its original definition \verb#{}#!  In this case we can copy the return value `by reference' instead, by making an anonymous alias:

\begin{code} \begin{verbatim}
rtrns :: { f(5), f(12), @g(3) }
\end{verbatim} \end{code}

\noindent Let's just hope \verb#f()# doesn't have the same problem, because if we alias both \verb#f()# calls then the second call will overwrite the first.  This potential pitfall also lurks in function arguments, since an argument list is simply a set passed into a function.

\index{sets|)}






% -----------------  Functions  ----------------


\subsection{Functions} \index{functions|(}

A basic Cicada function call looks exactly the same as a C function call.

\begin{code} \begin{verbatim}
y = f(x)
\end{verbatim} \end{code}

\noindent But behind the familiar syntax roams what is probably the strangest beast in the Cicada menagerie.  For one thing, Cicada functions are \emph{objects} that live in ordinary heap memory, unlike their stack-dwelling counterparts in C.  Cicada functions have no input type and no output type, and they can have several coding sections.  Function arguments are hopelessly different from their C counterparts.  These changes together allow Cicada functions to be used in some unusual ways.



% -----------------  Function definitions  ----------------

\subsubsection{Defining functions (properly)}

Cicada functions are \emph{objects}, like composite variables and sets (the analogy here is closer than you would think).  So we define functions using the same operators we use for defining other objects.  The function code goes inside curly braces beginning on the line of the definition.  Here is an example.

\begin{code} \begin{verbatim}
SwapDigits :: {
    
    tensDigit :: onesDigit :: int
    
    code
    
    tensDigit = floor(args[1] / 10)
    onesDigit = args[1] mod 10
    
    return 10*onesDigit + tensDigit
}
\end{verbatim} \end{code}

\noindent The function has two Cicada keywords.  1) A `\texttt{code}'\index{code@\texttt{code} marker|textbf} marker (or semicolon) separates the function's variable definitions from its executable code.  Before the \verb#code# marker, the function's internal variables are defined in exactly the same way as global variables in the workspace are defined.  2) Function arguments are contained inside of an \texttt{args}\index{args@\texttt{args}} variable, and we access them using the index operators \verb#[]#.  The function exits with the classic \texttt{return}\index{return@\texttt{return}} statement, just as in C.

Once we have written the function, we can run it in the normal way.

\begin{code} \begin{verbatim}
> print(SwapDigits(27))

72
\end{verbatim} \end{code}

\noindent From the command line we can also just type the function name and read off the output:

\begin{code} \begin{verbatim}
> SwapDigits(27)

72
\end{verbatim} \end{code}

\noindent Sometimes the automatic output can be annoying:  the function may be performing an important task but we don't care about the return value.  To throw away the return value, append a `$\sim$' operator to the function call:  \texttt{SwapDigits(27)}$\sim$.

In Cicada we can treat functions as if they were variables, peek at all their internal members, and even fiddle around inside them.  This is useful for debugging.

\begin{code} \begin{verbatim}
> SwapDigits.tensDigit            | did it do what we wanted?

2

> remove SwapDigits.onesDigit     |  let's see if it still works..
\end{verbatim} \end{code}

Finally, functions can define other functions:

\begin{code} \begin{verbatim}
> SD2 :: SwapDigits
\end{verbatim} \end{code}

\noindent We broke \verb#SwapDigits()# when we deleted its \verb#oneDigit# member, but \verb#SD2# is defined using the \emph{original definition} of \verb#SwapDigits# so it will work just fine.

One situation that requires several copies of a function is recursion\index{recursion|(}.  This is because each nested recursive instance of the function requires its own storage.  This is true whether a function \verb#f()# calls itself directly or indirectly (\verb#f()# calls \verb#g()# calls \verb#f()#).  Here is an example that handles recursion properly.

\begin{code} \begin{verbatim}
factorial :: {
    
    nextFact :: *
    numToReturn :: int
    
    code
    
    if args[1] == 1  then numToReturn = 1
    else  (
        if nextFact ==@ * then nextFact :: this
        numToReturn = args[1] * nextFact(args[1]-1)
    )
    
    return numToReturn
}
\end{verbatim} \end{code}

\noindent Importantly, the definition \verb#nextFact :: this# had to be in the \emph{coding section} of \verb#factorial()#.  If we had put the \verb#nextFact()#'s definition \emph{before} the \verb#code# marker, \verb#factorial.nextFact# would have defined another member \verb#factorial.nextFact.nextFact#, etc. until Cicada threw in the towel with a recursion-depth error.\index{recursion|)}

Here is one unusual feature\index{code number operator|(} of Cicada functions:

\begin{code} \begin{verbatim}
f :: {
    num := 2
    
    code
    num = that + 1
    
    code
    return num   }
\end{verbatim} \end{code}

\noindent Two coding blocks---so there should be a way to access them both.

\begin{code} \begin{verbatim}
> f()


> f#2()

3
\end{verbatim} \end{code}

\noindent The code-number operator `\verb$#$' lets us run the code beginning at the $N$th \verb#code# marker.  By running \verb$f()$, which defaults to \verb$f#1()$, we incremented \verb#f.num#.  But execution stopped at the next \verb#code# marker.  There was no \verb#return# statement, which is fine:  the function returns \verb#nothing#, just as it would had we written \verb#return# or \verb#return *#.  In order to get a value back we had to run the \emph{second} coding block which returned \verb#f.num#.  Incidentally, if we run \verb$f#0()$ we rerun \verb#f#'s `constructor' which will reset \verb#f.num# to 2.\index{code number operator|)}

Short functions like \verb#f()# are sometimes easier to code on one line.  To do this, use the fact that 1) commas are equivalent to ends-of-lines, and 2) semicolons are equivalent to \verb#code# markers.

\begin{code} \begin{verbatim}
> f :: {  num := 2; num = that + 1; return num  }
\end{verbatim} \end{code}







% -----------------  Function arguments  ----------------

\subsubsection{Function arguments} \index{functions!arguments to|(}

Notice that the definition of a Cicada function doesn't specify any argument list.  That means functions in Cicada are automatically able to handle different argument types, variable numbers of arguments, etc.  Here is a simple function that can take any arguments whatsoever, as long as there are at least 2 of them.

\begin{code} \begin{verbatim}
> arg2 :: {  code, return args[2]  }


> arg2(5, 3+9, 'C')                             | return a number

12

> arg2(pi, { a := 3, b := 4; return a*b })      | return a function! 

{ 3, 4 }
\end{verbatim} \end{code}

\noindent Cicada functions also don't specify return types, and as our last example shows a single function can return different kinds of values even from the same \verb#return# statement.  And of course different \verb#return# statements within the same function can return different types of objects.\\

\index{args@\texttt{args}|(textbf}What happens if we stick a \texttt{code}\index{code@\texttt{code} marker} marker (or semicolon) \emph{inside the function's argument list}?  When we try this experiment, we'll find out is that anything after the function arguments' \verb#code# marker isn't created, or doesn't run, until the function \emph{runs its arguments}.

\begin{code} \begin{verbatim}
PrintArgs :: {
    code
    
    print("Before running args:  ", args, "\n")
    args()
    print("Afterwards:  ", args, "\n")
}
\end{verbatim} \end{code}

\noindent If we call

\begin{code} \begin{verbatim}
PrintArgs( 0.3, " 4", code, " word ", 10 )
\end{verbatim} \end{code}

\noindent then the function prints

\begin{code} \begin{verbatim}
Before running args:  0.3 4
Afterwards:  0.3 4 word 10
\end{verbatim} \end{code}

\noindent We can even put coding statements in the function arguments.

\begin{code} \begin{verbatim}
PrintArgs( " *** announcement *** ", code, print("I am an argument list.\n") )
\end{verbatim} \end{code}

\noindent which causes the output

\begin{code} \begin{verbatim}
Before running args:  *** announcement *** 
I am an argument list.
Afterwards: *** announcement *** 
\end{verbatim} \end{code}

\noindent In fact an argument list can run any code whatsoever.  A few tricky points:  if we define variables, etc. inside of an argument list then they will only exist inside that function's \verb#args# variable; \verb#this# inside the argument list refers to \verb#args#, not the variable space where the function was called (that will be \verb#parent#); and \verb#return# inside of \verb#args# only stops execution of \verb#args#'s code.

If we can \emph{run} the \texttt{args} list, surely we can also pass it parameters?  Write a new function to test this:

\begin{code} \begin{verbatim}
> doArgs :: {  code, args(9, "lives"), return args  }


> doArgs( args, code, print(top(args), " arguments were passed\n") )

2 arguments were passed
\end{verbatim} \end{code}

\noindent This example is complicated, particularly the function call (2nd command entered at the prompt).  On this line, within the parentheses, `\texttt{args}' refers to two different things depending on which side of the \verb#code# marker it falls on.  Before the \verb#code# marker, \verb#args# holds the same value it had when the function was called.  But \emph{after} the \verb#code# marker, `\texttt{args}' is the parameter list passed by \texttt{doArgs}, containing the number 9 and the string \verb#"lives"#.  Each function call temporarily replaces the existing \verb#args# variable with its own argument list; the old \verb#args# comes back when each function exits.

Here's another example showing more explicitly how \texttt{args} changes across the \texttt{code} marker.

\begin{code} \begin{verbatim}
f :: {
    code
    
    g( print(args, " --> "), code, print(args) )
}

g :: {  code, args("B")  }
\end{verbatim} \end{code}

\noindent That is, \texttt{f()} runs \texttt{g()}, which in turn runs its own arguments.  Now run \verb#f()#.

\begin{code} \begin{verbatim}
> f("A")

A --> B
\end{verbatim} \end{code}

\noindent Focus on the line in which function \verb#f()# calls function \verb#g()#.  The part of \verb#args# \emph{before} the \verb#code# marker predates \verb#g()#, so here \texttt{args} still has its old value `\texttt{A}'.  The part of \verb#args# \emph{after} the \verb#code# marker is called by \texttt{g()}, so here \texttt{args} is `\texttt{B}'.

Finally, function arguments can contain \verb#return# statements just like normal functions.

\begin{code} \begin{verbatim}
> doTwice :: {  num :: double, code, num = args[1], return args(args(num))  }


> doTwice(3, code, return args[1]^2)        | calculate (3^2)^2

81
\end{verbatim} \end{code}

To summarize, Cicada's function arguments are themselves functions.  To make this clearer, we can imagine a syntax that uses curly braces for function calls:

\begin{code} \begin{verbatim}
doTwice{ 3, code, return args[1]^2 }
\end{verbatim} \end{code}

\noindent In fact this syntax is legal!  The only difference with a regular function call is that the argument space will linger as a new object after the function call, wherever that call happened.  (Technically the argument space always persists but is normally hidden).  This way of writing a function makes clear that the arguments are just some function object that's ordinarily invisible, but has an \verb#args# alias inside of the running function.

The args variable is usually defined inline, using parentheses or braces, but it can also be aliased from an existing variable or function using the familiar \verb#@# operator.  For example:

\begin{code} \begin{verbatim}
f :: { ; return args + 1 }
g :: { ; return args*2 }
a := 5
print(g @ f @ a)
\end{verbatim} \end{code}

\noindent This produces a notation similar to the `circle' syntax for function composition.

\index{args@\texttt{args}|)} \index{functions!arguments to|)}




% -----------------  Code substitution  ----------------

\subsubsection{Code substitution}

Why would a function ever want to run its arguments?  One good reason is that running \verb#args()# is an easy way for the caller to modify optional parameters.  To do this, we put all of the function's optional parameters (or aliases to them) in one composite variable, set default values, then run \verb#args()# \emph{inside of that parameters variable} using the code substitution operator `\verb#<<#'.  Here is an example.

\begin{code} \begin{verbatim}
RollDice :: {
    
    numDice :: total :: loopDie :: int
    
    params :: {
        numSides :: int
        isLoaded :: bool    }
    
    code
    
    { numDice } = args
    
    params = { 6, false }
    (params << args)()
    ...
}
\end{verbatim} \end{code}

\noindent If we are happy with the default values of \verb#numSides# and \verb#isLoaded#, so we can leave them out.

\begin{code} \begin{verbatim}
RollDice(5)
\end{verbatim} \end{code}

\noindent The function call only needs a coding section when we want to cheat or roll exotic dice.

\begin{code} \begin{verbatim}
RollDice(5; isLoaded = true)
\end{verbatim} \end{code}

All members of \verb#params# should be explicitly named.  If we wrote:

\begin{code} \begin{verbatim}
    numSides :: int
    isLoaded :: bool
    
    params :: { numSides, isLoaded }
\end{verbatim} \end{code}

\noindent then \verb#args# would find itself in a space with two nameless members.  An alias to \verb#numSides# or \verb#isLoaded# variable is not the same as an alias named \verb#numSides# or \verb#isLoaded#.\\


In general, a code substitution \verb#D << F#, involving composite variables or functions \verb#D# and \verb#F#, returns the data space of \verb#D# along with the code of \verb#F#.  On the other hand, plain old \verb#F# returns both the data space and the code of \verb#F#.  The two basic properties of composite variables and functions are data and code, and the code substitution operator is the tool for separating and recombining these properties.

There are many uses for code substitution beyond optional function arguments.  For example, the terminal script uses it to run the user's commands inside of the workspace variable.  Code substitution can save a lot of typing when working with awkward pathnames.  For example, instead of

\begin{code} \begin{verbatim}
games.backgammon.RollDice.params.numSides = 20
games.backgammon.RollDice.params.isLoaded = true
games.backgammon.RollDice.params.dieColor := "green"
...
\end{verbatim} \end{code}

\noindent we can just write

\begin{code} \begin{verbatim}
(games.backgammon.RollDice.params << {
    
    code
    
    numSides = 20
    isLoaded = true
    dieColor := "green"
    ...
})()
\end{verbatim} \end{code}

\noindent Notice that we wrote all of our commands after a \texttt{code} marker, and ran the substituted code as a function.

A code substitution is quite temporary, lasting only as long as the expression evaluation.  The next time we run \verb#RollDice()# it will be its normal self, except that its \verb#params# variable will have a new member \verb#dieColor#.

The code-number\index{code number operator|(} operator can be used to control which code is passed to the code-substitution operator.  Here is a function that uses either one or two sets of optional parameters, depending on how it is called.

\begin{code} \begin{verbatim}
f :: {
    ...
    
    code
    
    params_1 :: { doMoreStuff := false, ... }
    params_2 :: { otherNum :: int, ... }
    
    (params_1 << args)()
    if params_1.doMoreStuff  then (params_2 << args#2)()
    
    ...
}
\end{verbatim} \end{code}

\noindent When we call this function, our arguments will contain 1, 2 or 3 coding blocks.

\begin{code} \begin{verbatim}
f(2, 5)                                             | don't doMoreStuff
f(2, 5; doMoreStuff = true)                         | doMoreStuff w/ defaults
f(2, 5; doMoreStuff = true; otherNum = 12, ...)     | change defaults
\end{verbatim} \end{code}\index{code number operator|)}





% -----------------  search paths  ----------------

\subsubsection{Search Paths} \index{search paths|(}

A Cicada function has access not only to its own members, but also to members defined at the global level (the workspace).  More generally, the function can access any members along its \emph{search path}, which goes through any object that encloses the function.  We'll show this with some examples:

\begin{code} \begin{verbatim}
allFunctions :: {
    ...
    stringFunctions :: { ... }
    numericFunctions :: {
        ...
        theNumber :: double
        raiseToPower :: { ; theNumber := args[1], return theNumber^power }
}   }
raiseToPowerAlias := @allFunctions.numericFunctions.raiseToPower

allFunctions.numericFunctions.calcLog :: { ; theNumber = args[1], return log(theNumber) }

powerOfThree :: { power := 3 }
\end{verbatim} \end{code}

\noindent Compare the various functions.  The \verb#raiseToPower()# function has a long but straightforward search path, beginning at \verb#raiseToPower#, then passing through \verb#numericFunctions# and \verb#allFunctions# and ending at the workspace variable (blue path, Figure \ref{searchPaths}).  This means that when its code references a member, it looks first in its own space for that member, then if it's not there it backs out to \verb#numericFunctions# and look there; etc. all the way to the workspace if necessary.  If it doesn't find the member by the end of its search path it will crash with a member-not-found error.  This search path is used regardless of whether we called \verb#raiseToPower()# or \verb#raiseToPowerAlias()# -- it's a property of the function, not the member.

On the other hand, \verb#calcLog()#'s search path only touches \verb#calcLog# itself and the workspace variable (the green path in Figure \ref{searchPaths}).  The reason is that \verb#calcLog# was defined straight from the workspace, \emph{not} from the code that defined \verb#allFunctions# or \verb#numericFunctions#.  So \verb#calcLog()# cannot find \verb#theNumber#:  it is a broken function.  It's not that the data is inaccessible, it's that we just need to walk the function to where the data lives.  We should have written:

\begin{code} \begin{verbatim}
allFunctions.numericFunctions.calcLog :: {
    code
    theNumber = args[1]
    return log(allFunctions.numericFunctions.theNumber)   }
\end{verbatim} \end{code}

\noindent Everyone's door is unlocked, but you have to deliberately open the door to go into someone else's data space.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{searchPaths}
\caption{Search paths of various functions from an example in the text.  For simplicity we've named each variable/function box by the member that defined it.  Search paths are shown with heavy arrows:  green arrows for \texttt{calcLog()}; light blue arrows for \texttt{raiseToPower()}; and purple arrows for \texttt{raiseToPower()} function \emph{substituted into} \texttt{powerOfThree()}.  A hypothetical function derived from \texttt{raiseToPower()} and specialized by \texttt{powerOfThree()} (using the inheritance operator) would have each half its code follow its respective original search path (blue and dotted black arrows from the box at right).}
\label{searchPaths}
\end{figure}

The define operator is special in that it always defines the member right in the first variable of the search path.  So \verb#theNumber# will be defined inside \verb#raiseToPower# even if there is another member called \verb#theNumber# further up the search path.

The notion of a search path gives a more accurate picture of code substitution:  that operation just changes the \emph{first step} on the search path of the substituted code.  Suppose we write

\begin{code} \begin{verbatim}
(powerOfThree << allFunctions.numericFunctions.raiseToPower)(2)
\end{verbatim} \end{code}

\noindent Then the search path for the substituted function begins at \verb#powerOfThree# but then passes on to \verb#numericFunctions#, \verb#allFunctions#, and the workspace variable just as before.  This is the purple path in Figure \ref{searchPaths}.  Of course the substitution is temporary, but when the substituted function is run it has a permanent effect on \verb#powerOfThree#:  it creates a member inside of it called \verb#theNumber#.  That member will inherit the spliced search path of the substituted code.

\index{search paths|)}\index{functions|)}







% -----------------  Classes & Inheritance  ----------------


\subsection{Classes and Inheritance}\index{classes|(}

A pair of curly braces can be thought of as a datatype, a composite variable, a function.. or even a class or class object.





% -----------------  Classes  ----------------


\subsubsection{Classes}

A Cicada class, or class instance, is nothing more than a composite variable having both members that are methods (functions).

\begin{code} \begin{verbatim}
myClass :: {
    data :: int
    moreData :: string
    
    init :: {
        code
        { data, moreData } = { 1, "blank" }
    }
    
    otherMethod :: { ... }
}
\end{verbatim} \end{code}

\noindent In a sense, all we have done is point out that functions such as \verb#init()# can be defined inside of composite variables.

The \verb#init()# function can be thought of as a constructor, since it initializes the class data.  It might be more convenient to have that run automatically by taking it out of \verb#init()#:

\begin{code} \begin{verbatim}
myClass :: {
    data :: int
    moreData :: string
    
    { data, moreData } = { 1, "blank" }
    
    otherMethod :: { ... }
}
\end{verbatim} \end{code}

\noindent Now \verb#myClass# and any class instance \verb#myObject :: myClass# begins initialized to \verb${ 1, "blank" }$.  We can even bundle the constructor code together with the member definitions:

\begin{code} \begin{verbatim}
myClass :: {
    data := 1
    moreData := "blank"
    
    otherMethod :: { ... }
}
\end{verbatim} \end{code}

\noindent The constructors run when the object is created, but what if we need to rerun the constructor?  Treating our object as a function, we just write:

\begin{code} \begin{verbatim}
myObject#0()    | code #0 is the constructor
\end{verbatim} \end{code}

\noindent Code number 1 of a function, which is the default function code, begins \emph{after} the first \verb#code# marker or semicolon; therefore the constructor code, which is code number 0, comprises everything \emph{leading up to} that first \verb#code# marker.  In the case of a class object, there is no \verb#code# marker, so the constructor is everything inside of the curly braces.

There is no destructor in Cicada.  In fact there isn't even a direct way to delete an object -- we can only \verb#remove# members leading to an object.  Theoretically, when no more members point to an object, that object will be deleted.  In practice Cicada doesn't do this very well -- we can help it out using its \texttt{springCleaning()} function.\index{classes|)}






% -----------------  Inheritance  ----------------


\subsubsection{Inheritance}\index{inheritance|(}

Cicada also supports a sort of inheritance.  The inheritance operator is a colon `\verb#:#' separating the parent object from the code that specializes it.  For example, to derive a class from \verb#myClass# we could write:

\begin{code} \begin{verbatim}
myDerivedClass :: myClass : {
    newString := "Hello, I am new to this class."
}
\end{verbatim} \end{code}

\noindent \verb#myDerivedClass# has all of the members of \verb#myClass#, plus the new string member.

In this last example, we specialized a predefined parent object with inlined code within braces, using a single inheritance operator.  But one doesn't have to follow this pattern; we can combine class objects and inlined codes in any number and any combination.

\begin{code} \begin{verbatim}
A :: { var1 :: int }
B :: { } : { var2 :: string }
C :: A : B
D :: B : A
E :: { var3 :: int, var4 :: string } : A : { var5 :: char }
F :: C : { remove var1 }
\end{verbatim} \end{code}

\noindent So for example the type of \verb#C# is effectively \verb#{ var1 :: int } : { } : { var2 :: string }#, whereas \verb#D# is \verb#{ } : { var2 :: string } : { var1 :: int }#.  The definition of \verb#F# shows that it is possible for a derived object to have \emph{fewer} members than its parent object.

Importantly, an object's type is sensitive to the order of inheritance.  \verb#C# has a different type than \verb#D#, so \verb#C :: D# or \verb#C = @D# will cause a type-mismatch error.

Cicada allows \emph{existing} objects to be redefined as a different type only if the new type is derived from its original type.  We can always specialize a member's type by adding more inheritance operators \emph{at the end} of the type specification.  All of the following commands will work in order except the last one.

\begin{code} \begin{verbatim}
C :: A : B               | we already did this, but fine
C :: C                   | fine -- C equals A : B
C :: C : B               | OK -- now C will be A : B : B
C :: A : B : B : {}      | OK
C :: A : B : B : {}      | error!
\end{verbatim} \end{code}

\noindent The last line failed only because any two inlined types are presumed different -- Cicada is not in the business of comparing what's inside those braces to see if they match up.

Although types can be specialized, they can never be generalized.  So typing \verb#F :: C# will cause a type-mismatch error.

The same type-matching rules apply to aliases.

\begin{code} \begin{verbatim}
D ::  B : A              | was already defined this way
G :: B : A : { }
D = @G                   | legal
(D =@ *) :: B : A        | legal
G = @D                   | NOT legal!
\end{verbatim} \end{code}

\noindent Aliasing doesn't change a member's type, which explains why we could reassign \verb#D# to a new variable of its original type.

It turns out that the inheritance operator can derive new types for any composite Cicada object:  variables, sets, even functions.  Inheritance applied to sets is best thought of as set concatenation.

\begin{code} \begin{verbatim}
a :: {  Alice, Bob  }
b :: {  Charlie, David  }
c :: a : b
\end{verbatim} \end{code}

\noindent So \texttt{c} contains \texttt{Alice}, \texttt{Bob}, \texttt{Charlie}, \texttt{David}, in that order.

Inheritance of \emph{functions} basically tacks new code at the end of the old (parent) function.  Each sub-code keeps its own original search path (the example of Figure \ref{searchPaths} on page \pageref{searchPaths} shows a situation where these may be different).  Function-inheritance makes most sense when the function does not return a value (i.e. it's a subroutine), because any \verb#return# statement will prevent the new code from running.  The resulting function contains members from both parent functions.

\begin{code} \begin{verbatim}
absval :: {
    sign :: int
    code
    
    sign = 1
    if args[1] < 0  then sign = -1
    args[1] = that*sign
}

sqrt :: {
    code
    return args^0.5
}

modulus_sqrt :: absval : sqrt
\end{verbatim} \end{code}

Here's another way of using the inheritance operator to accomplish the same thing:

\begin{code} \begin{verbatim}
sqrt :: {
    f :: { ; return args[1] }
    code

    return f(args[1])^0.5
}

modulus_sqrt :: sqrt : {
    remove f
    f :: { ; return abs(args[1])  }
}
\end{verbatim} \end{code}

\noindent So the inheritance operator can conjoin different types of objects:  functions, sets, classes, basically any composite object.  To see how this works, think of any non-function as the constructor part of a function (for example, imagine putting a \verb#code# marker at the very end).  Inheritance in Cicada is really a concatenation of code, whether that be constructor code (the commands before the first \verb#code# marker), the first coding block, or any subsequent code blocks.  In Cicada, type is code.  This explains why objects can be specialized but not generalized:  the specialization code tells Cicada how to convent a parent into a child object, but not the reverse.
\index{inheritance|)}



\newpage







% --------------- Customizing the Cicada language --------------

\section{Customizing the Cicada language}

Cicada's language syntax is described in the \verb#cclang.c# source file, specifically in two arrays that are passed to the compiler when Cicada loads.  It follows that, by changing those arrays, we change the syntax of the language.  Or by passing new arrays during runtime, our scripts can repurpose the compiler to run some entirely new language.



\subsection{\texttt{cclang.c}}\index{cclang.c@\verb#cclang.c#|(textbf}

Inside the file \verb#cclang.c# lives an array called \verb#cicadaLanguage[]# which defines basically every symbol we find inside of a script.  Each array element is a \verb#commandTokenType# structure variable that defines one operator in the Cicada language:

\begin{code} \begin{verbatim}
typedef struct {
    const char *cmdString;
    ccInt precedence;
    const char *rtrnTypeString;
    const char *translation;
} commandTokenType;
\end{verbatim} \end{code}

\noindent The first string, \verb#cmdString#, is the operator symbol or name as written in Cicada.  The \verb#precedence# level determines how operators are grouped (see Table \ref{OoO_table} on page \pageref{OoO_table}).  Next comes \verb#rtrnTypeString# which explains to the Cicada compiler what type(s) of data this operator `returns' to the surrounding expression.  The final string, \verb#translation#, either encodes the operator directly as bytecode (Cicada's native language), or else `expands' the operator in terms of other Cicada commands.  Most operators have a direct bytecode translation, indicated by the fact that their \verb#translation# begins with a \verb#inbytecode# marker (which concatenates to the following string as an unprintable character).  The remaining operators lack the \verb#inbytecode# marker, and their \verb#translation# string is just an expression built from previously-defined operators.

To add a new operator into the language, simply add a new entry to the end of the \verb#cicadaLanguage[]# array, and fill in the four fields.



\paragraph{\texttt{cmdString:}}  The command string defines the various operators that Cicada expects to see in the command.  Typically a command string consists of a concatenation of constant operator strings, which serve as signposts for the compiler, placeholders for sub-expressions within the command, and tokens indicating miscellaneous objects like variable names and hardcoded constants.  There must be some distinctive constant string in the first or second position of a command sequence, so that the compiler knows what it's looking at.

Many operators take left-hand and/or right-hand arguments, as indicated by keywords like \verb#type3arg# to the left and/or right of the respective operator string.  For example, the full command string of the define operator is

\begin{code} \begin{verbatim}
type3arg "::" type7arg
\end{verbatim} \end{code}

\noindent The define command requires both a left-hand expression or argument (the member to define) and a right-hand argument, which can be a member name but also a type like \verb#bool#.  The two arguments expect different objects and therefore require a different `type' of expression.  These types are unrelated to variable/member types.  Looking at the comment before the \verb#cicadaLanguage[]# array, we see that a type 3 argument represents a variable or function, and a type 7 argument represents a code-containing expression, as one would expect.  The type specifications allow the compiler to throw type-mismatch errors when expressions don't make sense.

In some cases two different commands will use the same operator string.  For example, compare `\verb#*#' is used as a multiplication operator as well as the void operator, and `\verb#-#' is either subtraction or negation.  This is \emph{only allowed} if one of the operators expects a left-hand argument and the other doesn't, so that the compiler will immediately know which of the two operators it is looking at when it sees the operator string in a script.  For example, when it stumbles upon a `\verb#-#', that symbol will be interpreted as a subtraction if there is an unattached expression just to the left, and a negation otherwise.

More complex definitions like \verb#while ... do# can involve several operators.

\begin{code} \begin{verbatim}
"while" type6arg "do" type1arg
\end{verbatim} \end{code}

\noindent The pattern is always:  operator strings like `\verb#do#' alternating with arguments.  Some complex definitions involve an \verb#optionalargs# keyword:  everything before the keyword is required, but everything afterwards is optional.  For example, the \verb#if# command

\begin{code} \begin{verbatim}
"if" type6arg "then" type1arg optionalargs "else" type1arg
\end{verbatim} \end{code}

\noindent \emph{requires} an \verb#if# and a \verb#then#, but the \verb#else# is optional.

There are 10 allowed argument types:  \verb#type0arg# through \verb#type9arg#.  There are also a few special types.  A \verb#typeXarg# accepts any type of argument, and is used by the \verb#(...)# operator with \emph{no} left-hand argument (i.e. the grouping operator, not a function call) to allow the user to group any sort of expression, even entire commands.  The \verb#commentarg# keyword denotes an block of text to be entirely ignored until the next operator string is encountered (i.e. everything from a comment bar `\verb#|#' to an end-of-line is skipped).  \verb#chararg# and \verb#stringarg# treat the argument as text containing one or several characters respectively.

Finally, there are several special operators that don't have any operator string at all.  If the operator string is simply \verb#int_constant#, then the operator is read when the compiler encounters a number that it deems to be an integer; and the operator whose operator string is \verb#double_constant# corresponds to a floating-point number.  The \verb#variable_name# operator is assumed to apply whenever the compiler encounters a novel word beginning with a letter (which may be followed by underscores and numbers).  In these three cases the number or word should be thought of as an argument, insofar as the bytecode is concerned.

The final class of special operator strings is the adapters, an important element of Cicada scripting that is explained in the next section.  Suffice to say that there is an adapter for each of the 10 argument types, \verb#type0arg_adapter# through \verb#type9arg_adapter#, along with a \verb#noarg_adapter#.



\paragraph{\texttt{precedence:}}  The precedence level determines how operators are bound into expressions.  The high-precedence operators are grouped most tightly to their neighbors, and evaluated before the low-precedence operators.  Thus \verb#A = 2 * B - 2# is grouped:  \verb#A = ( (2*B) - 2)# because of the three gluing operators `\verb#= * -#', multiplication `\verb#*#' has the highest precedence and assignment `\verb#=#' has the lowest precedence.  The precedence level is just an integer, although notice that \verb#cclang.c# predefines a keyword for each precedence level and uses those keywords instead of numbers.

The \verb#cicadaLanguageAssociativity[]# array in \verb#cclang.c# explains how to group operators of the same precedence level, when there are no parentheses to break the tie.  This can be important.  For example, multiplication and division operators have precedence level 11, and the eleventh entry of the associativity array (i.e. \verb#cicadaLanguageAssociativity[10]#) is \verb#l_to_r# signifying left-to-right grouping.  Therefore the expression \verb#8/2/4# groups as \verb#(8/2)/4# which equals 1, as opposed to \verb#8/(2/4)# which equals 16.  On the other hand, assignment works at precedence level 5, which has \verb#r_to_l# or right-to-left grouping.  Therefore \verb#A = B = C = 2# groups as \verb#A = (B = (C = 2))#, so that 2 copies to \verb#C#, then to \verb#B#, then to \verb#A#.  If the grouping were the other way, then each assignment would only rewrite \verb#A#.

The size of the \verb#cicadaLanguageAssociativity[]# array determines the allowed precedence levels.  So by adding an entry to that table we would bump up the maximum allowable operator precedence level to 16.  Anything outside the interval [1, \emph{max\_precedence}] will cause an out-of-range compiler error.



\paragraph{\texttt{rtrnTypeString:}}  Many operators `return' a value to the enclosing expression, and which type(s) of value they are allowed to return is encoded in the return-types string.  For example, the addition operator has the return-types string \verb#"567"#, so its return value can be construed as being of type 5, 6, or 7.  The return types correspond to the argument types from the \verb#cmdString# field (\underline{not} precedence levels), so the expression \verb#A = 2+5# is legal because the assignment operator expects a type-6 right-hand argument, but \verb#2 + 5 = A# is \emph{illegal} because the left-hand argument of the assignment operator should be of type 3.

There is a special \verb#argXtype# return type which is paired with a \verb#typeXarg# argument type.  This is used by the grouping operator \verb#(...)#, causing the type inside the parentheses (its `argument') to be the type returned back to the enclosing expression.  The parentheses only force a grouping, without affecting the type of the enclosed expression.

An entire script must be of type 0 -- Cicada enforces this using adapters (see below).



\paragraph{\texttt{translation:}}  The last field of an operator definition explains how it will be translated into bytecode.  If the bytecode string begins with a \verb#inbytecode# keyword, then the string contains a list of integers which are the bytecode representation of the operator.  For ease of reading, the bytecode translations in \verb#cclang.c# are built from string macros defined in \verb#cicada.h#.  If there is no \verb#inbytecode# keyword, then the string is interpreted as a fragment of Cicada code that will be translated into bytecode using \emph{previously-defined} operators -- so it is best to define those operators last.

The translation strings of bytecode-written operators have strings of numbers separated by spaces in their translation strings, but also some funny letters:  `\verb#a#', `\verb#j#' and `\verb#p#'.  The `\verb#a#' letter stands for an argument that is to be substituted into the bytecode at the given location, and is followed immediately (no space) by a number from 1 to 9 indicating \emph{which} argument.  (Cicada only supports up to 9 arguments in an operator.)  For example, the assignment operator has a bytecode string

\begin{code} \begin{verbatim}
inbytecode "8 1 a1 a2"
\end{verbatim} \end{code}

\noindent meaning that the operation consists of two integers (8 followed by 1), then the first (left-hand) argument, and last the second (right-hand) argument.  \verb#a1# and \verb#a2# will each be replaced by potentially-long bytecode expressions (think \verb#f().a = 5+cos(b)#).  In \verb#cclang.c# the macro \verb#bcArg(x)# produces the \verb#a1# and \verb#a2# strings, so the \verb#translation# string reads

\begin{code} \begin{verbatim}
inbytecode bc_define(equFlags) bcArg(1) bcArg(2)
\end{verbatim} \end{code}

\noindent where \verb#bc_define(equFlags)# produces a define operator \verb#"8"# with equate flags:  \verb#"1"#.

The `\verb#j#' and `\verb#p#' bytecode symbols are used to specify jump offsets (`\verb#j#' -- effectively gotos) and jump positions (`\verb#p#') in the bytecode.  Offsets are the number of code words to jump ahead \emph{from the offset word} (negative offsets jump backwards), and the cicada compiler calculates these as the difference between a jump (\verb#j#) marker and a target position (\verb#p#) marker.  Each position/jump marker is followed immediately by a number 1-9 indicating which position to define/jump to.  For example, the bytecode string of the \verb#if#-\verb#then#-\verb#else# command which potentially takes 3 arguments is:

\begin{code} \begin{verbatim}
inbytecode "3 j1 a1 a2 1 j2 p1 a3 p2"
\end{verbatim} \end{code}

\noindent In \verb#cclang.c# the position markers are produced using \verb#bcPosition()# macros, and the jump operators have dedicated macros taking the jump offsets as arguments, so this same operator definition reads

\begin{code} \begin{verbatim}
inbytecode bc_jump_if_false(1) bcArg(1) bcArg(2)
                    bc_jump_always(2) bcPosition(1) bcArg(3) bcPosition(2)
\end{verbatim} \end{code}

\noindent In this case the first bytecode command -- bytecode operator 3 which is the jump-if-false command -- jumps to the position of the first position marker, so the compiler calculates this offset by taking the difference in the code position between the \verb#j1# command and \verb#p1#, and puts that value in place of the \verb#j1# word.  Likewise, there is an unconditional jump later on to the end (\verb#j2#).  The third argument \verb#a3# may or may not exist because the third argument is in the optional \verb#else# block:  if there is no \verb#else# then \verb#a3# is basically ignored, but the second position marker is still defined.

Many of the adapter operators (explained in the next section) have \verb#anonymousmember# keywords in their bytecode.  These are replaced by unique (and negative) member IDs that are found nowhere else in the script:  the first use of a \verb#anonymousmember# in the bytecode becomes the number -1, the second use represents a -2 in the bytecode, etc.  These are used to define hidden member IDs that won't conflict with the positive IDs of user-defined members.

Scripted operators -- those without \verb#inbytecode# keywords -- work basically the same as bytecoded operators except that the arguments have to be encoded with the special keywords \verb#arg1# through \verb#arg9#.  For example, the \verb#remove# function is defined at the beginning of \verb#cclang.c# in bytecode, and the \verb#[-< ... >]# syntax for removal cites \verb#remove# in its scripted translation:

\begin{code} \begin{verbatim}
"remove " arg1 "[<" arg2 "," arg3 ">]"
\end{verbatim} \end{code}

\noindent So the command \verb#arr[-<2,3>]# is first translated into \verb$remove arr[<2,3>]$, then into bytecode.

Some operators (usually comments) have no effect on the bytecode whatsoever, and for those we give neither bytecode nor a script translation but instead write \verb#removedexpression# for their translation string.  The \verb#|* ... *|# comment block uses this keyword, as does the line-continuation operator \verb#&# which ignores everything to the end of the line.  Oddly enough the single-line comment \verb#| ...# doesn't use this keyword, and the reason is that it always separates two sentence-level commands -- so in terms of bytecode it works a lot like a comma or end-of-line. \index{cclang.c@\verb#cclang.c#|)}





% --------------- Cicada bytecode --------------

\subsection{Cicada bytecode}

Occasionally, we might want to extend the Cicada language in a way that can't be scripted, in which case we have to define our new command directly in Cicada's native `bytecode', using \verb#cicada.h# as a dictionary to the command words.  Scripts run much faster from bytecode than they ever could by reading their original text, but it should be emphasized that Cicada's bytecode is \emph{different from} (and much slower than) raw machine code.  One significant difference is that Cicada's bytecode has a recursive structure, composed of expressions and sub-expressions, just like Cicada script itself.  In fact, there is pretty much a one-to-one correspondence between the symbols (operators) we write in Cicada and bytecode commands, except that the bytecode commands are in a different order.

For example, when we type the following command into the command prompt:

\begin{code} \begin{verbatim}
> area = 3.14 * R^2
\end{verbatim} \end{code}

\noindent Cicada's compiler produces bytecode output that looks roughly like:

\begin{code} \begin{verbatim}
equate [ <area> , product_of ( 3.14, raise_to_power ( <R> , 2 ) ) ]
\end{verbatim} \end{code}

\noindent where we've bracketed the arguments of each bytecode operator.  These are just the arguments of each operator in the script, but the compiler has made two changes.  1) Each operator's arguments \emph{follow} the actual operator command:  for example the equate operator is followed by two immediate arguments which correspond to the expressions to the left and right of the equate symbol in the script.  2) The operators are reordered, in ascending precedence when parentheses don't force otherwise.  The equate is done \emph{last}, so it becomes the \emph{outermost} function in the bytecode.  The trick is to think of every operator as a function in bytecode, and write the function command first followed by its arguments.

There's actually a way we can see bytecode from the command prompt:  by using the slightly anachronistic \verb#disassemble()#\index{disassemble@\texttt{disassemble()}} function (dating from before error messages).

\begin{code} \begin{verbatim}
> bytecodeStr := compile("area = 3.14 * R^2")


> disassemble(bytecodeStr)

equ ( sm $area , mul ( 3.14 , pow ( sm $R , 2 ) ) )
\end{verbatim} \end{code}

\noindent Using this tool we find out that there's a `search-for-member' (\verb#sm#) operator before each member identifier.  The member identifier is simply an integer ID number:  positive ID numbers for user-defined members (counting upwards from 1), and negative ID numbers (counting downwards from -1) for so-called hidden members which the compiler adds to the bytecode.  The `disassembly' doesn't show it but there's also a `constant-floating-point' operator just before the 3.14 constant.  The raw bytecode will look something like:

\begin{code} \begin{verbatim}
> bytecd :: [] int

> bytecd[] =! compile("area = 3.14 * R^2")

> bytecd

{ 8, 1, 10, 309, 29, 55, 1374389535, 1074339512, 31, 10, 310, 54, 2, 0 }
\end{verbatim} \end{code}

\noindent where each bytecode command is now just a number which we can look up in \verb#cicada.h#.  The two abstruse numbers are the bytes of 3.14 split across two integers.  The actual output varies based on machine and also on what has been run beforehand (which determines which member ID numbers are assigned).   Every script ends with a null word, telling the interpreter to either fall back to the enclosing function or else exit the program.



\paragraph{Pathnames} \index{pathnames!in bytecode|(}

Cicada pathnames consist of a sequence of steps starting from some variable.  For example the path 

\begin{code} \begin{verbatim}
myVar.array[5].x
\end{verbatim} \end{code}

\noindent takes 3 steps:  to \verb#array#, to the fifth element, and finally to \verb#x#.  In bytecode the final step is the \emph{outermost} operator, so the entire path looks like

\begin{code} \begin{verbatim}
step_to_member( step_to_index( step_to_member( "array", search_member "myVar" ), 5 ), "x" )
\end{verbatim} \end{code}

\noindent (For speed reasons the `step-to-member' operator takes the member-to-step-to as its first argument, which is backwards from the other step operators.)  Notice that step-to-member continues a path, whereas search-member \emph{begins} a path and so takes one fewer arguments.\index{pathnames!in bytecode|)}




\paragraph{Inlined constants}\index{constants!in bytecode|(}

Each of the four types of inlined constants---Booleans, characters, integers, and floating-point numbers---along with strings has its own unique bytecode operator.  The raw data of the constant follows in subsequent bytecode words (integers).  The data for large constants -- floating-point numbers and many strings -- takes up several bytecode words.

String constants in bytecode use the `Pascal' string convention rather than the C format:  the constant-string operator is the first bytecode word, followed by the \emph{character-length} of the string (also 1 bytecode word), followed by the raw string data ($N$/\verb#size(int)# words rounded up).  There is no terminating character.\index{constants!in bytecode|)}



\paragraph{Flow control commands}\index{flow control!in bytecode|(}

The four flow-control commands in Cicada---\verb#if#, \verb#for#, \verb#while# and \verb#do#---are all higher-order commands that the compiler expands into expressions involving `goto's\index{goto, in bytecode|(}.  Cicada bytecode sports three `goto's:  an unconditional jump, and jump-if-true and and jump-if-false operators.  Each goto sequence begins with its bytecode command word followed by a jump offset (1 word).  The jump offset is the number of bytecode words to jump ahead \emph{from the jump offset}, which is negative if we want to jump backwards.  The jump must be take us to the \emph{start of a command} -- otherwise \verb#transform()# throws an error.  In the case of the two conditional gotos, there is a final bytecode expression following the jump offset which is the condition on which to jump.

The most complicated flow-control command is the \verb#for# statement, which basically consists of a \verb#while# along with an assignment (to initialize the counter) and a counter-increment command at the end of the loop.  Notice that if we define a variable inside the \verb#for# loop, as in \verb#for (j::int) in <1, 5>#), then Cicada will plunk the whole expression \verb#j::int# into both the initialization and the increment command, which can slow down loops considerably.\index{flow control!in bytecode|)}\index{goto, in bytecode|)}



% --------------- define flags  --------------


\subsubsection{\texttt{define} flags} \index{define, flags|(textbf}

Member definition (\verb#::#), assignment (\verb#=#), and aliasing (\verb#=@#) are all done by different flavors of the \emph{define operator}.  What makes them different is their `flags':  a set of binary properties such as:  does this operator define new members? does it copy data? etc.  In bytecode, all 8 flags are stored in a single word immediately following the define-operator bytecode word, just before the left- and right-hand arguments to the operator.  This section is devoted to that single flags bytecode word.

To calculate a flags word for a set of flags, we treat each flag as a binary digit and read out the number in decimal.  For example, the define operator has flags 1, 2, 3 and 5 set, so its flags bytecode word is

\begin{align*}
flag &= (1 << 1 = 2) + (1 << 2 = 4) + (1 << 3 = 8) + (1 << 5 = 32)\\
&= 46
\end{align*}

\noindent (where \verb#<<# denotes a bit-shift operator).  Table \ref{defineFlagsTable} on page \pageref{defineFlagsTable} summarizes the flags words for each Cicada operator.  Clearly there are many possible operators that are not being used in Cicada.\\


\paragraph{Flag 0 -- equate:}  copies data from the source variable into the destination variable.  This is used by both the assignment \verb#=# and define-equate \verb#:=# operators, but \emph{not} the aliasing operators.\\


\paragraph{Flag 1 -- update-members:}  causes the destination member to be updated to the type of either the source \emph{variable} (by default), or if the source variable is void then to the type of the source member.  For example, suppose we write:

\begin{code} \begin{verbatim}
a :: *, b := 5
a = @b

c :: a
\end{verbatim} \end{code}

\noindent Member \verb#a# has no type, but the variable it points to is an integer.  Thus the member named `\verb#c#' will be defined and allocate storage for an integer, because the define operator sets the update-member flag.\\


\paragraph{Flag 2 -- add-members:}  creates the looked-for member if it doesn't already exist inside the current-running function.  Set by all define operators, even \verb#:: @# which doesn't assign a type to the new member but will create it.\\


\paragraph{Flag 3 -- new-target:}  does two things.  1) Creates a new destination \emph{variable} if none existed already (i.e. if the destination member was void), but it will not overwrite an existing variable.  2) This flag also updates (specializes) the type of the destination variable, regardless of whether or not it had just created that variable.  The new type is the type of the source member or source variable, whichever is more restrictive.  Since a member can only point to an as-or-more-restrictively typed variable, this means that the new type will be that of the source variable unless there is none (the source member points into the void), in which case it's the type specification of the source member.

The member-define operator (\verb#*::#) sets the update-members flag, but not the new-target flag, so it operates only on members.  On the other hand, the variable-define operator (\verb#@::#) has its new-target flag set but the update-members flag clear, so it will specialize variable but not member types.  It can however create new members since it sets the add-members flag.  Plain old define (\verb#::#) sets all three flags.\\


\paragraph{Flag 4 -- relink-target:}  instructs Cicada to make the destination member an \emph{alias} of the source variable.  This flag is set by the equate-at and define-equate-at operators.  The left-hand argument must be an entire variable, not certain indices of an array (i.e. \verb#a[].b = @c# is legal but \verb#a[<2, 3>] = @c# is not).

In a sense, relink-target is the third of three pillars of the def-equate flags.  Whereas post-equate copies data, and update-members and new-target copy code, the relink-target flag copies the target \emph{reference} of the source member.\\


\paragraph{Flag 5 -- run-constructor:}  \index{constructor!flag in bytecode|(}causes the constructor of the destination variable to run after the variable has been created/had its type updated, but before any data has been copied from the source variable if the equate flag was set.  The constructor is the part of a script before the first \verb#code# marker or semicolon.  If the variable has several concatenated codes, the constructors of each code are run in order from first code to last.  Primitive variables have no code, so they are unaffected by this flag.

The constructor-run is the 2nd-to-last operation performed by the def-equate operator, with the actual equate being the last.  This is why we are able to copy composite variables in one step:

\begin{code} \begin{verbatim}
comp1 :: { ... }
comp2 := comp1
\end{verbatim} \end{code}

\noindent The new variable \verb#comp2# is defined to have the same code as \verb#comp1#, so when its constructor runs it will grow the same set of members that \verb#comp1# has.  Then the final equate should not have any problems, as long as we didn't modify \verb#comp1# after defining it.\index{constructor!flag in bytecode|)}\\


\paragraph{Flag 6 -- hidden-member:} \index{members!hidden|(} sets the `hidden' flag of any newly-defined member.  Hidden members, which are created by bytecode adapters, can only be accessed by name (which is usually unwriteable).  Array-index operators, assignment operations (\verb#=#), comparisons (\verb#==#), and built-in functions like \verb#print()# all skip over hidden members.\index{members!hidden|)}\\


\paragraph{Flag 7 -- unjammable:} makes a member unjammable, i.e. unable to prevent another member from being resized.  Ordinarily, if two members alias overlapping indices of an array, neither one can resize the array since doing so would also affect the other member.  However, if one member is defined as unjammable, then it cannot jam the other member:  the second member \emph{can} be resized and the first member, which now has the wrong number of indices, becomes `unjammed' -- i.e., inoperable.  An unjammed member has to be re-aliased before it can be used again without causing a void-member error.\index{define, flags|)}\\



% --------------- Functions, revisited --------------

\subsubsection{Adapters}\index{adapters|(}

There's something missing in our scripts, and the easiest place to see this is in an ordinary function call:

\begin{code} \begin{verbatim}
f(2, pi, { 1, int })
\end{verbatim} \end{code}

\noindent Realizing that commas are just ends-of-lines, we could write this

\begin{code} \begin{verbatim}
f(
    2
    pi
    { 1, int }
)
\end{verbatim} \end{code}

\noindent which shows that \verb#2#, \verb#pi#, and \verb#{ 1, int }# are somehow all valid commands.  How can this be?

Let's draw an analogy.  Back in the cave man days, there were probably a lot of sentences like

\begin{code} \begin{verbatim}
rock
\end{verbatim} \end{code}

\noindent which in modern English would be

\begin{code} \begin{verbatim}
[That which I want to draw your attention to] [is] the rock.
\end{verbatim} \end{code}

\noindent In other words, if a sentence only contains an object, the cave man's brain fills it out by adding some stock subject and verb.  Cicada works exactly the same way:  the stock subjects and verbs to use in different situations are the so-called adapters defined in \verb#cclang.c#.  Each adapter allows the compiler to convert some bare expression (e.g. the object of a sentence) to another type (a full sentence) by throwing in a few extra bytecode words.

When the user enters the command `\verb#2#', the compiler rolls its eyes and reaches for the type-mismatch error button, because it a complete command is a type 1 expression whereas an \verb#int_constant# can only be construed as types 5, 6, or 7 based on its return-types string in the \verb#cicadaLanguage[]# array.  But then Cicada notices an adapter that works on type-6 objects (named \verb#type6arg_adapter# in \verb#cclang.c#), and moreover that adapter's return-types string includes a ``1" which is what we want.  So the adapter adds its code and the error never happens.  Here is the adapter's bytecode:

\begin{code} \begin{verbatim}
inbytecode bc_define(deqxFlags) bc(search_member) anonymousmember bcArg(1)
\end{verbatim} \end{code}

\noindent The expression to adapt is considered the argument and goes in place of \verb#bcArg(1)#.  It's clear that this adapter turns our expression into something looking like

\begin{code} \begin{verbatim}
var1 := 2
\end{verbatim} \end{code}

\noindent except that the define-equate operator has slightly different define flags (\verb#deqxFlags# instead of \verb#deqFlags#).

Other types of objects use different adapters when they appear by themselves.  Variables use an adapter that creates an alias:  for example the expression `\verb#pi#' becomes something like

\begin{code} \begin{verbatim}
var2 := @pi
\end{verbatim} \end{code}

\noindent though again using slightly different flags from a normal aliasing operator.  Finally, type-objects are turned into full commands using a third adapter that adds a define-like operator.  Thus `\verb#{ 1, int }#' turns into a modified version of

\begin{code} \begin{verbatim}
var3 :: { 1, int }
\end{verbatim} \end{code}

\noindent or more precisely:

\begin{code} \begin{verbatim}
var3 :: { var3a := 1, var3b :: int }
\end{verbatim} \end{code}

The \verb#anonymousmember# keyword produces a unique member `name' that is inexpressible by the user.  (Names become ID numbers in the bytecode:  user-typed names become positive ID numbers, whereas anonymous members get assigned sequential negative ID numbers as they are encountered.  The namespace consists of both the name-ID list and the negative ID counter.)  Thus \verb#var1#, \verb#var2#, etc. in the last paragraph don't really don't have those names or any other, so function \verb#f()# will access those members using the bracket operators (\verb#args[1]#, \verb#args[2]#, etc.).  It's technically possible to hand-write bytecode that uses negative IDs to access anonymous members, but that's a heroic measure that's probably only useful for anonymous members that are also `hidden'.

Hidden members are invisible to the array-index operators.  In bytecode-speak, these are produced using define operators whose hidden-member flags are set (flag 6 in Table \ref{defineFlagsTable} on page \pageref{defineFlagsTable}).  A typical workspace has a sprinkle of hidden members, notably around function calls where they briefly shine as \verb#args# while the function is running, then live almost invisibly until the function is rerun.  (Unless the function was called using braces, in which case the \verb#args# variable is not hidden).  The rarest bird of all is the hidden-define-minus-constructor operator (\verb#def-c**# in the table), living exclusively in \verb#trap()#\index{trap@\texttt{trap()}} function calls, where it defines an \verb#args# variable \emph{without running its constructor} so that \verb#trap()# can do so in a controlled way.

The other define-operator flag used by (all) adapters is the unjammable flag (flag 7; see Table \ref{defineFlagsTable} on page \pageref{defineFlagsTable}), which prevents members from jamming arrays.  Consider the function call \verb#f(myArray[<2, 4>])#, which produces a hidden \verb$args$ variable consisting of \verb${ myArray[<2, 4>] }$, and which compiles to something like \verb${ anon1 := @myArray[<2, 4>] }$.  Ordinarily \verb$anon1[]$ would jam \verb$myArray[]$, and the actual array could not be resized from either member since doing so would also force a resize of the other.  But in this case \verb$anon1$ was defined as unjammable---as in unjam-able (can be unjammed)---so future array resizes like \verb#myArray[+3]# are allowed because \verb$anon1$ will de-alias rather than cause a jammed-member error.  That's OK because the alias will be restored the next time that same function call happens, since the argument constructor will be rerun.  (However there can be a problem in other contexts where the constructor is not rerun each time it is used, for example in sets containing aliases to array subsets.  Use hard-coded aliases for these cases.)  As an aside, these adapters also clear their update-member-type flags (flag 1), so that their anonymous members can be re-assigned to variables of different type (in case, for example, between two iterations of the command \verb#f(a)# member `\verb#a#' gets removed and redefined).

One last type of adapter called \verb#noarg_adapter# replaces missing expressions altogether.  These adapters are necessary to allow blank scripts, or situations like two consecutive end-of-lines (command-conjoining operators) which lack a command between them to conjoin.  Another no-argument adapter allows a script to contain a \verb#return# command without a variable.  The final set of no-argument adapters in \verb#cclang.c# is used to convert a sentences-type expression (type 1) to a script expression (type 0), by adding a null bytecode word at the end.\index{adapters|)}\\


 



\subsection{Custom-compiling within a script}

For a variety of reasons, we might occasionally want to run a script manually without using the \verb#run()# function.  This involves two steps.  The first step is to produce bytecode, easily done using the \verb#compile()# function.  Second, the \verb#transform()# function gives bytecode a perch on a function's internal code registry.  Here is a simple example:

\begin{code} \begin{verbatim}
myBytecode := compile("myMessage := \"Hello, world!\"; print(myMessage)")

newFunction :: transform(myBytecode)

newFunction()
\end{verbatim} \end{code}

Another \verb#compile()#-\verb#transform()# situation arises when we run a script that uses a \emph{different syntax} from the default Cicada language.  For example, our script might want to process commands typed by the user, that are in a completely different format from the Cicada language.  In that case we won't want to change \verb#cclang.c# since doing so would break Cicada's built-in scripts.  Instead we must use the \verb#newCompiler()#\index{newCompiler@\texttt{newCompiler()}|(} function to process the user's input using a different syntax from that of our own scripts.  Here is an example, relying on language-constant definitions in \verb#defs.cicada#.

\begin{code} \begin{verbatim}
newLanguage :: [] compiledCommandType
newLanguage[] = {
    { cat("add  ", type1arg, "to", type1arg), 1, "0",
            cat(inbytecode, "8 173 10", anonymousmember, "27 a1 a2 0") },
    { cat("negative", type1arg), 2, "1", cat(inbytecode, "29 54 -1 a1") },
    { int_constant, 0, "1", cat(inbytecode, "54 a1") },
    { double_constant, 0, "1", cat(inbytecode, "55 a1") }
}
newLanguageAssociativity :: [] int
newLanguageAssociativity[] = { l_to_r, r_to_l }
newCompilerID := newCompiler(newLanguage, newLanguageAssociativity)

myBytecode := compile(input("Give me math:  "); compilerID = newCompilerID)
doMath :: transform(myBytecode)

doMath()
printl("The answer is:  ", doMath[1])
\end{verbatim} \end{code}

\noindent Running this script:

\begin{code} \begin{verbatim}
Give me math:  add negative 1 to 3.14
The answer is:  2.14
\end{verbatim} \end{code}

\noindent Notice how the two array arguments to \verb#newCompiler()# are almost exactly the same as the two arrays that specify the language in \verb#cclang.c#, the main difference just being the use of \verb#cat()# to concatenate strings.  For consistency, all of the constants used in the C file (such as \verb#int_constant# and \verb#inbytecode#) are also defined in the scripting environment.  Also, make sure to define both arguments as arrays -- \verb#newCompiler()# will not understand anything inside of curly braces.  As always, any script must have an overall type of 0.  In this primitive example the only possible valid script is an \verb#add# command.

Functions produced by different compilers live in different namespaces, because each compiler keeps its own running tally of all member names and anonymous members it has encountered.  But the use of separate compilers does \emph{not} prevent collisions of member names between these functions:  if anything switching compilers makes collisions more likely.  (Any new compiler member will assign member IDs starting from 1 and counting upwards, and that ID is the only thing Cicada sees when the function runs.)  To avoid problems, manually isolate the new bytecode's search path from the workspace using \verb#transform()#.\index{newCompiler@\texttt{newCompiler()}|)}


\newpage


% --------------- REFERENCE --------------

\section{Reference}



% --------------- Operators --------------

\subsection{Operators and reserved words}  \index{reserved\_words|(} \index{operators!list of|(}

\small

\noindent
\begin{description}
\item{\verb#,# or line break} :  demarcate commands
\item{\verb#( ... )#} :  group terms in an expression
\item{\verb#X#$\sim$} :  ignore output of expression \verb#X#
\item{\verb#|#} :  single-line comment
\item{\verb#|* ... *|#} :  multiple-line comment
\item{\verb#&#} :  continue command on next line\\
\end{description}

\noindent
Numeric operators:
\begin{description}
\item{\verb#x + y#} :  addition
\item{\verb#x - y#} :  subtraction
\item{\verb#x * y#} :  multiplication
\item{\verb#x / y#} :  division
\item{\verb#x ^ y#} :  raise to a power
\item{\verb#i mod j#} :  modulo (integer only)\index{mod@\texttt{mod}}\\
\end{description}

\noindent
Boolean operators:
\begin{description}
\item{\verb#A == B#} :  if equal
\item{\verb#A ==@ B#} :  if same reference
\item{\verb#A /= B#} :  if not equal
\item{\verb#A /=@ B#} :  if different reference
\item{\verb#A >= B#} :  if greater than or equal to
\item{\verb#A > B#} :  if greater than
\item{\verb#A <= B#} :  if less than or equal to
\item{\verb#A < B#} :  if less than
\item{\verb#A and B#} :  if A and B\index{and@\texttt{and}|textbf} (both arguments are always evaluated)
\item{\verb#A or B#} :  if A or B or both\index{or@\texttt{or}|textbf} (both arguments are always evaluated)
\item{\verb#A xor B#} :  if A or B, but not both\index{xor@\texttt{xor}|textbf}
\item{\verb#not A#} :  true only if A is false\index{not@\texttt{not}|textbf}\\
\end{description}

\noindent
Member/array/list operators:\index{members|(}\index{arrays|(}
\begin{description}
\item{\verb#A.B#} :  step from A into member B
\item{\verb#[ A ]#} :  step into array index A
\item{\verb#[< A, B >]#} :  step into array indices A through B
\item{\verb#[^ N ]#} :  resize array to given size N, step into all indices 1-N
\item{\verb#[+ A ]#} :  insert index
\item{\verb#[+< A, B >]#} :  insert indices
\item{\verb#[]#} :  step to all indices; can resize before \verb#=# or \verb#=!#\index{arrays|)}
\item{\verb#remove A#  or  \verb#[-< A, B >]#} :  remove member or indices A through B\\\index{remove@\texttt{remove}}
\end{description}\index{members|)}

\noindent
Define/equate operators:
\begin{description}
\item{\verb#A :: B#} :  define A (member with a variable) with the type of the variable that B points to
\item{\verb#A = B#  or  \verb#A <- B#} :  copy data from B to A
\item{\verb#A := B#} :  define A to type B, copy data from B to A
\item{\verb#A =@ B#  or  \verb#A <- @ B#} :  make A an alias of B\index{aliases}
\item{\verb#A :=@ B#} :  define A and make it an alias of B\index{aliases}
\item{\verb#A @:: B#} :  define A to be of type B (variable type only)
\item{\verb#A *:: B#} :  define A to be of type B (member type only)
\item{\verb#A =! B#  or  \verb#A <- ! B#} :  copy data from B to A; even between dissimilar data types\\
\end{description}

\noindent
Predefined variables:
\begin{description}
\item{\verb#this#} :  the function currently executing\index{this@\texttt{this}}
\item{\verb#parent#  or  \verb#\#} :  the next function up the search path\index{this@\texttt{this}}
\item{\verb#that#} :  variable on the left side of an equate\index{that@\texttt{that}}
\item{\verb#args#} :  the argument variable to the function currently executing\index{args@\texttt{args}}
\item{\verb#top#} :  within array brackets, the number of indices\index{args@\texttt{args}}
\item{\verb#nothing#  or  \verb#*#} :  the void\index{nothing@\texttt{nothing}}\\
\end{description}

\noindent
Program flow:
\begin{description}
\item{\verb#if A then ..., else if B then ..., else ...#} :  do if A, B, etc. are true
\item{\verb#while A do ...,#} :  do as long as A is true
\item{\verb#loop ... until A#} :  do until A is true
\item{\verb#for I in < A, B >  ...#} :  do for a defined number of times
\item{\verb#backfor I in < A, B >  ...#} :  same as \verb$for$, except starts at B and counts backwards to A
\item{\verb#A( ... )#} :  call A as a function with given arguments
\item{\verb#code#} or \verb#;# :  begin a new code block\index{code@\texttt{code} marker}
\item{\verb#return A#  or  \verb#return#} :  exit function with return variable A (if specified)\index{return@\texttt{return}}
\item{\verb#exit#} :  exit Cicada\index{exit@\texttt{exit}}\\
\end{description}

\noindent
Data types:
\begin{description}
\item{\verb#bool#} :  Boolean
\item{\verb#char#} :  character
\item{\verb#int#} :  integer
\item{\verb#double#} :  floating point
\item{\verb#string#} :  string of characters
\item{\verb#'...'#} :  inlined character constant (one character only)
\item{\verb#"..."#} :  inlined string containing given characters
\item{\verb#[ N ]#} or \verb#[ ]# :  array
\item{\verb#[[ ]]#} :  list
\item{\verb#{ ... }#} :  inlined function, set, class or data type
\item{\verb#A : B#} :  an inherited type specialized by B from parent type A
\item{\verb#A << B#} :  the code/type of B substituted into the variable space of A
\item{\verb$A # B$} :  the Bth code block of variable A\\
\end{description}

\index{reserved\_words|)} \index{operators!list of|)}

\normalsize






% --------------- Bytecode operators --------------

\subsection{Bytecode operators}  \index{bytecode|(}

Each entry in the following list consists of:  a bytecode command word (which is a number), a name in brackets, and then the arguments for that operator separated by commas.  Arguments in plain text take up a defined number of bytecode words.  Unless otherwise indicated, a fixed-width argument is one word long and should be read as a signed integer.  Arguments in italics are themselves bytecode expressions, which can span arbitrary numbers of bytecode words.\\



\begin{description}
\item{0  [ null ]} :  marks the end of a code block

\item{1  [ jump ], offset}\index{goto, in bytecode|(} : jumps the program counter to the position of the offset word plus \emph{offset} bytecode words
\item{2  [ jump-if-true ], offset, \emph{condition}} : jumps the program counter to the position of the offset word plus \emph{offset} bytecode words, if the conditional expression evaluates to true
\item{3  [ jump-if-false ], offset, \emph{condition}} : moves the program counter to the position of the offset word plus offset byetcode words, if \emph{condition} is false\index{goto, in bytecode|)}

\item{4  [ code ]} : delineates the boundary between two code blocks
\item{5  [ return ], \emph{return\_variable}} :  exits the function and returns the specified variable
\item{6  [ user function ], \emph{function\_variable}, \emph{args\_variable}} : runs the given user function with the specified arguments, and returns the return variable (if any)
\item{7  [ C function ], \emph{function\_ID}, \emph{args\_variable}} : runs either a built-in or user-defined C function with the given ID and arguments, and returns an integer

\item{8  [ define ], flags, \emph{LH\_var}, \emph{RH\_var}} : applies the define/equate/equate-at command specified by the flags from the source \emph{RH\_var} to the target \emph{LH\_var}
\item{9  [ forced\_equate ], \emph{LH\_var}, \emph{RH\_var}} : copies the raw data from the source \emph{RH\_var} into the target \emph{LH\_var} if their byte-sizes match

\item{10  [ search member ], ID} : searches backwards from the current function for the member having the given ID
\item{11  [ step to member ], ID, \emph{starting\_variable}} : steps to the member with the given ID from the given starting variable
\item{12  [ step to index ], \emph{starting\_variable}, \emph{index}} : steps into the given index of the starting variable
\item{13  [ step to indices ], \emph{starting\_variable}, \emph{low\_index}, \emph{high\_index}} : steps simultaneously into the given range of indices from the starting variable
\item{14  [ step to all indices ], \emph{starting\_variable}} : steps into all indices of the starting variable
\item{15  [ resize ], \emph{variable}, \emph{top\_index}} : resizes the variable's member to have the given number of indices, and steps into these indices
\item{16  [ insert index ], \emph{variable}, \emph{new\_index}} : adds a new index to \emph{variable} at position \emph{new\_index}
\item{17  [ insert indices ], \emph{variable}, \emph{new\_low\_index}, \emph{new\_high\_index}} : adds the new range of indices to \emph{variable} beginning at \emph{low\_index}
\item{18  [ remove ], \emph{member}} : deletes the member or part of the member that was stepped into

\item{19  [ if equal ], \emph{expr1}, \emph{expr2}} : returns true if the two expressions' data are equal; false otherwise
\item{20  [ if not equal ], \emph{expr1}, \emph{expr2}} : returns false if the two expressions' data are equal and true otherwise
\item{21  [ if greater-than ], \emph{num1}, \emph{num2}} : returns true if and only if \emph{num1} is greater than \emph{num2}
\item{22  [ if greater-than-or-equal ], \emph{num1}, \emph{num2}} : returns true if and only if \emph{num1} is greater than or equal to \emph{num2}
\item{23  [ if less-than ], \emph{num1}, \emph{num2}} : returns true if and only if \emph{num1} is less than \emph{num2}
\item{24  [ if less-than-or-equal ], \emph{num1}, \emph{num2}} : returns true if and only if \emph{num1} is less than or equal to \emph{num2}
\item{25  [ if same reference ], \emph{expr1}, \emph{expr2}} : returns true if the two members point to the same data; false otherwise
\item{26  [ if different reference ], \emph{expr1}, \emph{expr2}} : returns false if the two members point to the same data and true otherwise

\item{27  [ add ], \emph{num1}, \emph{num2}} : returns the sum of its numeric arguments
\item{28  [ subtract ], \emph{num1}, \emph{num2}} : returns \emph{num1} minus \emph{num2}
\item{29  [ multiply ], \emph{num1}, \emph{num2}} : returns the product of its numeric arguments
\item{30  [ divide ], \emph{num1}, \emph{num2}} : returns \emph{num1} divided by \emph{num2}
\item{31  [ power ], \emph{num1}, \emph{num2}} : returns \emph{num1} raised to the power \emph{num2}
\item{32  [ modulo ], \emph{num1}, \emph{num2}} : returns the remainder of \emph{num1} divided by \emph{num2} after they have been truncated to integers

\item{33  [ not ], \emph{condition}} : returns true if the condition is false and false if the condition is true
\item{34  [ and ], \emph{condition1}, \emph{condition2}} : returns true if and only if both conditions are true (both are always evaluated)
\item{35  [ or ], \emph{condition1}, \emph{condition2}} : returns true if and only if one or both of the conditions are true (both are always evaluated)
\item{36  [ xor ], \emph{condition1}, \emph{condition2}} : returns true if and only if one, but not both, conditions are true

\item{37  [  code number ], \emph{code number},  \emph{var}} : causes an enclosing function call to execute the given \emph{code number} of \emph{var}
\item{38  [ substitute code ], \emph{code},  \emph{var}} : returns \emph{var} but paired with the given \emph{code} instead of its native code
\item{39  [ append code ],  \emph{f1}, \emph{f2}} : returns \emph{f1} but with the concatenated code \emph{f1} + \emph{f2} instead of its native code

\item{40  [ args ]} : returns the \verb#args# variable for the current function
\item{41  [ this ]} : returns the function variable that is currently running
\item{42  [ that ]} : returns the variable on the left-hand side of the equate statement
\item{43  [ parent ]} : returns the parent of the currently-running function
\item{44  [ top ]} : returns the highest index of the enclosing array brackets
\item{45  [ nothing ]} : returns no variable

\item{46  [ array ],  \emph{num\_indices}, \emph{type}} : an array of \emph{num\_indices} elements of \emph{type}
\item{47  [ list ],  \emph{type}} : an empty list of \emph{type}
\item{48  [ bool ]} : Boolean data type\index{bool@\texttt{bool}}
\item{49  [ char ]} : character data type\index{char@\texttt{char}}
\item{50  [ int ]} : integer data type\index{int@\texttt{int}}
\item{51  [ double ]} : floating-point data type\index{double@\texttt{double}}

\item{52  [ constant bool ], num} : returns the Boolean stored in \emph{num} (one bytecode word)
\item{53  [ constant char ], num} : returns the character stored in \emph{num} (one bytecode word)
\item{54  [ constant int ], num} : returns the integer stored in \emph{num} (one bytecode word)
\item{55  [ constant double ], num} : returns the floating-point number stored in \emph{num}, which occupies \verb#sizeof(ccFloat)# / \verb#sizeof(ccInt)# bytecode words
\item{56  [ constant string ], characters\_num, string\_data} : returns an inlined string having the given number of characters.  The string\_data field occupies one bytecode word for every four characters.
\item{57  [ code block ]} : returns the inlined code beginning with the next bytecode sentence and ending with a 0 bytecode word


\end{description}
\index{bytecode|)}




% --------------- Define operators and flags --------------

\subsubsection{Define operator flags}\index{define, flags|(} \index{operators!define|(}


Table \ref{defineFlagsTable} lists the common define/equate/equate-at operators and their associated bytecode flag words (the bytecode word following the define operator).  Each flag word encodes the various binary properties of a define operator:  it is the decimal representation of the columns in the table treated as binary digits (where a checkmark equals 1).  The flags are:  equate (0), update-members (1), add-members (2), new-target (3), relink-target (4), run-constructor (5), hidden (6), and unjammable (7).  The last six operators that have asterisks in their names cannot be written into a script, but are generated automatically by the compiler in various situations.\\

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
{\bf name} & {\bf abbr} & {\bf symbol} & {\bf flags} & {\bf 7} & {\bf 6} & {\bf 5} & {\bf 4} & {\bf 3} & {\bf 2} & {\bf 1} & {\bf 0}\\
\hline \hline
define & def & \verb#::# & 46 & & & \checkmark & & \checkmark & \checkmark & \checkmark &\\
member-define & mdf & \verb#*::# & 6 & & & & & & \checkmark & \checkmark &\\
variable-define & vdf & \verb#@::# & 44 & & & \checkmark & & \checkmark & \checkmark & &\\
\hline
equate & equ & \verb#=# & 1 & & & & & & & & \checkmark \\
define-equate & deq & \verb#:=# & 47 & & & \checkmark & & \checkmark & \checkmark & \checkmark & \checkmark \\
\hline
equate-at & eqa & \verb#=@# & 16 & & & & \checkmark & & & &\\
define-equate-at & dqa & \verb#:=@# & 22 & & & & \checkmark & & \checkmark & \checkmark &\\
\hline
\hline
$\sim$define & def* & N/A & 172& \checkmark & & \checkmark & & \checkmark & \checkmark & &\\
$\sim$define-equate & deq* & N/A & 173 & \checkmark & & \checkmark & & \checkmark & \checkmark & & \checkmark \\
$\sim$define-equate-at & dqa* & N/A & 148 & \checkmark & & & \checkmark & & \checkmark & &\\
\hline
$\sim$define & def** & N/A & 236 & \checkmark & \checkmark & \checkmark & & \checkmark & \checkmark & &\\
$\sim$define-equate & deq** & N/A & 237 & \checkmark & \checkmark & \checkmark & & \checkmark & \checkmark & & \checkmark \\
$\sim$define & def-c** & N/A & 204 & \checkmark & \checkmark & & & \checkmark & \checkmark & &\\
\hline
\end{tabular}
\end{center}
\caption{The flags of all various define, assignment and aliasing operators}
\label{defineFlagsTable}
\end{table}\index{define, flags|)} \index{operators!define|)}






% --------------- Predefined variables and functions --------------


\subsection{Predefined functions and variables}

Cicada comes prepackaged with a number of C-coded and scripted functions.  The C-coded functions are come from the \verb#ciclib.c# source file, and they are defined in exactly the same way as user-defined C functions/wrappers.  The scripted functions come from a \verb#defs.cicada# script (which is distributed in stringified form as \verb#defs.c#), a number of which are just wrappers for the C-coded functions.  \verb#defs.cicada# also predefines some variables and constants.  Finally, when Cicada is run interactively, the terminal itself defines a few variables in the user's workspace.

Table \ref{built_in_IDs} lists the predefined C functions, scripted functions, and other scripted variables.  Their descriptions follow in alphabetical order.\\

\noindent \underline{Basic constants:}
\begin{itemize}
\item \texttt{e}:\index{e@\texttt{e}}  the exponential constant.  Calculate exponentials by writing \verb#e^x#, or use the vectorized \verb#exp()# function
\item \texttt{pi}:\index{pi@\texttt{pi}}  the famous constant pi
\item \texttt{inf}:\index{inf@\texttt{inf}}  infinity
\item \texttt{nan}:\index{nan@\texttt{nan}}  not-a-number (used by floating-point arithmetic)
\item \texttt{passed}:\index{passed@\texttt{passed}}  0, denoting the error code of a function that did not cause any error
\item \texttt{root}:\index{root@\texttt{root}}  an alias to the user's workspace
\end{itemize}


\noindent \paragraph{\underline{Predefined functions and variables}}


\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c||c|c|c||c|c|c|}
\hline
{\bf name} & {\bf \emph{f}} & {\bf \texttt{\$}} & {\bf \texttt{>}} & {\bf name} & {\bf \emph{f}} & {\bf \texttt{\$}} & {\bf name} & {\bf \emph{f}} & {\bf \texttt{\$}}\\
\hline \hline
newCompiler & x & x & & filePaths & & & add & x & x\\
compile & x & x & & cd & x & & subtract & x & x\\
transform & x & x+ & & pwd & x & & multiply & x & x\\
\cline{5-7}
disassemble & x & & & run & x & & divide & x & x\\
\cline{1-4}
trap & x & x & & load/Load & x & x & pow & x & x\\
\cline{8-10}
throw & x & x & & save/Save & x & x & min & x & x\\
\cline{1-4} \cline{5-7}
top & x & x & & input & x & x & max & x & x\\
size & x & x & & print & x & x & sum & x & x\\
type & x & x & & printl & x & & mean & x & \\
\cline{8-10}
bytecode & x & x & & sprint & x & & abs & x & x\\
member\_ID & x & x & & mprint & x & & floor & x & x\\
\cline{5-7}
allNames & & & \checkmark & read\_string & x & x & ceil & x & x\\
\cline{1-4}
do\_in & x & & & print\_string & x & x & round & x & x\\
\cline{8-10}
compile\_and\_do\_in & x & & & cat & x & & exp & x & x\\
\cline{5-7}
go & x & & & readTable & x & & log & x & x\\
\cline{8-10}
jump & x & & & readFile & x & & cos & x & x\\
go\_path & & & \checkmark & readInput & x & & sin & x & x\\
where & & & & writeTable & x & & tan & x & x\\
what & x & & & saveTable & x & & acos & x & x\\
\cline{1-4} \cline{5-7}
calculator & x & & \checkmark & find & x & x & asin & x & x\\
\cline{5-7}
ans & & & \checkmark & lowercase & x & & atan & x & x\\
\cline{1-4} \cline{8-10}
springCleaning & x & x & & uppercase & x & & random & x & x\\
\cline{8-10}
 &  & & & C\_string & x & & sort & x & x+\\
 &  & & & & x & & binsearch & x & \\
\hline
\end{tabular}
\caption{Built-in functions and variables.  An `x' in the `\emph{f}' column indicates that it's an executable function.  An `x' in the `\$' column indicates that there is a corresponding C function.  A checkmark in the \texttt{>} column indicates that the definition only exists when running from the terminal (all of these are on the left side of the table)}\index{types!primitive}
\label{built_in_IDs}
\end{center}
\end{table}




% abs()

\paragraph{\texttt{abs()}, \texttt{\$abs()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{y} = \texttt{abs}((numeric) \emph{x})\\
\normalfont \emph{C syntax: } \texttt{\$abs}((double) \emph{x}, (double) \emph{y})\\\\}\index{abs@\texttt{abs()}|(}

Returns the absolute value of its argument, which must be a numeric scalars or arrays.\\

\index{abs@\texttt{abs()}|)}



% acos()

\paragraph{\texttt{acos()}, \texttt{\$acos()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{y} = \texttt{acos}((numeric) \emph{x})\\
\normalfont \emph{C syntax: } \texttt{\$acos}((double) \emph{x}, (double) \emph{y})\\\\}\index{acos@\texttt{acos()}|(}

Returns the inverse cosine of its argument.  The argument must be a number on the interval [-1, 1] (a number outside this range will generate the `not a number' value on many machines).  The result is on the interval [0, $\pi$].  The arguments may be numeric scalars or arrays.\\

\index{acos@\texttt{acos()}|)}



% add()

\paragraph{\texttt{add()}, \texttt{\$add()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{z} = \texttt{add}((numeric) \emph{x}, (numeric) \emph{y})\\
\normalfont \emph{C syntax: } \texttt{\$add}((doubles) \emph{x}, (doubles) \emph{y}, (doubles) \emph{z})\\\\}\index{min@\texttt{min()}|(}

Computes $z = x + y$, for scalar or vector numeric data.\index{add@\texttt{add()}|)}\\\\




% allNames

\paragraph{\texttt{allNames}:}\index{allNames@\texttt{allNames}|(}  the list of member names that have been defined so far, including those defined in \verb#terminal.cicada#.  \verb#allNames# is updated with every new command-line prompt, or every time the user calls \verb#compile()# with \verb#allNames# as the fourth argument.  This list is used by \verb#user.cidada#'s \verb#go()# and \verb#what()# functions.\index{allNames@\texttt{allNames}|)}




% ans

\paragraph{\texttt{ans}:}\index{ans@\texttt{ans()}|(}:  short for ``answer".  This is aliased to whatever the calculator last printed (void if the calculator hasn't printed anything yet).  Use \verb#ans# like any other variable:

\begin{code} \begin{verbatim}
> 2+5

7

> ans*2

14
\end{verbatim} \end{code}

\index{ans@\texttt{ans()}|)}




% asin()

\paragraph{\texttt{asin()}, \texttt{\$asin()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{y} = \texttt{asin}((numeric) \emph{x})\\
\normalfont \emph{C syntax: } \texttt{\$asin}((double) \emph{x}, (double) \emph{y})\\\\}\index{asin@\texttt{asin()}|(}

Returns the inverse sine of its argument.  The argument must be a number on the interval [-1, 1] (a number outside this range will generate the `not a number' value on many platforms).  The result is on the interval [$-\pi/2$, $\pi/2$].  The arguments may be numeric scalars or arrays.\\

\index{asin@\texttt{asin()}|)}




% atan()

\paragraph{\texttt{atan()}, \texttt{\$atan()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{y} = \texttt{atan}((numeric) \emph{x})\\
\normalfont \emph{C syntax: } \texttt{\$atan}((double) \emph{x}, (double) \emph{y})\\\\}\index{atan@\texttt{atan()}|(}

Returns the inverse tangent of the argument, which must be numeric scalars or arrays.  The result is an angle in radians on the interval [$-\pi/2$, $\pi/2$].\\

\index{atan@\texttt{atan()}|)}



% binsearch()

\paragraph{\texttt{binsearch()}\\\\
\normalfont \emph{syntax: } \texttt{binsearch}((table) \emph{table\_to\_search}, (numeric) \emph{value\_to\_find})\\\\}\index{binsearch@\texttt{binsearch()}|(}\index{tables!searching|(}

Searches a sorted list for a given value.  The list must be numeric (\verb#char#-typed lists are OK).  If the list is not sorted then \verb#binsearch()# will probably not find the element.\index{binsearch@\texttt{binsearch()}|)}\index{tables!searching|)}\\\\



% bytecode()

\paragraph{\texttt{bytecode()}\\\\
\normalfont \emph{syntax: } (string) \emph{codeString} = \texttt{bytecode}((function) \emph{myFunction} [, (numeric) \emph{memberIndex}])\\
\normalfont \emph{C syntax: } \texttt{\$bytecode}((function) \emph{myFunction}, (int) \emph{memberNumber}, (string) \emph{codeString})\\\\}
\index{bytecode@\texttt{bytecode()}|(}

Returns the bytecode of a given variable or member.  If there is one argument it returns the bytecode of that variable; if there are two then it returns the bytecode of member \verb#myFunction[memberIndex]#.  Member code is never run directly, but it determines the sort of variable a member can point to (because \emph{code} and \emph{type} are equivalent in Cicada).

To read the bytecode we need to move the bytecode data from the string into an array of integers using the \verb#=!# operator.  The last integer is always 0, signifying the end of bytecode.  If there are multiple codes (due to the inheritance operator) then the codes are concatenated in parent-to-child order in the same string, and each separate code ends in a null integer.  \texttt{bytecode()} is the inverse operation to \texttt{transform()}.

The \verb#bytecode()# function return the code for functions, but also many other objects that we don't normally think of as having code.  In fact the only restriction is that \verb#myFunction# must be some composite object (defined using curly braces).  So if we define

\begin{code} \begin{verbatim}
pow :: {
    params :: { x :: y :: double  }
    
    code
    
    params = args
    return new(params.x^params.y)
}
\end{verbatim} \end{code}

\noindent then \verb#bytecode(pow)# returns the bytecode for everything inside \verb#pow()#'s definition (including the definition of \verb#params# and the \verb#code# marker), whereas \verb#bytecode(pow.params)# is also legal and returns the bytecode corresponding to \verb#x :: y :: double#.\\

\index{bytecode@\texttt{bytecode()}|)}




% C_string


\paragraph{\texttt{C\_string()}\\\\
\normalfont \emph{syntax: } (string) \emph{string bytes} = \texttt{C\_string}((string) \emph{my\_string})\\\\}\index{C\_string@\texttt{C\_string()}|(}

Cicada strings are normally stored internally as linked lists.  \verb#C_string()# converts a length-$N$ resizable Cicada string to a $N+1$-byte C-style string containing a terminating 0 character.\index{C\_string@\texttt{C\_string()}|)}\\\\



% calculator

\paragraph{\texttt{calculator}:}\index{calculator@\texttt{calculator}|(} is a function that prints the results of incomplete expressions at the command line.  An incomplete expression is one that is not assigned to a variable, or used in any other way.  For example, if the user types

\begin{code} \begin{verbatim}
a = 5 + 2
\end{verbatim} \end{code}

\noindent then nothing will be printed, regardless of whether \texttt{calculator} is on or off.  However, if the user were to enter just

\begin{code} \begin{verbatim}
5 + 2
\end{verbatim} \end{code}

\noindent then the answer `7' will be printed, thanks to the calculator.

To be completely technical, the calculator prints the data of all hidden members created by the user.  Since these members will never be used again, the terminal removes them after each command from the user, but only after asking the calculator to print them first.  The calculator is only a printing function, not a calculator per-se.

By default, the calculator is aliased to \verb#defs.cicada#'s \verb#sprint()# function.  We can change the output style by aliasing it to another printing function:

\begin{code} \begin{verbatim}
> calculator = @mprint
\end{verbatim} \end{code}

\noindent Or, if calculator is getting annoying (e.g. printing the output of functions we don't care about, or that return enormous blocks of data), we can turn it off altogether:

\begin{code} \begin{verbatim}
> calculator = @nothing
\end{verbatim} \end{code}

\index{calculator@\texttt{calculator}|)}



% cat()

\paragraph{\texttt{cat()}\\\\
\normalfont \emph{syntax: } (string) \emph{concatenated string} = \texttt{cat}((variables) \emph{var1}, \emph{var2}, ...)\\\\}\index{cat@\texttt{cat()}|(}

Returns a string which is the concatenation of the arguments.  This is just a convenient implementation of the \verb#print_string()# function:  \verb#s = cat(v1, v2)# is equivalent to \verb#print_string(s, v1, v2)#.\index{cat@\texttt{cat()}|)}\\\\\\\\




% cd()

\paragraph{\texttt{cd()}\\\\
\normalfont \emph{syntax: } \texttt{cd}((string) \emph{filepath})\\\\}\index{cd@\texttt{cd()}|(}

The easiest way to change Cicada's file-search directory.  \verb#cd()# resizes the \verb#filePaths[]# array to size 1 and sets that to the string given as its argument.\index{cd@\texttt{cd()}|)}\\\\



% ceil()

\paragraph{\texttt{ceil()}, \texttt{\$ceil()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{y} = \texttt{ceil}((numeric) \emph{x})\\
\normalfont \emph{C syntax: } \texttt{\$ceil}((double) \emph{x}, (double) \emph{y})\\\\}\index{ceil@\verb$ceil()$|(}

Returns the nearest integer that is as high as or higher than the argument, which must be numeric.  For example, \verb$ceil(5.6)$ returns 6, \verb$ceil(-5.6)$ returns -5, and \verb$ceil(2)$ returns 2.  Both arguments may also be arrays\\

\index{ceil@\verb$ceil()$|)}


 

% compile()

\paragraph{\texttt{compile()}\\\\
\normalfont \emph{syntax: } (string) \emph{script\_bytecode} = \texttt{compile}((string) \emph{script} [, (string) \emph{char\_positions} [, member\_names]] [, \texttt{code}, \texttt{compilerID} = (int), \texttt{filename} = (string)])\\
\normalfont \emph{C syntax: } \texttt{\$compile}((int) \emph{compilerID}, (string) \emph{script}, (string) \emph{filename}, (string) \emph{script\_bytecode}, (string) \emph{char\_positions}, (int) \emph{num\_member\_names})\\\\}
%\normalfont \emph{C-2 syntax: } \texttt{\$getMemberNames}((int) \emph{compilerID}, (strings) \emph{member\_names}, (int) \emph{first\_name\_to\_load})\\\\}
\index{compile@\texttt{compile()}|(textbf}

Before Cicada can execute a script, that script must be compiled into a binary form called bytecode that is much easier to execute than the raw text.  The built-in \texttt{compile()} function does this job.  Given a string containing a Cicada script (\verb#script#), \verb#compile()# returns a second string (\verb#script_bytecode#) containing Cicada bytecode.  The bytecode is \emph{not} machine code -- it is only used by Cicada.

A basic \verb#compile()# call looks like:

\begin{code} \begin{verbatim}
myBytecode := compile("x = 3")
\end{verbatim} \end{code}

\noindent This command produces bytecode from a given script.  Optionally, the compiler ID can be set to the return value from a \verb#newCompiler()# call.  Each compiler keeps a record of all variable names, so if \verb#x# had been defined with bytecode produced by the current compiler then this command will run just fine.  The scripted function calls \verb#$getMemberNames()# to maintain the \verb#allNames# list.

A compilation error will actually crash the script running the \verb#compile()# command.  To prevent this we can enclose the \verb#compile()# call inside of the \verb#trap()# function.  If we want to print out the error message, we can write a semicolon or \verb#code# marker at the beginning of \verb#trap()#'s arguments.

\begin{code} \begin{verbatim}
> trap(; compile("x = "))

Error:  right-hand argument expected

x =
  ^
\end{verbatim} \end{code}

\noindent The optional second \verb#filename# argument causes any error message to reference that file name.

\begin{code} \begin{verbatim}
> trap(; compile("x = "; filename = "myFile.txt"))

Error:  right-hand argument expected in file myFile.txt
\end{verbatim} \end{code}

Often a script will compile but cause an error when it runs.  In order to properly flag runtime error messages we must collect another piece of information:  the character position in the original script of each bytecode word.  This lets the error message flag the offending line in the original script.  The character positions are stored inside of any string that is passed as an optional third argument to \texttt{compile()}.  Both that string and the original Cicada script will be passed to \verb#transform()#, the function that actually allows compiled bytecode to be run.

In some cases we may want to avoid using \verb#compile()#, but instead hand-code the bytecode and load it in using \verb#transform()#.  After all, \texttt{compile()} is only a string operation:  it converts a readable script into a string containing binary bytecode.\\

 \index{compile@\texttt{compile()}|)textbf}
 
 
 
 % compile_and_do_in()

\paragraph{\texttt{compile\_and\_do\_in()}\\\\
\normalfont \emph{syntax: } \texttt{compile\_and\_do\_in}((composite) \emph{target} [, \emph{search path} [, \emph{code\_args} [, \emph{bytecode\_mod\_args}]]] , code, (string) \emph{base script string} [, \texttt{code}, code modifying \texttt{bytecode[]}])\\\\}\index{compile\_and\_do\_in@\texttt{compile\_and\_do\_in()}|(}

Compiles a script, optionally modifies it, and then executes the script in the provided directory.  This is equivalent to \verb#do_in()# except that the script is stored as an uncompiled string rather than compiled code.  We write the arguments just as we did for \verb#do_in()#, except with an extra pair of double-quotes around the code to compile (even though it's in the coding section of the arguments).  The analog of the \verb#do_in()# example would be:


\begin{code} \begin{verbatim}
compile_and_do_in(root; "al := @var1"; bytecodeWords[2] = that + 128)
\end{verbatim} \end{code}\index{compile\_and\_do\_in@\texttt{compile\_and\_do\_in()}|)}




% cos()

\paragraph{\texttt{cos()}, \texttt{\$cos()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{y} = \texttt{cos}((numeric) \emph{x})\\
\normalfont \emph{C syntax: } \texttt{\$cos}((double) \emph{x}, (double) \emph{y})\\\\}\index{cos@\texttt{cos()}|(}

Returns the cosine of its argument.  The argument must be numeric scalars or arrays..\\

\index{cos@\texttt{cos()}|)}
 


% disassemble()

\paragraph{\texttt{disassemble()}\\\\  
\normalfont \emph{syntax: } [(string) \emph{disassembly} = ] \texttt{disassemble}((string) \emph{compiled\_code} [ , (string array) \emph{name\_space} [ , (int) \emph{start\_position} ] ] [ , code, (bool) \texttt{expandFunctions}, (int) \texttt{flagPosition} = values ])\\\\}\index{disassemble@\texttt{disassemble()}|(textbf}

The \texttt{disassemble()} function returns a textual interpretation of compiled Cicada bytecode.  The first argument is a string containing the bytecode.  The optional second argument allows the user to pass a different namespace (a string array) other than \verb#allNames[]#, or \verb#*# to avoid printing member names.  The function will return the `disassembly' as a readable string.  Used by the author to satisfy the odd craving for a rush of bytecode:

\begin{code} \begin{verbatim}
> disassemble(compile("x = that + 2", *, *, allNames))
\end{verbatim} \end{code}

By passing a third argument, the disassembler can be used to skip over a bytecode expression.  In this case the disassembler will only disassemble up to the end of the expression, and if the starting word index was passed in a variable then that variable will be updated to the beginning of the next expression.  For example, we can use this feature to write a function that finds the $N$th command in a compiled expression.

\begin{code} \begin{verbatim}
go_to_Nth_sentence :: {
    
    code
    
    code_string := args[1]
    N := args[2]
    
    code_index := 1
    for (n :: int) in <1, N-1>  &
        disassemble( code_string, *, code_index )
    
    return new(code_index)
}
\end{verbatim} \end{code}

\noindent When run in this `skip' mode, \verb#disassemble()# does \emph{not} return any bytecode string.  If you want the output string you should first find the end of the expression that \emph{start\_position} begins, then do a full disassembly on just that expression.

The \verb#expandFunctions# option determines whether inlined code definitions (as in, objects defined within curly braces) are disassembled (\verb#true# is the default), or skipped with an ellipsis if \verb#false#.  If \verb#flagPosition# is set to an integer value then the disassembler will flag that bytecode word, which is useful for marking errors.\index{disassemble@\texttt{disassemble()}|)textbf} \index{functions!pre-scripted|)}\\\\\\



% divide()

\paragraph{\texttt{divide()}, \texttt{\$divide()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{z} = \texttt{divide}((numeric) \emph{x}, (numeric) \emph{y})\\
\normalfont \emph{C syntax: } \texttt{\$divide}((doubles) \emph{x}, (doubles) \emph{y}, (doubles) \emph{z})\\\\}\index{min@\texttt{min()}|(}

Computes $z = x / y$, for scalar or vector numeric data.\index{divide@\texttt{divide()}|)}\\\\




% do_in()

\paragraph{\texttt{do\_in()}\\\\
\normalfont \emph{syntax: } \texttt{do\_in}((composite) \emph{target} [, \emph{search path} [, \emph{code\_args} [, \emph{bytecode\_mod\_args}]]] , code, base script [, \texttt{code}, code modifying \texttt{bytecodeWords[]}])\\\\}\index{do\_in@\texttt{do\_in()}|(}

The \verb#do_in()# tool allows one to run code in a specified location and with a specified search path, and gives the option of manually modifying the bytecode before it is run.  The idea is that it is easier to write bytecode by perturbing a compiled script than to write everything from scratch.

The first argument to \verb#do_in()# is the variable to run the code inside.  The optional second argument gives a customizable search path, and it exactly mirrors the optional third argument to \verb#transform()# (see the reference on \verb#transform()# for how to specify a path).  The third and fourth arguments, if given, are passed as \verb#args[1]# for the script to be run and the bytecode-modifying script respectively.

Following the first code marker we give the text of the script that we want to run, or the closest that the Cicada compiler can achieve.  Often this is all we need.  On occasion we may wish to modify the compiled bytecode of the baseline script before it executes, perhaps to achieve something that is unscriptable.  \verb#do_in()# accommodates this need by running, in unusual fashion, the code following an optional \emph{second} \verb#code# marker/semicolon in its argument list (if that exists) after compilation but before execution.   At that time the compiled baseline script will be stored in an array entitled \verb#bytecodeWords# of integers, and we may alter in any way whatsoever provided the bytecode comes out legitimate.  In the extreme case we can give no baseline script and simply alias \verb#bytecodeWords[]# to an existing integer array that is already filled with bytecode.

Here we show how to use \verb#do_in()# to create an unjammable alias to some variable \verb#var1#, which cannot be done using ordinary Cicada scripting.

\begin{code} \begin{verbatim}
do_in(
    root
    
    code
    
    al := @var1
    
    code
    
    bytecodeWords[2] = that + 128    | add an unjammable flag
)

\end{verbatim} \end{code}\index{do\_in@\texttt{do\_in()}|)}




% exp()

\paragraph{\texttt{exp()}, \texttt{\$exp()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{y} = \texttt{exp}((numeric) \emph{x})\\
\normalfont \emph{C syntax: } \texttt{\$exp}((double) \emph{x}, (double) \emph{y})\\\\}\index{exp@\texttt{exp()}|(}

Returns the exponential (base $e$) of its argument.  The arguments must be numeric scalars or arrays.\\

\index{exp@\texttt{exp()}|)}



% filePaths()

\paragraph{\texttt{filePaths[]}:}\index{filePaths@\texttt{filePaths}|(}  a string array of pathnames to folders.  \verb#Load()#, \verb#Save()#, and \verb#run()# will search each of these paths when looking for a file.  The terminal preloads an empty path, which usually implies the Cicada directory.  We can change the search paths just by manipulating this set:  e.g. \verb#filePaths[+2] = "/Desktop/"#.\index{filePaths@\texttt{filePaths}|)}\\\\\\\\



% find()

\paragraph{\texttt{find()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{result} = \texttt{find}((strings) \emph{search\_in}, \emph{search\_for} [\texttt{, code, mode} = -1/0/1 [\texttt{, code, startPosition} = (numeric)]])\\
\normalfont \emph{C syntax: } \texttt{\$find}((string) \emph{search\_in}, (string) \emph{search\_for}, (int) \emph{mode}, (int) \emph{starting\_position}, (int) \emph{result})\\\\}
\index{find@\texttt{find()}|(}

Finds an instance of, or counts the number of instances of, a substring (argument 2) within another string (argument 1).  If \texttt{find()} is used in search mode, it returns the character position (where 1 denotes the first character) where the substring was first found, and 0 if it was not found anywhere.  If \texttt{find()} is run in count mode, it returns the number of instances of the substring found within the larger string.

The optional third argument controls the mode that \texttt{find()} is run in:  it needs to be -1, 0 or 1.  If a mode is not specified then it defaults to mode 1, which denotes a forward search; i.e. it will return the first instance of the substring that it finds.  Mode -1 corresponds to a reverse search, which will find the last instance of the substring.  Mode 0 is the count mode.

By default, a forward search begins from the first character, and a reverse search begins with the last character.  A count proceeds forward from the first character.  The starting character can be changed by specifying a starting position in the fourth argument.  A mode has to be given in order for a starting position to be specified.\\

\index{find@\texttt{find()}|)}




% floor()

\paragraph{\texttt{floor()}, \texttt{\$floor()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{y} = \texttt{floor}((numeric) \emph{x})\\
\normalfont \emph{C syntax: } \texttt{\$floor}((double) \emph{x}, (double) \emph{y})\\\\}\index{floor@\verb$floor()$|(}

Returns the nearest integer that is as low as or lower than the (numeric) argument.  For example, \verb$floor(2.3)$ returns 2, \verb$floor(-2.3)$ returns -3, and \verb$floor(-4)$ returns -4.  The arguments may be numeric scalars or arrays.\\\\

\index{floor@\verb$floor()$|)}




% go()

\paragraph{\texttt{go()}\\\\
\normalfont \emph{syntax: } \texttt{go}([ code, ] \emph{path})\\\\}\index{go@\texttt{go()}|(}

Cicada's \verb#go()# function changes the working variable for commands entered from the prompt.  A search path is dragged along behind that leads eventually back to \verb#root# (the original workspace).  To see how this works, type:

\begin{code} \begin{verbatim}
> a :: { b := 2 }

> go(a)

> b    | we are now in 'a', so this is legal

2

> a    | search path extends back to root, so we can see 'a' as a member

{ 2 }
\end{verbatim} \end{code}

The search path exactly backtracks the given path.  If one types \verb#go(a[b].c().d#, then the working variable is `\verb#d#', and the search path goes backwards through (in order):  the return variable of `\verb#c#', then `\verb#c#' itself, then the \verb#b#'th element of `\verb#a#', then `\verb#a#' itself and finally \verb#root#.  Typing just \verb#go()# sends one back to the root; typing \verb#go(root)# is actually not quite as good because it puts \verb#root# on the path list twice.  To see the path, look at the global \verb#pwd# variable.

\verb#go()# works by updating the \verb#go_paths[]# array defined by the terminal.  Each command entered from the prompt is transformed and run according to the current state of \verb#go_paths#, so invoking \verb#go()# does not take effect until the next entry from the prompt.  Thus it was necessary in our example to separate the second and third lines:  \verb#go(a), sprint(b)# would have thrown a member-not-found error.  For the same reason, while running a script (via \verb#run()#), \verb#go()# will do nothing until the script finishes -- use \verb#do_in()# instead.

When the user calls \verb#go(...)#, Cicada constructs the argument list before \verb#go()# itself has a chance to run.  Owing to this fact, certain sorts of go-paths will cause an error that \verb#go()# can do nothing about.  For example, \verb#go(this[3])# will never work because `\verb#this#' is construed as the argument variable, not the working variable.  To get around this problem, \verb#go()# gives us the option of writing the path after a \verb#code# marker or semicolon, as in \verb#go(code, this[3])#, as those paths are not automatically evaluated.  A \verb#code# marker is also useful if we need to step to a function's return variable but don't want the function to run more than once.  \verb#go(code, a.f().x)# will evaluate \verb#f()# just a single time in the course of go-processing, whereas for technical reasons \verb#f()# would have run twice had we not included the \verb#code# marker.

\verb#go()# at present has many limitations.  Each path must begin with a member name or \verb#this#, and all subsequent steps must consist of step-to-member (\verb#a.b#) and step-to-index (\verb#a[b]# and related) operations and function calls (\verb#a()#).  No \verb#[+..]# or \verb#+[..]# operators are allowed.  The step-to-index operations are particularly dicey because of two nearly contradictory requirements:  the path can only step through single indices, and for practical use the path must nearly always span complete members (i.e. \emph{all} of the indices of an arrays).  Although the latter is not a hard requirement, it is really hard to do anything meaningful within a single element of an array, because so many common operations involve creating tokens and hidden variables which can only be done for \emph{all} elements of the array simultaneously.  Even trying to reset the path by typing \verb#go()# will not work at that point, so in this sticky situation the terminal will eventually bail the user out.  The upshot of all this is that \verb#go()# does not work very well inside of arrays.

\verb#jump()# is a similar operation to \verb#go()#, except that \verb#go()# can shorten a path whereas successive \verb#jump#s keep appending to the current search path.\index{go@\texttt{go()}|)}\\\\




% go_path

\paragraph{\texttt{go\_path[]}:}\index{go\_path@\texttt{go\_path}}  a set of aliases to each composite object in the search path, beginning with \verb#root# and ending with the current working variable.  The terminal uses \verb#go_path# to form the search path for each command entered by the user.  Both \verb#go()# and \verb#jump()# work by modifying \verb#go_path#, and the terminal will reset \verb#go_path# if it detects a problem.  The user can add a small coding section to \verb#go_path# which the terminal will run if it needs to reset the path; in this coding section do not define any variables or run any functions or problems will start happening.\\\\




% input()

\paragraph{\texttt{input()}\\\\
\normalfont \emph{syntax: } (string) \emph{str} = \texttt{input}(\emph{args\_to\_print})\\
\normalfont \emph{C syntax: } \texttt{\$input}((string) \emph{str}, \emph{args\_to\_print})\\\\}
\index{input@\texttt{input()}|(}

Reads in a single line from the C standard input (which is usually the keyboard).  \texttt{input()} causes Cicada's execution to halt until an end-of-line character is read (i.e. the user hits return or enter), at which point execution resumes.  The return string contains all characters before, but not including, the end-of-line.  Reading in a null character causes the error ``I/O error" to be thrown.\\

\index{input@\texttt{input()}|)}




% jump()

\paragraph{\texttt{jump()}\\\\
\normalfont \emph{syntax: } \texttt{jump}([ code, ] \emph{path})\\\\}\index{jump@\texttt{jump()}|(}

\verb#jump()# is basically identical to \verb#go()# except in the way that it handles the first step in a search path.   For most details, see the explanation of \verb#go()# above.  The difference between the two functions can be seen by example.

\begin{code} \begin{verbatim}
> a :: { b :: { ... } }

> go(a.b), where

root.a.b

> go(a), where   | starting from a.b

root.a

> go(b), where

root.a.b

> jump(a), where   | again, starting from a.b

root.a.b-->a
\end{verbatim} \end{code}

\noindent \verb#jump()# takes advantage of the fact that search paths in Cicada can twine arbitrarily through memory space; we don't have to restrict ourselves to paths where each variable is `contained in' the last.  A more useful path would be something like \verb#root.a.b-->c.d#:  that would allow us to work inside of `\verb#d#' while retaining access to `\verb#a#' and `\verb#b#', even if those latter lie along a different branch.\index{jump@\texttt{jump()}|)}\\\\





% load()

\paragraph{\texttt{load()}\\\\
\normalfont \emph{syntax: } (string) \emph{file\_string} = \texttt{Load}((string or int) \emph{file\_name})\\
\normalfont \emph{syntax: } (string) \emph{file\_string} = \texttt{load}((string or int) \emph{file\_name})\\
\normalfont \emph{C syntax: } \texttt{\$load}((string or int) \emph{file\_name}, (string) \emph{file\_string})\\\\}
\index{load@\texttt{load()}|(} \index{file I/O!loading|(}

Reads a file into a string.  If there is an error in opening or reading the file (i.e. if the file was not found), then \texttt{load()} returns ``I/O error", signifying that the error comes from the operating system, not Cicada.  The counterpart to \texttt{load()} is \texttt{save()}.

Little-L \texttt{load()} only looks for files in the default directory.  Big-L \texttt{Load()} extends this function by searching all paths specified in the \texttt{filePaths[]} array.

The filename may be an integer (1-3) rather than a string, in order to load one of the predefined scripts.  The scripts are:  1) \verb#defs.cicada#; 2) \verb#terminal.cicada#; 3) the user's script passed to \verb#runCicada()# (if given, otherwise an error is thrown).\\\\\index{Load@\texttt{Load()}|)}\index{file I/O!loading|)}\\\\

\index{load@\texttt{load()}|)} \index{file I/O!loading|)}




% log()

\paragraph{\texttt{log()}, \texttt{\$log()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{y} = \texttt{log}((numeric) \emph{x})\\
\normalfont \emph{C syntax: } \texttt{\$log}((double) \emph{x}, (double) \emph{y})\\\\}\index{log@\texttt{log()}|(}

Returns the natural logarithm (base $e$) of its argument.  The argument must be numeric scalars or arrays.\\

\index{log@\texttt{log()}|)}




% lowercase()

\paragraph{\texttt{lowercase()}\\\\
\normalfont \emph{syntax: } (string) \emph{lowercase\_string} = \texttt{lowercase}((string) \emph{my\_string})\\\\}\index{lowercase@\texttt{lowercase()}|(}

Converts a mixed-case string to lowercase.\index{lowercase@\texttt{lowercase()}|)}\\\\



% max()

\paragraph{\texttt{max()}, \texttt{\$minmax()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{result} = \texttt{max}((numeric list) \emph{the\_list} [, \texttt{code}, \texttt{rtrn} = \{ \texttt{index} / \texttt{value} / \texttt{both}])\\
\normalfont \emph{C syntax: } \texttt{\$minmax}((doubles) \emph{the\_list}, 1, (int) \emph{index}, (double) \emph{value}])\\\\}\index{max@\texttt{max()}|(}

Returns the maximum element of a list:  its index, value (the default), or both \{ index, value \}.\index{max@\texttt{max()}|)}\\\\



% mean()

\paragraph{\texttt{mean()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{result} = \texttt{mean}((numeric list) \emph{the\_list})\\\\
\normalfont \emph{C syntax: } \texttt{\$mean}((doubles) \emph{the\_list}, (double) \emph{result})\\\\}\index{mean@\texttt{mean()}|(}

Returns the average (arithmetic mean) of the elements of a numeric list.\index{mean@\texttt{mean()}|)}\\\\




% member_ID()

\paragraph{\texttt{member\_ID()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{ID} = \texttt{member\_ID}((composite variable) \emph{var}, (numeric) \emph{member\_number})\\
\normalfont \emph{syntax: } \texttt{\$member\_ID}((composite variable) \emph{var}, (int) \emph{member\_number}, (int) \emph{ID})\\\\}
\index{member_ID@\texttt{member\_ID()}|(}

Returns the ID number of a given member of a composite variable.  The ID is essentially the bytecode representation of the member's name.  Under normal conditions user-defined names are assigned positive ID numbers, whereas hidden members are given unique negative ID numbers.  The variable enclosing the member is the first argument, and the member number is the second argument.\\

\index{member_ID@\texttt{member\_ID()}|)}



% min()

\paragraph{\texttt{min()}, \texttt{\$minmax()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{result} = \texttt{min}((numeric list) \emph{the\_list} [, \texttt{code}, \texttt{rtrn} = \{ \texttt{index} / \texttt{value} / \texttt{both}])\\
\normalfont \emph{C syntax: } \texttt{\$minmax}((doubles) \emph{the\_list}, -1, (int) \emph{index}, (double) \emph{value}])\\\\}\index{min@\texttt{min()}|(}

Returns the minimum element of a list:  its index, value (the default), or the combination \{ index, value\}.\index{min@\texttt{min()}|)}\\\\



% mprint()

\paragraph{\texttt{mprint()}\\\\
\normalfont \emph{syntax: } \texttt{mprint}([data to print] [ ; (ints) \texttt{fieldWidth}, \texttt{maxDigits}, (string) \texttt{voidString} = values ])\\\\}\index{mprint@\texttt{mprint()}|(}\index{tables!printing|(}

This `matrix' print function prints tables of numbers.  Each index of the argument is printed on a separate line; each index of a row prints separately with a number of spaces in between.  For example:

\begin{code} \begin{verbatim}
> mprint({ 2, { 3, nothing, 5 }, { 5/2, "Hello" } })

2
3         *         5         
2.5       Hello     
\end{verbatim} \end{code}

\noindent \texttt{mprint()} has three user-adjustable optional parameters that can be changed in the argument coding section.  \verb#mprint.fieldWidth# controls the number of spaces in each row; it defaults to 12.  \verb#mprint.maxDigits# controls the precision of numbers that are printed out; it defaults to 6.  A \verb#maxDigits# of zero means `no limit'.  \verb#mprint.voidString# is the string used to represent void members.\index{mprint@\texttt{mprint()}|)}\index{printing!to screen|)}\index{tables!printing|)}\\\\\\\\



% multiply()

\paragraph{\texttt{multiply()}, \texttt{\$multiply()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{z} = \texttt{multiply}((numeric) \emph{x}, (numeric) \emph{y})\\
\normalfont \emph{C syntax: } \texttt{\$multiply}((doubles) \emph{x}, (doubles) \emph{y}, (doubles) \emph{z})\\\\}\index{min@\texttt{min()}|(}

Computes $z = x * y$, for scalar or vector numeric data.\index{multiply@\texttt{multiply()}|)}\\\\



% newCompiler()

\paragraph{\texttt{newCompiler()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{compilerID} = \texttt{newCompiler}((\texttt{compiledCommandType} array) operatorDefs, (int array) opLevelDirections)\\
\normalfont \emph{C syntax: } \texttt{\$newCompiler}((\texttt{compiledCommandType} array) operatorDefs, (int array) opLevelDirections, (int) \emph{compilerID})\\\\}
\index{newCompiler@\texttt{newCompiler()}|(}

Produces a new compiler from a language specification, and returns the new compiler's ID number.  (The default Cicada compiler has ID number 1).  The two arguments are:  1) an array of \texttt{\{ string, int, string, string \}}, one element for each command, containing the command definitions; and 2) an array giving the direction of evaluation for each order-of-operations level.  These mirror the \verb#cicadaLanguage[]# and \verb#cicadaLanguageAssociativity[]# arrays, respectively, which are defined in \verb#cclang.c#.

The beginning of \verb#defs.cicada# has lots of definitions to make a language specification simpler and more readable.\\

\index{newCompiler@\texttt{newCompiler()}|)}



% pow()

\paragraph{\texttt{pow()}, \texttt{\$pow()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{z} = \texttt{pow}((numeric) \emph{x}, (numeric) \emph{y})\\
\normalfont \emph{C syntax: } \texttt{\$pow}((doubles) \emph{x}, (doubles) \emph{y}, (doubles) \emph{z})\\\\}\index{min@\texttt{min()}|(}

Computes the power function $z = x^y$, for scalar or vector numeric data.\index{pow@\texttt{pow()}|)}\\\\



% print()

\paragraph{\texttt{print()}\\\\
\normalfont \emph{syntax: } \texttt{print}((vars) v1, v2, ...)\\
\normalfont \emph{C syntax: } \texttt{\$print}((vars) v1, v2, ...)\\\\}
\index{print@\texttt{print()}|(} \index{printing!to screen|(}

Writes data to the standard output (which is normally the command prompt window).  The arguments are printed sequentially and without spaces in between.  Numeric arguments are converted to ASCII and printed as legible integers or floating-point numbers.  String arguments are written verbatim (byte-for-byte) to the screen, except that unprintable characters are replaced by their hexadecimal equivalents ``\verb$\AA$" (which is also the format in which these characters may be written into a string).  Also, carriage returns in strings are written as end-of-line characters, so a PC-style line ending marked by ``\verb$\0D\n$" outputs as a double line-break.

When Cicada is run from the command prompt, \verb#defs.cicada# loads three further printing functions:  \verb#printl()# (print with line break), \verb#sprint()# (for printing composite structures), and \verb#mprint()# (printing arrays).  \verb#sprint()# is the default function for printing expressions typed by the user.\\

\index{print@\texttt{print()}|)} \index{printing!to screen|)}



% print_string()

\paragraph{\texttt{print\_string()}\\\\
\normalfont \emph{syntax: } (string) \emph{result} = \texttt{print\_string}((vars) v1, v2, ... [\texttt{, code, maxFloatingDigits} = (numeric)])\\
\normalfont \emph{syntax: } \texttt{\$print\_string}((string) result, (int) max\_floating\_digits, (vars) v1, v2, ...)\\\\}
\index{print_string@\verb$print_string()$|(} \index{strings!type conversion|(} \index{printing!to a string|(}

Writes data to a text string.  \texttt{print\_string()} is the counterpart to \texttt{read\_string()}.  Roughly speaking, \texttt{print\_string()} is to \texttt{print()} as C's more elaborate \texttt{sprintf()} is to \texttt{printf()}.  The string to write is followed by any number of variables whose data Cicada writes to the string (with no spaces in between).  Strings from the source variables get copied into the destination string verbatim.  Numeric variables are written as text, and here \texttt{print\_string} differs from a forced equate.  For example: 

\begin{code} \begin{verbatim}
print_string(str, 5, 2.7)
\end{verbatim} \end{code}

\noindent sets \texttt{str} to ``52.7", whereas

\begin{code} \begin{verbatim}
str =! { 5, 2.7 }
\end{verbatim} \end{code}

\noindent gives something illegible (the raw bytes encoding the two numbers in binary format).

If the first argument is numeric, then it is taken as the minimum field width for numeric and Boolean (but not string or character) variables to be printed; otherwise the default minimum field width is zero.  If both the first and second arguments are numeric, then the second argument is the output precision for floating-point variables; otherwise the output precision is determined by the C constant \texttt{DBL\_DIG} for \texttt{double}-typed variables.  When no precision is specified, \texttt{print\_string} prints considerably more digits than does \texttt{print()}, whose precision is set by \verb#printFloatFormatString# at the top of \verb#cmpile.c#.\\

\index{print_string@\verb$print_string()$|)} \index{strings!type conversion|)} \index{printing!to a string|)}



% printl()

\paragraph{\texttt{printl()}\\\\
\normalfont \emph{syntax: } \texttt{printl}([data to print])\\\\}\index{printl@\texttt{printl()}|(}

This function is the same as \texttt{print()} except that it adds an end-of-line character at the end.\index{printl@\texttt{printl()}|)}\\\\




% pwd()

\paragraph{\texttt{pwd()}\\\\
\normalfont \emph{syntax: } \texttt{pwd}()\\\\}\index{pwd@\texttt{pwd()}|(}

Prints all file directories (all entries in the \verb#filePaths[]# array) to the screen.\index{pwd@\texttt{pwd()}|)}\\\\




% random()

\paragraph{\texttt{random()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{y} = \texttt{random}()\\
\normalfont \emph{C syntax: } \texttt{random}((doubles) \emph{y})\\\\}
\index{random@\verb$random()$|(}

Returns pseudo-random numbers uniformly drawn on the interval [0, 1].  To obtain the random number to double-precision, Cicada calls C's \verb$rand()$ function twice:

\begin{align*}
\texttt{random()} = \texttt{rand()}/\texttt{RAND\_MAX} + \texttt{rand()}/(\texttt{RAND\_MAX})^2\\
\end{align*}

\noindent The random number generator is initialized by Cicada to the current clock time each time the program is run, so the generated sequence should not be repeatable.  The scripted function returns a scalar; for vectorized random data run the C function.\\

\index{random@\verb$random()$|)}




% read_string()

\paragraph{\texttt{read\_string()}\\\\
\normalfont \emph{syntax: } \texttt{read\_string}((string) to\_write, (vars) v1, v2, ...)\\
\normalfont \emph{syntax: } \texttt{\$read\_string}((string) to\_write, (vars) v1, v2, ...)\\\\}
\index{read_string@\verb$read_string()$|(} \index{strings!type conversion|(}

Reads data from an ASCII string into variables.  The first argument is the string to read from; following arguments give the variables that will store the data.  \texttt{read\_string()} is the humble cousin to C's \texttt{sscanf()} routine (it does not take a format string).  The various fields within the string must be separated by white space or end-of-line characters.

\texttt{read\_string()} converts ASCII data in the source string into the binary format of Cicada's memory.  Thus numeric fields in the source string need to be written out as text, as in ``3.14".  Each string field must be one written word long, so ``the quick brown" will be read into three string variables, not one.  Composite variables are decomposed into their primitive components, which are read sequentially from the source string.  Void members are skipped.

Here is an example of the use of \texttt{read\_string()}

\begin{code} \begin{verbatim}
date :: { month :: string, day :: year :: int }
activity :: string
read_string("Jan 5 2007   meeting", date, activity)
\end{verbatim} \end{code}

If the string cannot be read into the given variables (i.e. there are too many or too few variables to read), then \verb#read_string()# throws a type-mismatch warning.  Warnings can also be thrown if \verb#read_string()# cannot read a field that should be numeric, or if there is an overflow in a numeric field.

\texttt{read\_string()} is a counterpart to \texttt{print\_string()}.  However, \texttt{print\_string()} does not write spaces in between the fields, so unless spaces are put in explicitly its output cannot be read directly by \texttt{read\_string()}.\\

\index{read_string@\verb$read_string()$|)} \index{strings!type conversion|)}



% readFile()

\paragraph{\texttt{readFile()}\\\\
\normalfont \emph{syntax: } \texttt{readFile}((table) \emph{table\_array}, (string) \emph{file\_name} [ ; (bools) \texttt{ifHeader}, \texttt{resizeColumns}, \texttt{resizeRows} = values])\\\\}
\index{readTable@\texttt{readTable()}|(}\index{tables!reading|(}

Identical to \texttt{readTable()}, except reads the table string from a file.  Searches all directories in the \verb#filePaths[]# array.\index{readTable@\texttt{readTable()}|)}\index{tables!reading|)}\\\\\\\\



% readInput()

\paragraph{\texttt{readInput()}\\\\
\normalfont \emph{syntax: } \texttt{readInput}((table) \emph{table\_array} [ ; (bools) \texttt{ifHeader}, \texttt{resizeColumns}, \texttt{resizeRows} = values])\\\\}\index{readTable@\texttt{readTable()}|(}\index{tables!reading|(}

Identical to \texttt{readTable()}, except reads the table string from the command line input.\index{readTable@\texttt{readTable()}|)}\index{tables!reading|)}\\\\\\\\



% readTable()

\paragraph{\texttt{readTable()}\\\\
\normalfont \emph{syntax: } \texttt{readTable}((table) \emph{table\_array}, (string) \emph{table\_text} [ ; (bools) \texttt{ifHeader}, \texttt{resizeColumns}, \texttt{resizeRows} = values])\\\\}\index{readTable@\texttt{readTable()}|(}\index{tables!reading|(}

The counterpart to \texttt{saveTable()} is \texttt{readTable()}, which loads data into an array.  It reads the data from a string, not a file, and tries to parse the data into the provided table.  If the \texttt{IfHeader} variable is set to true, then the first line of text is skipped.  Setting the \texttt{Resize...Index} arguments gives \verb#readTable()# permission to adjust the size of the table to fit the data; in order for this to work the table must be a square array (i.e. not a list of 1-dimensional arrays that can be resized independently).  The default values of the optional arguments are \texttt{false} for \texttt{IfHeader}, and \texttt{true} for \texttt{ResizeFirstIndex} and \texttt{ResizeSecondIndex}.  An error results in a non-zero value for \verb#readTable.errCode# and an error message printed to the screen.\index{readTable@\texttt{readTable()}|)}\index{tables!reading|)}\\\\\\\\



% round()

\paragraph{\texttt{round()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{rounded\_integer} = \texttt{round}((numeric) \emph{real\_number})\\
\normalfont \emph{C syntax: } \texttt{\$round}((double) \emph{x}, (double) \emph{y})\\\\}\index{round@\texttt{round()}|(}

Rounds a real number to the nearest integer.  For example, 1.499 rounds to 1, 1.5 rounds up to 2, and -1.5 rounds `up' to -1.  Arguments may be scalars or arrays.\index{round@\texttt{round()}|)}\\\\

\index{round@\verb$round()$|)}



% run()

\paragraph{\texttt{run()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{script\_return\_value} = \texttt{run}((string) \emph{filename} [, (composite) \emph{target}])\\\\}\index{run@\texttt{run()}|(}

The essential \texttt{run()} function runs a script stored in a file.  \texttt{run()} compiles, transforms and finally runs the code in the current \verb#go{}# location and search path.  Any errors in the process are flagged along with the offending text.  \texttt{run()} searches all directories in the \texttt{filePaths[]} array.  If there is a direct \verb#return# from the lowest level of a script (i.e. not within a function or type definition) then the return variable will be handed back to the calling script.

Normally the specified script is run in the user's workspace.  Optionally, we can pass some other variable or function as a second argument to \texttt{run()}, in which case the script runs inside that object instead.

A given script is often run multiple times.  By default, when executing a script \verb#run()# first checks to see whether it has seen that script before, and if so removes any root-level objects that the script defined when it was last run.  This is to avoid type-mismatch errors when the script tries redefining those objects.  If this is a problem then set \verb#run.CleanUp = false#.  (This parameter is not set within the arguments.)  To make sure it knows when a script was rerun, make sure that the Boolean \verb#run.caseSensitive# is set properly for your file system (it defaults to \verb#false# meaning that Cicada assumes the file system doesn't discriminate filename cases).\index{run@\texttt{run()}|)}\\\\




% save()

\paragraph{\texttt{save()}\\\\
\normalfont \emph{syntax: } \texttt{Save}((string) \emph{filename}, (string) \emph{filedata})\\
\normalfont \emph{syntax: } \texttt{save}((string) \emph{file\_name}, (string) \emph{filedata})\\
\normalfont \emph{C syntax: } \texttt{\$save}((string) \emph{filename}, (string) \emph{filedata})\\\\}
\index{save@\texttt{save()}|(} \index{file I/O!saving|(}

Saves the data from the second argument into the file specified in the first argument.  There is no return value, although the error ``I/O error" will be thrown if the save is unsuccessful.

\texttt{Save()} (capital `S') extends the \texttt{save()} function by searching all paths in the \texttt{DirectoryNames[]} array.  This is useful when \verb#filename# involves a path that may only be found in another directory.

If our data isn't already in string format, it's easy to do an on-line conversion:

\begin{code} \begin{verbatim}
save("my_data", (temp_str :: string) =! the_data)
\end{verbatim} \end{code}

\index{save@\texttt{save()}|)} \index{file I/O!saving|)}




% saveTable()

\paragraph{\texttt{saveTable()}\\\\
\normalfont \emph{syntax: } \texttt{saveTable}((string) \emph{filename}, (table) \emph{data} [ ; (ints) \texttt{fieldWidth}, \texttt{maxDigits}, (string) \texttt{voidString} = values ])\\\\}\index{saveTable@\texttt{saveTable()}|(}\index{tables!saving|(}

The \texttt{saveTable()} routine exports data stored a set or array to a file.  This routine attempts all file paths when saving, just like the general-purpose \verb#Save()# function.  The optional arguments are the same as those used by the function \texttt{mprint()}.\index{saveTable@\texttt{saveTable()}|)}\index{tables!saving|)}\\\\




% sin()

\paragraph{\texttt{sin()}, \texttt{\$sin()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{y} = \texttt{sin}((numeric) \emph{x})\\
\normalfont \emph{C syntax: } \texttt{\$sin}((double) \emph{x}, (double) \emph{y})\\\\}\index{sin@\texttt{sin()}|(}

Returns the sine of its argument, which must be a numeric scalar or array.\\

\index{sin@\texttt{sin()}|)}





% size()

\paragraph{\texttt{size()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{var\_size} = \texttt{size}((var) \emph{my\_var} [, code, \texttt{storageSize} = (bool)])\\
\normalfont \emph{C syntax: } \texttt{\$size}((var) \emph{my\_var}, (bool) \emph{storageSize}, (int) \emph{var\_size})\\\\}
\index{size@\texttt{size()}|(}

Returns the size, in bytes, of the first argument.  For composite variables, this is the sum of the sizes of all its members.  If two members of a composite variable point to the same data (i.e. one is an alias of the other), then that data will indeed be double-counted \emph{unless} the optional second argument is set to \verb#true# (its default value is \verb#false#).

If a member points back to the composite variable, as in

\begin{code} \begin{verbatim}
a :: {
    self := @this
    data :: int    }

size(a)   | will cause an error
\end{verbatim} \end{code}

\noindent then the size of \texttt{a}, including its members and its members' members, etc., is effectively infinite, and Cicada throws a self-reference error unless the second argument was set to \verb#true#.\\

\index{size@\texttt{size()}|)}



% sort()

\paragraph{\texttt{sort()}\\\\
\normalfont \emph{syntax: } \texttt{sort}((table) \emph{table\_to\_sort}, \{ (list) \emph{sort\_by\_list} or (numeric) \emph{sorting\_index} \} [, \texttt{code}, \texttt{direction} = \{ \texttt{increasing} / \texttt{decreasing}])\\
\normalfont \emph{C-1 syntax: } \texttt{\$makeLinkList}((doubles) \emph{list\_to\_sort}, (ints) \emph{link\_list}, (int) direction, (int) \emph{first\_index}, (ints or doubles) \emph{sorted\_list})\\
\normalfont \emph{C-2 syntax: } \texttt{\$sort}((ints) \emph{link\_list}, (int) first\_index, (ints or doubles) \emph{lists\_to\_sort}, (ints or doubles) \emph{sorted\_lists})\\\\}
\index{sort@\texttt{sort()}|(}\index{tables!sorting|(}

Sorts a list or table, which is passed as the first argument.  If it is a table then a second argument is required: either the column number to sort by, or a separate list to sort against.  So the following two sorts are equivalent:

\begin{code} \begin{verbatim}
myTable :: [10] { a :: b :: double }
for (c1::int) in <1, 10> myTable[c1] = { random(), random() }

sort(myTable, 1)     | sort by first column
sort(myTable, myTable[].a)
\end{verbatim} \end{code}

\noindent The sort-by list will be unaffected.

Whether to sort in increasing or decreasing order can be specified after the semicolon/\verb#code# marker; the default is `increasing'.  The column to sort by, whether it is in the same table or in a separate list, must be numeric; \verb#sort()# will not alphabetize strings (although it will work with character fields).

The Cicada \verb#sort()# function first calls \verb#$makeLinkList()#, then attempts \verb#$sort()# using the link list from the first step.  The C-coded \verb#$sort()# only works if each list to sort is numeric; if that's not true then \verb#$sort()# uses a slower scripted sort function that works on more general data types.  \verb#$sort()# can sort multiple lists per function call: i.e. it accepts $2N+2$ arguments.
\index{sort@\texttt{sort()}|)}\index{tables!sorting|)}\\\\



% springCleaning()

\paragraph{\texttt{springCleaning()}\\\\
\normalfont \emph{syntax: } \texttt{springCleaning}()\\
\normalfont \emph{C syntax: } \texttt{\$springCleaning}()\\\\}
\index{springCleaning@\texttt{springCleaning()}|(}

This function removes all unused objects from Cicada's memory, in order to free up memory.  An object is termed `unused' if it cannot be accessed by the user in any way.  For example, if we \verb#remove# the only member to a function then that function's internal data can never be accessed unless it is currently running.

Cicada tries to free memory automatically, but unfortunately it is not always able to do so.  (The reason is self-referencing loops between objects in memory.)  The only way to eliminate these zombies is to comb the whole memory tree, which is what \texttt{springCleaning()} does.  When Cicada is run from the command prompt, it disinfects itself with a \texttt{springCleaning()} after every command from the user.  But we might want to scrub the memory more often if we are running a lengthy, memory-intensive script that allocates and removes memory frequently.  \verb#springCleaning()# can help unjam arrays, if there is no member leading to the jamb.\\

\index{springCleaning@\texttt{springCleaning()}|)}



% sprint()

\paragraph{\texttt{sprint()}\\\\
\normalfont \emph{syntax: } \texttt{sprint}([data to print])\\\\}
\index{sprint@\texttt{sprint()}|(}

\texttt{sprint()} is used for printing composite objects such as variables and functions;  the `s' probably originally stood for `spaced', `set', or `structure'.  This is one of the most useful functions.  It prints each member of an object separated by commas, and each composite object is enclosed in braces.  Void members are represented by asterisks.  The output is in exactly the format that Cicada uses for constructing sets.

\begin{code} \begin{verbatim}
> sprint({  a := 5, b :: { 4, 10, "Hi" }, nothing }, 'q')

{ 5, { 4, 10, Hi }, * }, q
\end{verbatim} \end{code}

\verb#sprint()# is the default calculator (i.e. \verb#calculator# aliases \verb#sprint()#).\index{sprint@\texttt{sprint()}|)}\\\\



% subtract()

\paragraph{\texttt{subtract()}, \texttt{\$subtract()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{z} = \texttt{subtract}((numeric) \emph{x}, (numeric) \emph{y})\\
\normalfont \emph{C syntax: } \texttt{\$subtract}((doubles) \emph{x}, (doubles) \emph{y}, (doubles) \emph{z})\\\\}
\index{min@\texttt{min()}|(}

Computes $z = x - y$, for scalar or vector numeric data.\index{subtract@\texttt{subtract()}|)}\\\\



% sum()

\paragraph{\texttt{sum()}, \texttt{\$sum()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{result} = \texttt{sum}((numeric list) \emph{the\_list})\\
\normalfont \emph{C syntax: } (numeric) \texttt{\$sum}((doubles) \emph{the\_list}, (double) \emph{result})\\\\}\index{sum@\texttt{sum()}|(}

Returns the sum of elements of a numeric list.\index{sum@\texttt{sum()}|)}\\\\



% tan()

\paragraph{\texttt{tan()}, \texttt{\$tan()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{y} = \texttt{tan}((numeric) \emph{x})\\
\normalfont \emph{C syntax: } \texttt{\$tan}((double) \emph{x}, (double) \emph{y})\\\\}\index{tan@\texttt{tan()}|(}

Returns the tangent of its numeric argument (scalar or array).\\

\index{tan@\texttt{tan()}|)}




% throw()

\paragraph{\texttt{throw()}\\\\
\normalfont \emph{syntax: } \texttt{throw}((numeric) error\_code [, (composite) error\_script, (numeric) code\_number, error\_index] [, code, if\_warning = (bool)])\\
\normalfont \emph{C syntax: } \texttt{\$throw}((int) error\_code, (bool) if\_warning, (composite) error\_script, (int) code\_number, (int) error\_index)\\\\}
\index{throw@\texttt{throw()}|(}

Causes an error to occur.  This stops execution and throws Cicada back to the last enclosing \texttt{trap()} function; if there is none then Cicada either prints an error (if run from the command line) or bails out completely.  The first argument is the error code to throw -- these are listed in Table \ref{errCodeTable} on page \pageref{errCodeTable}.  The optional second, third and fourth arguments allow one to specify the function, the part of the function (should be 1 unless the inheritance operator was used) and the bytecode word in that function the error appears to come from.  If one sets the optional fifth argument to true, then the error will be thrown as a warning instead.

Although all real errors have error codes in the range 1-50, \texttt{throw()} is happy to cause an error with any integer  error code.  If the error code is zero then it will seem that \texttt{throw()} is not working, just because 0 is code for `no error'.  \texttt{throw()} does require that the error code be zero or positive, so it gives a number-out-of-range error if the argument is negative.  However, \verb#throw(2)# also gives an out-of-range-error.. because that's what error code 2 represents!\\

\index{throw@\texttt{throw()}|)}





% top()

\paragraph{\texttt{top()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{vartop} = \texttt{top}((composite variable) \emph{my\_var})\\\\}
\index{top@\texttt{top()}|(}

Returns the number of indices of the argument variable.  The argument must be a composite variable or equivalent (e.g. set, function, class, etc.).  \texttt{top()} does \emph{not} count hidden members.  Therefore the value it returns corresponds to the highest index of the variable that can be accessed, so

\begin{code} \begin{verbatim}
my_var[top(my_var)]
\end{verbatim} \end{code}

\noindent is legal (unless the top member is void) whereas

\begin{code} \begin{verbatim}
my_var[top(my_var) + 1]
\end{verbatim} \end{code}

\noindent is always illegal (unless we are in the process of defining it).  Notice that in both of these cases we can replace the \verb#top()# function by the \verb#top# \emph{keyword}, which is always defined inside of array brackets:  e.g. \verb#my_var[top+1]#.\\

For technical reasons \verb#top()# is defined inside of \verb#cclang.c# rather than in \verb#defs.cicada#.  Don't try to use the C-coded \verb#$top()#, it just confuses the compiler.

\index{top@\texttt{top()}|)}




% transform()

\paragraph{\texttt{transform()}\\\\
\normalfont \emph{syntax: } [(composite) \emph{target\_function} =] \texttt{transform}((string) \emph{bytecode} [, (function) \emph{target\_function} ] [\texttt{, code, codePath} = @(set of functions), \texttt{errInfo.filename/sourceCode/opCharPositions} = (string)])\\
\normalfont \emph{C syntax: } \texttt{\$transform}((string) \emph{bytecode}, (function) \emph{target\_function}, (set of functions) \emph{codePath}, (string) \emph{errInfoFilename}, (string) \emph{errInfoSourceCode}, (string) \emph{errInfoOpCharPositions})\\\\}
\index{transform@\texttt{transform()}|(textbf} \index{registers!composite|(} \index{R_composite@\verb#R_composite#|(}

Copies compiled bytecode stored as a string (1st argument) into the internal code of a target function variable (return value or 2nd argument), \emph{without} running the code's constructor.  The bytecode is typically generated using the \verb#compile()# function:

\begin{code} \begin{verbatim}
newFunction :: transform(compile("toAdd := 2; return args[1]+toAdd"))
\end{verbatim} \end{code}

\noindent but it is also possible to write the bytecode by hand.  This probably won't work -- the member IDs depend on your workspace history -- but the code looks something like:

\begin{code} \begin{verbatim}
newFunction :: {}
(newBytecode :: string) =! { 8, 47, 10, 314, 54, 2, 4, &
                      5, 8, 237, 10, -999, 27, 12, 40, 54, 1, 10, 314, 0 }
transform(newBytecode, newFunction)
\end{verbatim} \end{code}

\noindent At this point it is as if we had written

\begin{code} \begin{verbatim}
newFunction :: { toAdd := 2; return args[1]+toAdd }
\end{verbatim} \end{code}

\noindent We can now execute the new code by running the target function.

\begin{code} \begin{verbatim}
newFunction(3)        | will return 5
\end{verbatim} \end{code}

When we define a function as the return value of \verb#transform()#, as in the previous example, the constructor runs automatically.  If we don't want this to happen, we should pass in a target function as the second argument of \verb#transform()#.  If a function appears here, that is not void, then that function's existing codes are erased and replaced by the transformed code (assuming no error) without running the constructor.

The default search path for the transformed code is the same search path used the function that called \verb#transform()#, but we can replace this default with a manually-constructed path by passing a set of variables as the optional 3rd argument.  For example

\begin{code} \begin{verbatim}
A :: B :: C :: { D :: {} }
transform(newBytecode, newFunction, { A, C.D, B })
\end{verbatim} \end{code}

\noindent causes \verb#newFunction()#'s search path to go from \verb#newFunction# to \verb#A# to \verb#C.D# and finally end at \verb#B#.

The optional fourth, fifth and sixth arguments help Cicada to give helpful error messages if the new code crashes when we try to run it.  The fourth argument is just the name of the file containing the script, if applicable (otherwise set it to the void).  The fifth argument is the original ASCII text of the script, and the sixth is the mapping between bytecode words and script characters that is an optional output of \verb#compile()#.  Here is how we pass all of this information between \verb#compile()# and \verb#transform()#:

\begin{code} \begin{verbatim}
fileName := "scriptFile.cicada"
myScript := load(fileName)
opPositions :: string

scriptBytecode := compile(myScript, fileName, opPositions)

newFunction :: {}
transform(scriptBytecode, newFunction, { }, fileName, myScript, opPositions)
\end{verbatim} \end{code}

It is certainly possible to pass bogus bytecode to \verb#transform()# (particularly if we're trying to write out the binary ourselves).  \verb#transform()# checks the bytecode's syntax, and if there is a problem then it crashes out with an error message.\\

\index{transform@\texttt{transform()}|)textbf} \index{registers!composite|)} \index{R_composite@\verb#R_composite#|)}




% trap()

\paragraph{\texttt{trap()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{error\_code} = \texttt{trap}([;[;[;]]] code\_to\_run)\\\\}
\index{trap@\texttt{trap()}|(textbf} \index{registers!error and warning|(}

Runs the code inside the parentheses (i.e. its argument), and returns any error value.  Error codes are listed in Table \ref{errCodeTable} on page \pageref{errCodeTable}.  No \texttt{code} marker is needed within a \texttt{trap()} call.  Upon error, the argument stops running and the error code is returned; if the argument finishes with no error then the return value is 0.  \verb#trap()# thus prevents a piece of dubious code from crashing a larger script.  Note that some egregious errors are caught at compile-time and \verb#trap()# will not be able to prevent those -- this includes some type-mismatch errors like \verb#trap(string = 4)#.

A \verb#trap()# call can optionally print out an error message if needed.  To do this we add a semicolon (or \verb#code# marker) immediately at the beginning of its arguments.  Two opening semicolons causes \verb#trap()# to re-throw the error (without printing an error message), effectively redirecting the source of the error to the \verb#trap()# command.  Three opening semicolons causes it to both print any error message and re-throw the error as a thrown-to error -- so code execution will then fall back to the next enclosing \verb#trap()# and print another message.  This can help to trace errors through multiple nested functions.

\begin{code} \begin{verbatim}
trap((a::*) = 2)                   | prevents a crash
errCode := trap((a::*) = 2)        | returns the type-mismatch error code
trap( ; (a::*) = 2)                | prints a type-mismatch error but doesn't crash
trap( ; ; ; (a::*) = 2)            | prints a type-mismatch error, then crashes out
\end{verbatim} \end{code}

\noindent Notice that \verb#trap()# will also print warning messages (minor errors that don't stop the program).  Warning codes are the same as error codes except that they are negated:  for example an out-of-range error will return error code 2, but an out of range warning will return -2.  If several warnings have been produced, \verb#trap()# will only print and return the error code for the last one.

The \verb#trap()# function is actually defined in \verb#cclang.c#, and has the unique ability to run its arguments in whatever function called \verb#trap()#, rather than in a private argument variable used by all other built-in and user-defined functions.  So variables which are defined within the \verb#trap()# argument list will be accessible to the rest of the function.  Also \verb#this# and \verb#parent# have the same meaning inside a \verb#trap()# command as outside of it.  The C-coded \verb#$trap()# lacks this ability and has the usual run-constructor arguments flag, so just use the scripted function call.

\index{trap@\texttt{trap()}|)textbf} \index{registers!error and warning|)}





% type()

\paragraph{\texttt{type()}\\\\
\normalfont \emph{syntax: } (numeric) \emph{theType} = \texttt{type}((variable) \emph{var} [, (numeric) \emph{memberIndex}])\\
\normalfont \emph{C syntax: } \texttt{\$type}((variable) \emph{var}, (int) \emph{memberNumber},  (int) \emph{theType})\\\\}
\index{type@\texttt{type()}|(}

Returns a number representing the type of the given variable (one argument) or one of its members (if there is a second argument).  The variable is the first argument, and the member index is the optional second argument.  The types IDs are listed in Table \ref{types_table} on page \pageref{types_table}.  A composite-typed variable or member only returns a `5' even though its full type is properly determined by its code list -- use the \verb#bytecode()# function to obtain the code list.\\

\index{type@\texttt{type()}|)} \index{functions!built-in|)}




% uppercase

\paragraph{\texttt{uppercase()}\\\\
\normalfont \emph{syntax: } (string) \emph{uppercase\_string} = \texttt{uppercase}((string) \emph{my\_string})\\\\}\index{uppercase@\texttt{uppercase()}|(}

Converts a mixed-case string to uppercase.\index{uppercase@\texttt{uppercase()}|)}\\\\



% what()

\paragraph{\texttt{what()}\\\\
\normalfont \emph{syntax: } (string) \emph{var\_names} = \texttt{what}([ (composite) \emph{var\_to\_look\_in} ])\\\\}\index{what@\texttt{what()}|(}

Returns the names of the variables in the current directory, which is usually \verb#root# (see \verb#go()# and \verb#jump()#).  If an argument is provided then \verb#what()# returns the names of the variables inside that argument variable.  Remember that \verb#what()# \emph{requires} the parentheses!\index{what@\texttt{what()}|)}\\\\




% where

\paragraph{\texttt{where}:}\index{where@\texttt{where}}  the current search path of the user, stored as a string.\\\\




% writeTable()

\paragraph{\texttt{writeTable()}\\\\
\normalfont \emph{syntax: } (string) \emph{table\_string} = \texttt{writeTable}((table) \emph{data} [ ; (ints) \texttt{fieldWidth}, \texttt{maxDigits}, (string) \texttt{voidString} = values ])\\\\}\index{writeTable@\texttt{writeTable()}|(}\index{tables!writing|(}

\texttt{writeTable()} exports table data as a string.  This function takes the same three optional arguments as \verb#mprint()#.\index{writeTable@\texttt{writeTable()}|)}\index{tables!writing|)}\\\\





\subsection{C functions for working with whole arguments\\}\index{arg@\texttt{arg}|(}\index{arrays!dynamic in C|see{lists}} \index{functions!for strings in C|(}

\paragraph{\texttt{getArgTop()}\\\\
\normalfont \emph{syntax: } (ccInt) \emph{member\_top} = \texttt{getArgTop}((arg *) \emph{theArg})\\\\}\index{getArgTop@\texttt{getArgTop()}|(}

Returns the `top' of the argument.  This is either the array dimension (if it is an array variable), the number of list elements spanned (for a list variable), or the number of members (if it's a composite variable).\index{getArgTop\texttt{getArgTop()}|)}\\



\paragraph{\texttt{setMemberTop()}\\\\
\normalfont \emph{syntax: } (ccInt) \emph{err\_code} = \texttt{setMemberTop}((arg *) \emph{theArg}, (ccInt) memberNumber, (ccInt) newTop, (char **) argData)\\\\}\index{setMemberTop\texttt{setMemberTop()}|(}

Sets the `top' of one \emph{member of} the argument.  An array variable has one member whose top is one array dimension; a list variable has one member for each list it contains; and a composite variable typically each member has a name.  If the member points to primitive data, returns a pointer to that data in \verb#argData#.\index{setMemberTop\texttt{setMemberTop()}|)}\\



\paragraph{\texttt{setStringSize()}\\\\
\normalfont \emph{syntax: } (ccInt) \emph{err\_code} = \texttt{setStringSize}((arg *) \emph{theArg}, (ccInt) stringNumber, (ccInt) newStringSize, (char **) stringChars)\\\\}\index{setStringSize\texttt{setStringSize()}|(}



\paragraph{\texttt{stepArg()}\\\\
\normalfont \emph{syntax: } (arg *) \emph{sub\_arg} = \texttt{stepArg}((arg *) \emph{theArg}, (ccInt) memberNumber, (ccInt *) numIndices)\\\\}\index{stepArg\texttt{stepArg()}|(}

Steps into a member of an argument, returning another \verb#arg#-type pointer.  If \verb#numIndices# is non-null, its referent is multiplied by the top of that member.  Typically one would set \verb#numIndices# to \verb#args.indices[n]# and then update this variable with each \verb#stepArg()# call.\index{stepArg\texttt{stepArg()}|)}\\



\paragraph{\texttt{argData()}\\\\
\normalfont \emph{syntax: } (void *) \emph{arg\_data} = \texttt{argData}((arg *) \emph{theArg})\\\\}\index{argData\texttt{argData()}|(}

Returns a pointer to the data list of a primitive (\verb#bool#/\verb#char#/\verb#int#/\verb#double#) argument.\index{argData\texttt{argData()}|)}\\

\index{arg@\texttt{arg}|)}\index{functions!for strings in C|)}

% --------------- linked list routines --------------


%\subsection{Linked list routines for handling Cicada strings in C}\index{linked lists|(}\index{arrays!dynamic in C|see{linked lists}} \index{functions!for strings in C|(}
%
%Cicada strings are all stored in linked lists, and when a Cicada script calls a user-defined C function any string arguments are passed as \verb#linkedlist# variables.  The \verb#lnklst# source files were written for Cicada, but they are completely stand-alone and can be used in other C programs.
%
%The \verb#linkedlist# data type is defined as follows:
%
%\begin{code} \begin{verbatim}
%typedef struct {
%    ccInt elementNum;
%    sublistHeader *memory;
%    ccInt elementSize;
%    ccFloat spareRoom;
%} linkedlist;
%\end{verbatim} \end{code}
%
%\noindent The only field relevant for Cicada strings is \verb#elementNum#, which stores the number of characters (bytes) in the string.  \verb#memory# points to the first storage sublist, while \verb#elementSize# should always be 1 (the byte-size of a character).  \verb#spareRoom# is amount of extra room to allocate in sublists relative to \verb#elementNum#; this extra space uses memory but can speed up the insertion of new elements.
%
%Here is an example of how to use a linked list in a C function.
%
%\begin{code} \begin{verbatim}
%ccInt doubleString(ccInt argc, char **argv)
%{
%    linkedlist *theString = (linkedlist *) argv[0];
%    ccInt numInitChars = theString->elementNum;
%    
%    addElements(theString, numInitChars, ccFalse);
%    copyElements(theString, 1, theString, numInitChars+1, numInitChars);
%    
%    return 0;
%}
%\end{verbatim} \end{code}
%
%There are two rules to keep in mind when using linked lists, to avoid crashing Cicada.  1) The \verb#linkedlist# variable should only be updated by Cicada's linked list routines.  2) Whenever a linked list is updated the \emph{original} \verb#linkedlist# variable (i.e. Cicada's own copy) must be updated as well.  Therefore we should always pass linked lists \emph{by reference} to any C routine:  i.e. let's not use the \verb#byValue()# keyword for these lists when using \verb#getArgs()#.\\
%
%
%\paragraph{\texttt{newLinkedList()}\\\\
%\normalfont \emph{syntax: } (numeric) \emph{err\_code} = \texttt{newLinkedList}((linkedlist *) \emph{LL}, (numeric) \emph{element\_num}, \emph{element\_size}, \emph{spare\_room}, (Boolean) \emph{if\_cleared})\\\\}\index{newLinkedList@\texttt{newLinkedList()}|(}
%
%Allocates the memory for a new linked list.  The \texttt{linkedlist} variable itself is not created; rather its \texttt{memory} field is filled with a pointer to a newly-allocated sublist.  The first three arguments are just three of the fields of the \texttt{linkedlist} data type described above:  the initial number of elements, the byte size of each element, and the percentage of extra room to maintain in the list.  The final argument, if set, zeros the memory of the linked list.\index{newLinkedList@\texttt{newLinkedList()}|)}\\
%
%
%
%
%\paragraph{\texttt{deleteLinkedList()}\\\\
%\normalfont \emph{syntax: } \texttt{deleteLinkedList}((linkedlist *) \emph{LL})\\\\}\index{deleteLinkedList@\texttt{deleteLinkedList()}|(}
%
%De-allocates the storage of a linked list.  The actual variable of type \texttt{linkedlist} is not itself deleted, but its \texttt{memory} pointer is set to zero, indicating that the list is no longer defined.\index{deleteLinkedList@\texttt{deleteLinkedList()}|)}\\
%
%
%
%
%\paragraph{\texttt{insertElements()}\\\\
%\normalfont \emph{syntax: } (numeric) \emph{err\_code} = \texttt{insertElements}((linkedlist *) \emph{LL}, (numeric) \emph{insertion\_point}, \emph{new\_elements}, (Boolean) \emph{if\_cleared})\\\\}\index{insertElements@\texttt{insertElements()}|(}
%
%Adds elements to the beginning, middle or end of a linked list.  The elements are added \emph{before} the specified existing index.  So to add before the first element we must set the insertion-point argument to 1; to add after the final existing element we set that argument to the number of current elements plus one.  The number of new elements to add is given by the third argument.  The fourth argument, if set, zeros the new memory.
%
%Each linked list has a field signifying the amount of spare room it should try to maintain in the list.  This spare room takes up more memory, but it can improve the speed with which lists are resized, since adding new elements may not require allocating more sublists if the existing ones have the extra space.  When there is not enough room, \texttt{insertElements()} creates and inserts new sublists, again with the extra storage specified in the \texttt{spareRoom} field of the linked list variable. \index{insertElements@\texttt{insertElements()}|)}\\
%
%
%
%
%\paragraph{\texttt{addElements()}\\\\
%\normalfont \emph{syntax: } (numeric) \emph{err\_code} = \texttt{addElements}((linkedlist *) \emph{LL}, (numeric) \emph{new\_elements}, (Boolean) \emph{if\_cleared})\\\\}\index{addElements@\texttt{addElements()}|(}
%
%Same as \texttt{insertElements()}, except that the elements are appended to the end of the existing list.  (This is equivalent to calling \texttt{insertElements} with an insertion point of \texttt{elementNum}+1.) \index{addElements@\texttt{addElements()}|)}\\
%
%
%
%
%\paragraph{\texttt{deleteElements()}\\\\
%\normalfont \emph{syntax: } (numeric) \emph{err\_code} = \texttt{deleteElements}((linkedlist *) \emph{LL}, (numeric) \emph{first\_index}, \emph{last\_index})\\\\} \index{deleteElements@\texttt{deleteElements()}|(}
%
%Removes a given range of elements from the linked list.  (This is not the same as zeroing the elements!)  The range of elements to delete includes the first and last indices, so for example a range of \{4, 6\} removes three elements.\index{deleteElements@\texttt{deleteElements()}|)}\\
%
%
%
%\paragraph{\texttt{deleteElement()}\\\\
%\normalfont \emph{syntax: } (numeric) \emph{err\_code} = \texttt{deleteElement}((linkedlist *) \emph{LL}, (numeric) \emph{element\_index})\\\\} \index{deleteElement@\texttt{deleteElement()}|(}
%
%Same as \verb#deleteElements()# except only deletes one element.\index{deleteElement@\texttt{deleteElement()}|)}\\
%
%
%
%\paragraph{\texttt{resizeLinkedList()}\\\\
%\normalfont \emph{syntax: } (numeric) \emph{err\_code} = \texttt{resizeLinkedList}((linkedlist *) \emph{LL}, (numeric) \emph{num\_elements}, (Boolean) \emph{if\_cleared})\\\\} \index{resizeLinkedList@\texttt{resizeLinkedList()}|(}
%
%Adds elements to the end, or deletes elements from the end, so that the linked list will have the required number of elements.  If elements are being added then they will be zeroed if and only if \emph{if\_cleared} is set to true (\verb#ccTrue#).\index{resizeLinkedList@\texttt{resizeLinkedList()}|)}\\
%
%
%
%
%\paragraph{\texttt{defragmentLinkedList()}\\\\
%\normalfont \emph{syntax: } (numeric) \emph{err\_code} = \texttt{defragmentLinkedList}((linkedlist *) \emph{LL})\\\\}\index{defragmentLinkedList@\texttt{defragmentLinkedList()}|(}
%
%Rearranges the linked list's storage into one contiguous block of memory.  A linked list is ordinarily broken up over a number of sublists, since that reduces the amount of memory shuffling that has to occur when elements are inserted or removed.  If there will be no resizing of the list then it is faster to work with when it is de-fragmented, and it can save memory too (even when \texttt{spareRoom} is 0).
%
%C function calls defragment all of their string-arguments before passing them to the C routine.\index{defragmentLinkedList@\texttt{defragmentLinkedList()}|)}\\
%
%
%
%
%\paragraph{\texttt{copyElements()}\\\\
%\normalfont \emph{syntax: } [(numeric) \emph{err\_code} =] \texttt{copyElements}((linkedlist *) \emph{source\_LL}, (numeric) \emph{first\_source\_index}, (linkedlist *) \emph{dest\_list}, (numeric) \emph{first\_dest\_index}, \emph{num\_elements\_to\_copy})\\\\}\index{copyElements@\texttt{copyElements()}|(}
%
%Copies data between two linked lists, or between two parts of the same linked list if the source and destination lists are the same.  If the copy is being done within a linked list, then it is performed in such a way that data never overwrites itself and then gets re-copied (in other words, the procedure works correctly and gives the expected result even when the source and destination ranges overlap).  The two lists' element sizes must match.\index{copyElements@\texttt{copyElements()}|)}\\
%
%
%
%
%\paragraph{\texttt{compareElements()}\\\\
%\normalfont \emph{syntax: } (Boolean) \emph{err\_code/result} = \texttt{CompareElements}((linkedlist *) \emph{source\_LL}, (numeric) \emph{first\_source\_index}, (linkedlist *) \emph{dest\_list}, (numeric) \emph{first\_dest\_index}, \emph{num\_elements\_to\_compare})\\\\}\index{compareElements@\texttt{compareElements()}|(}
%
%Compares data between two linked lists, or between two parts of the same linked list.  The return value is either an error code, or the Boolean result of the comparison.\index{compareElements@\texttt{compareElements()}|)}\\
%
%
%
%
%\paragraph{\texttt{fillElements()}\\\\
%\normalfont \emph{syntax: } [(numeric) \emph{err\_code} =] \texttt{FillElements}((linkedlist *) \emph{LL}, (numeric) \emph{first\_index}, \emph{last\_index}, (char) \emph{byte\_pattern})\\\\}\index{fillElements@\texttt{fillElements()}|(}
%
%Fills the given range of elements of a linked list with the byte pattern specified.  That is, each byte of data storage used by those elements is set to the value of the byte given in the fourth argument.\index{fillElements@\texttt{fillElements()}|)}\\
%
%
%
%
%\paragraph{\texttt{clearElements()}\\\\
%\normalfont \emph{syntax: } [(numeric) \emph{err\_code} =] \texttt{clearElements}((linkedlist *) \emph{LL}, (numeric) \emph{first\_index}, \emph{last\_index})\\\\}\index{clearElements@\texttt{clearElements()}|(}
%
%Clears -- i.e. sets to zero -- the given range of elements of a linked list.  This is equivalent to calling \texttt{fillElements()} with a byte pattern of 0.\index{clearElements@\texttt{clearElements()}|)}\\
%
%
%
%
%\paragraph{\texttt{setElements()}\\\\
%\normalfont \emph{syntax: } [(numeric) \emph{err\_code} =] \texttt{setElements}((linkedlist *) \emph{LL}, (numeric) \emph{first\_index}, \emph{last\_index}, (void *) \emph{read\_address})\\\\}\index{setElements@\texttt{setElements()}|(}
%
%Copies data from a buffer (the final argument) into a given range of elements in a linked list.  The range includes the first and last elements.  Whereas the linked list has fragmented memory, the buffer's storage is expected to be contiguous, and the buffer address is a pointer to the beginning of the data to copy.\index{setElements@\texttt{setElements()}|)}\\
%
%
%
%
%\paragraph{\texttt{setElement()}\\\\
%\normalfont \emph{syntax: } [(numeric) \emph{err\_code} =] \texttt{setElement}((linkedlist *) \emph{LL}, (numeric) \emph{index}, (void *) \emph{read\_address})\\\\}\index{setElement@\texttt{setElement()}|(}
%
%Copies data from a buffer into a single element of a linked list.  This is equivalent to calling \texttt{setElements()} with the same first and last element.\index{setElement@\texttt{setElement()}|)}\\
%
%
%
%
%\paragraph{\texttt{getElements()}\\\\
%\normalfont \emph{syntax: } [(numeric) \emph{err\_code} =] \texttt{getElements}((linkedlist *) \emph{LL}, (numeric) \emph{first\_index}, \emph{last\_index}, (void *) \emph{write\_address})\\\\}\index{getElements@\texttt{getElements()}|(}
%
%Copies data from a range of elements of a linked list (including the first and last elements) into a buffer.  The write address points to the start of the buffer.\index{getElements@\texttt{getElements()}|)}\\
%
%
%
%
%\paragraph{\texttt{getElement()}\\\\
%\normalfont \emph{syntax: } [(numeric) \emph{err\_code} =] \texttt{getElement}((linkedlist *) \emph{LL}, (numeric) \emph{index}, (void *) \emph{write\_address})\\\\}\index{getElement@\texttt{getElement()}|(}
%
%Copies data from a single element of a linked list into a buffer.  This is equivalent to calling \texttt{getElements()} with the same first and last element.\index{getElement@\texttt{getElement()}|)}\\
%
%
%
%
%\paragraph{\texttt{elementExists()}\\\\
%\normalfont \emph{syntax: } (numeric) \emph{err\_code/if\_exists} = \texttt{elementExists}((linkedlist *) \emph{LL}, (numeric) \emph{index})\\\\}\index{elementExists@\texttt{elementExists()}|(}
%
%Returns \verb#ccTrue# or \verb#ccFalse# depending on whether a given element of a linked list exists.  An error code is thrown if the \verb#memory# field of the linked list is \verb#NULL#.\index{elementExists@\texttt{elementExists()}|)}\\
%
%
%
%
%\paragraph{\texttt{findElement()}\\\\
%\normalfont \emph{syntax: } (void *) \emph{element\_pointer} = \texttt{findElement}((linkedlist *) \emph{LL}, (numeric) \emph{element\_index})\\\\}\index{findElement@\texttt{findElement()}|(}
%
%Returns a pointer to the given element of a linked list, or \verb#NULL# if the element doesn't exist.\index{findElement@\texttt{findElement()}|)}\\
%
%
%
%
%\paragraph{\texttt{element()}\\\\
%\normalfont \emph{syntax: } (void *) \emph{element\_pointer} = \texttt{element}((linkedlist *) \emph{LL}, (numeric) \emph{element\_index})\\\\}\index{element@\texttt{element()}|(}
%
%Returns a pointer to the given element of a linked list.  Identical to \verb#findElement()# except that \verb#element()# doesn't do range checking:  if the index is out of range then \texttt{element()} will simply crash the program.\index{element@\texttt{element()}|)}\\
%
%
%
%
%\paragraph{\texttt{skipElements()}\\\\
%\normalfont \emph{syntax: } (void *) \emph{element\_pointer} = \texttt{skipElements}((linkedlist *) LL, (sublistHeader *) sublist, (void *) \emph{starting\_pointer}, (ccInt *) \emph{sublist\_index}, (numeric) \emph{indices\_to\_skip})\\\\}\index{skipElements@\texttt{skipElements()}|(}
%
%Only for real pros.  Starting from a pointer to an element in the linked list, this routine returns the pointer to another element a given number of indices farther down the list.  When canvassing large, heavily-fragmented lists it may be slightly faster to go through the list once using \texttt{skipElements()} than to call \texttt{element()}, which searches from the first sublist each time it is called.  The first three arguments are the linked list, a pointer to our current sublist and a pointer to the local index of our starting element (beginning at 0 for the first element in the sublist).  The new element must have a higher index than the old; Cicada's linked lists cannot be explored in reverse.\index{skipElements@\texttt{skipElements()}|)}\index{linked lists|)}\index{functions!for strings in C|)}\\



% --------------- Errors --------------


\subsection{Errors}

When an error happens in a Cicada script, one of two things happens.  If the error happened inside of a \verb#trap()# function, then Cicada falls out of the \verb#trap()# call, printing an error message if \verb#trap()#'s arguments began with a \verb#code# marker or semicolon.  If there was no \verb#trap()#, then the script crashes with an error message.  Table \ref{errCodeTable} lists the error message by error code (the number passed to \verb#throw()# and returned by \verb#trap()#).  The rest of this section explains each error message, in alphabetical order.


\begin{table}
\begin{center}
\begin{tabular}{|c|c||c|c|}
\hline
{\bf ID} & {\bf name} & {\bf ID} & {\bf name}\\
\hline \hline
0 & passed (no error) & 26 & member is void\\
\cline{1-2}
1 & out of memory & 27 & cannot step to multiple members\\
\cline{1-2}
2 & out of range & 28 & incomplete member\\
3 & initialization error & 29 & incomplete variable\\
\cline{1-2}
4 & mismatched indices & 30 & invalid index\\
5 & error reading string & 31 & multiple indices not allowed\\
6 & error reading number & 32 & invalid index\\
7 & overflow & 33 & variable has no parent\\
 \cline{3-4}
 8 & underflow & 34 & not a variable\\
\cline{1-2}
9 & unknown command & 35 & not a function\\
10 & unexpected token & 36 & not composite\\
11 & [ token ] expected & 37 & string expected\\
\cline{1-2} \cline{3-4}
12 & argument expected & 38 & illegal target\\
13 & left-hand argument expected & 39 & target was deleted\\
\cline{3-4}
14 & right-hand argument expected & 40 & unequal data sizes\\
15 & no left-hand argument allowed & 41 & not a number\\
16 & no right-hand argument allowed & 42 & overlapping alias\\
\cline{1-2} \cline{3-4}
17 & type mismatch & 43 & thrown-to error\\
\cline{1-2}
18 & illegal command & 44 & nonexistent C function\\
19 & code overflow & 45 & wrong number of arguments\\
20 & inaccessible code & 46 & error in argument\\
\cline{3-4}
21 & jump to middle of command & 47 & self reference\\
\cline{1-2}
22 & division by zero & 48 & recursion depth too high\\
\cline{1-2}
23 & member not found & 49 & I/O error\\
\cline{3-4}
24 & variable has no member & 50 & [ return flag ]\\
25 & no member leads to variable & 51 & [ exit signal ]\\
\hline
\end{tabular}\\
\caption{Error messages, by error code}\index{errors!linked list}
\label{errCodeTable}
\end{center}
\end{table}




\paragraph{Argument expected (\#12)\\\\}

There was an empty expression where there shouldn't be.  For example, the expression \verb#5+()# causes this error because there was nothing inside the parentheses.\\




\paragraph{Cannot step to multiple members (\#27)\\\\}

Cicada tried to step into two or more members at once.  This is not allowed; the user can step to multiple indices of an array, but never two members.  So, for example,

\begin{code} \begin{verbatim}
a ::  [2] double
a[<1, 2>]
\end{verbatim} \end{code}

\noindent is legal, whereas

\begin{code} \begin{verbatim}
b :: { one :: two :: double }
b[<1, 2>]
\end{verbatim} \end{code}

\noindent causes an error on the second line.\\




\paragraph{Code overflow (\#19)\\\\}

\verb#transform()# was given bytecode that did not seem to end in the way it was supposed to.  For example, the constant-string command gives a string length followed by the characters of the string; if the length of the string is greater than the remaining length of bytecode, this error will be thrown.  All scripts must end with a 0 terminating code word.\\




\paragraph{Division by zero (\#22)\\\\}

This warning is caused when the user tries to divide by zero at runtime.  Cicada still performs the division, resulting in either infinity or a not-a-number value.  And if on some machines a divide-by-zero crashes the computer, then the computer will crash.\\




\paragraph{Error in argument (\#46)\\\\}

There was a problem with a parameter passed to a built-in function.  This is a catch-all error for miscellaneous problems with arguments.  It can be caused by:  \verb#compile()# if the fourth (variable-names) argument is not a string array, or \verb#transform()# if the bytecode string length is not a multiple of the size of an integer.\\




\paragraph{Error reading number (\#6)\\\\}

The compiler tried to read a number that didn't follow the expected format.  This can be caused by the compiler or by the \verb#read_string()# function.\\




\paragraph{Error reading string (\#5)\\\\}

A string didn't follow the allowed format.  Strings begin and end with a double-quotation-mark character:  \verb#"#.  The string must all be written on one line; the line-continuation operator `\verb#&#' does not work inside strings.  A line break (other than a comma) within a string causes this error, as does the presence of a null character.  Certain special characters can be encoded with escape sequences:  \verb#\r# (carriage return), \verb#\t# (tab), \verb#\n# (end-of-line) and \verb#\\# (backslash).  General characters can be encoded using hexadecimal codes beginning with a backslash (e.g. \verb#\3D# is an equals character).\\




\paragraph{Exit signal (\#51)\\\\}

\index{exit@\texttt{exit}|(}This error code, thrown by the \verb#exit# command, is a bookkeeping device that causes Cicada to fall out of the program.  It does not mean that anything went wrong in the code.  If an \verb#exit# command is written inside of a \verb#trap()# function, the program does not quit, but instead falls out of the \verb#trap()# with error code 51.  Typing \verb#throw(51)# is equivalent to typing \verb#exit#.\index{exit@\texttt{exit}|)}




\paragraph{I/O error (\#49)\\\\}

One of the following built-in functions couldn't perform the action instructed of it:  \verb#load()#, \verb#save()#, \verb#input()# or \verb#print()#.  The usual cause of this is that the user tried to read a non-existent file, or read or write a file with a bad pathname or without the necessary read/write permissions.  Specifically, this error is thrown if a file cannot be opened or closed, or if data could not be read or written properly to a file or the standard input or output.\\




\paragraph{Illegal command (\#18)\\\\}

Cicada found a nonsensical command in bytecode that it was trying to transform into memory.  For example, the string-constant bytecode command has a string length word -- if the string length is less than zero then this error will be thrown.  Or, Cicada may hit a command ID that simply doesn't exist in any of its tables, which will also cause this error.\\




\paragraph{Illegal target (\#38)\\\\}

Cicada tried to make an alias to something other than a variable or the void.\\




\paragraph{Inaccessible code (\#20)\\\\}

This warning is thrown by \verb#transform()#.  It indicates that a null end-of-script bytecode word was encountered before the end of the bytecode was reached.  The code will still run, but the spurious code-terminating marker will prevent the last part of the bytecode from being used.\\




\paragraph{Incomplete member (\#28)\\\\}

There are two situations that cause this error.  The first is that the user tried to redefine or re-alias a part of an array --- these are operations that must be done to the entire array.  For example:

\begin{code} \begin{verbatim}
myArray :: [5] int
myArray[3] = @nothing     | not legal
\end{verbatim} \end{code}

\noindent will cause this error.  The second scenario is that we tried to step into only some indices of an array starting from a range of indices.  This is due to a technical limitation -- Cicada is only able to reference contiguous blocks of memory.  So once we step into more than one index of an array, each subsequent step must be into the full range of indices.  So this code

\begin{code} \begin{verbatim}
b :: [5][2] double
print( b[<1, 3>][1] )        | causes an error
\end{verbatim} \end{code}

\noindent also causes an incomplete-member error.\\




\paragraph{Incomplete variable (\#29)\\\\}

Only a partial variable was used for some operation that can only be done on an entire variable:  redefining or re-aliasing, or adding/removing indices.  For example, for a hypothetical array \verb#a :: [3][2] int# the following causes an incomplete-variable error.

\begin{code} \begin{verbatim}
a[1][^4]
\end{verbatim} \end{code}

\noindent If we want to resize the second dimension we have to do that for the entire array:  \verb#a[][^4]#.\\




\paragraph{Initialization error (\#3)\\\\}

An uninitialized linked list was passed to a linked list routine (other than \texttt{newLinkedList()}).  An uninitialized linked list is marked by a null pointer in its \texttt{memory} field.  To initialize a list one must first clear the \verb#memory# field, then make a successful call to \texttt{newLinkedList()}..\\




\paragraph{Invalid index (\#30, \#32)\\\\}

The most common cause of this error is that the user requested an index of an array that does not exist:  e.g. \verb#array[5]# when it only has only four indices, or \verb#array[0]# under any circumstance.  Remember that hidden members do not contribute to the total index count.  A second possibility is that an index range was given where the second index was (more than one) lower than the first, which is not allowed:  \verb#array[<4, 2>]# for example.  (However \verb#array[<4, 3>]# is allowed and just returns zero indices.)  This error also is thrown if we resize an array to a size less than zero, or try to add a huge number of indices (more than \verb#INT_MAX#).

The fact that this error has two error codes is irrelevant to the user, having only to do with the way Cicada keeps its books.\\




\paragraph{Jump to middle of command (\#21)\\\\}

\verb#transform()# found a goto statement pointing somewhere other than the beginning of a bytecode command.  The specific bytecode commands that can cause this error are:  jump-always, jump-if-true and jump-if-false.\\




\paragraph{Left-hand argument expected (\#13)\\\\}

An operator is missing its left-hand argument.  For example,

\begin{code} \begin{verbatim}
a = + 3
\end{verbatim} \end{code}

\noindent will cause this error because the \verb#+# operator expects a number to the left, after the equals sign.\\




\paragraph{Member is void (\#26)\\\\}

Cicada attempted to step into a void member (one that has no target).  Here is the most common sort of situation that will cause a void-member error:

\begin{code} \begin{verbatim}
x :: *
x = 2
\end{verbatim} \end{code}

\noindent Many built-in functions throw this error if any of their parameters are void.

A void-member error can also happen when we try to use an `unjammed' member:  a member defined as unjammable whose target variable was later resized.  This typically only happens to members of sets.  For example, this code will unjam the only member of \verb#set# and cause a void-member error:

\begin{code} \begin{verbatim}
array :: [5] int
set :: { array[<1, 5>] }

remove array[3]       | unjams the alias in our set
set[1][1] = 2         | the second '[1]' causes the error  
\end{verbatim} \end{code}

\noindent Had we defined the member of \verb#set# explicitly:

\begin{code} \begin{verbatim}
set :: { alias := @array[<1, 5>] }
\end{verbatim} \end{code}

\noindent we would have gotten an overlapping-alias error when we tried deleting the array element.\\




\paragraph{Member not found (\#23)\\\\}

The user gave a member name that Cicada could not find.  If the missing member is at the beginning of the path, for example if it flags member \verb#list# in

\begin{code} \begin{verbatim}
print(list[5])
\end{verbatim} \end{code}

\noindent then Cicada is telling us that that member (\verb#list#) was not to be found anywhere along the search path:  the current function or any enclosing object up through the workspace.  If the problematic member was some intermediate point in the path, for example if \verb#list# is flagged in

\begin{code} \begin{verbatim}
data[5].list = anotherList
\end{verbatim} \end{code}

\noindent then the missing member (\verb#list#) was not immediately inside the given path (\verb#data[5]#).

If possible, Cicada gives the member name in single quotes along with the error message, as in:  ``\texttt{member 'header' not found}".\\




\paragraph{Mismatched indices (\#4)\\\\}

Usually, this error means that the user either tried to copy or compare data between arrays of different sizes, or else alias one array to another of a different size.  For example, the following will cause this error regardless of how `\verb#a#' and `\verb#b#' were defined.

\begin{code} \begin{verbatim}
a[<1, 3>] = b[<1, 2>]
\end{verbatim} \end{code}

\noindent This can happen when working inside of an array; for example:

\begin{code} \begin{verbatim}
q :: int
threeQs :: [3] { qAlias := @q }
\end{verbatim} \end{code}

\noindent which is basically equivalent to \verb#threeQs[].qAlias := @q#.

Note that arrays of different dimensions can be copied/compared if their indices are specified manually and the total number of indices is the same (and each is a contiguous block of memory -- see the section on arrays).  So, for example, the following is legal:

\begin{code} \begin{verbatim}
q :: [4] int
r :: [2][2] int
q[] = @r[][]
\end{verbatim} \end{code}

If the last index of the array on the left-hand side of a compare or equate is a `\verb#[]#', then Cicada will automatically resize it if that will prevent a mismatched-indices error.  Sometimes this does not work; for example, in the case below:

\begin{code} \begin{verbatim}
a :: [2][3] string
b :: [5] string
a[][] = b[]
\end{verbatim} \end{code}

\noindent we will get a mismatched-indices error because only the \emph{last} index of `\verb#a#' can be resized, which is incompatible with `\verb#b#' having an odd number of indices.  We would also get this error if the first dimension of `\verb#a#' was sized to zero, even if `\verb#b#' was also of zero size.

A mismatched-indices error can also be thrown by the linked list routines (used for working with Cicada strings in C).  The only scenario where this would happen is when the two linked lists have different element sizes.  Strings always have an element size of 1 (the byte size of a character), so this should never happen unless the linked list routines are being used for something else.\\








\paragraph{Multiple indices not allowed (\#31)\\\\}

Several instances of a variable were given where only one was expected.  Whenever Cicada expects either a number or a string, that quantity has to be a constant, a single variable or a single element of an array.  For example, the following causes this error.

\begin{code} \begin{verbatim}
if 4 < a[<1, 2>]  then print("dunno how this worked")
\end{verbatim} \end{code}

\noindent Likewise, the following expression is also (at present) disallowed for the same reason.

\begin{code} \begin{verbatim}
a :: [2] { b :: int, if 4 < b  then ... }
\end{verbatim} \end{code}

Many built-in Cicada functions will throw a multiple-indices error when passed an array parameter when only a single number or string was expected.\\




\paragraph{No left-hand argument allowed (\#15)\\\\}

An operator had a left-hand argument that it was not allowed to have.  For example, the following line

\begin{code} \begin{verbatim}
10 return
\end{verbatim} \end{code}

\noindent will cause this error because it interprets the \verb#return# statement as having a left-hand argument \verb#10#.  \texttt{return} is only supposed to have an argument on the right.\\




\paragraph{No member leads to variable (\#25)\\\\}

Cicada attempted an operation that involving a member, not just a variable, and it didn't have one.  For example, the define operator specializes the member type as well as the variable type.  The following code

\begin{code} \begin{verbatim}
f :: { code, return 5 }
f() :: double
\end{verbatim} \end{code}

\noindent will generate this error since the \verb#return# command returns only a variable, not the member of the function that points to it.

In addition to the define operator, both equate and forced-equate require a member in order to resize an array either using \verb#[^...]#, or via a \verb#[]# operator.  (That is because both the variable and the member have to be resized.)  Finally, the insertion and removal operators operate on members and therefore will generate this error if none is provided.\\




\paragraph{No right-hand argument allowed (\#16)\\\\}

An operator had an argument to its right that it was not allowed to have.  Depending on precedence, this problem can also cause a no-left-argument-allowed error.\\




\paragraph{Nonexistent C function (\#44)\\\\}

A C function was invoked that does not exist.  Each C function has function ID: positive IDs for the user's C functions, and negative IDs for the in-built functions.  The ID was not on the interval [-numInbuiltCfs, -1] or [1, numUserCfs].\\




\paragraph{Not a function (\#35)\\\\}

The user tried to do something involving code with an object that doesn't have code.  For example:

\begin{code} \begin{verbatim}
transform(compile(""), 2)
\end{verbatim} \end{code}

\noindent causes this error because \verb#transform()# cannot put the transformed code into the primitive variable storing `2'.  This error message is technically redundant with the `not-composite' error message, because every composite object (i.e. defined using curly braces) is a function and vice versa.\\




\paragraph{Not a number (\#41)\\\\}

Cicada was given a non-numeric expression where it expected a number.  For example:

\begin{code} \begin{verbatim}
b := "7"
2 + b
\end{verbatim} \end{code}

\noindent generates this error.  In different contexts one can also get compile-time or other runtime errors; the phrase ``\verb#2 + "7"# generates ``type mismatch".\\




\paragraph{Not a variable (\#34)\\\\}

We tried to do some variable operation on a non-variable.  For example, the define operator operates on both a member and a variable, so trying 

\begin{code} \begin{verbatim}
nothing :: string
\end{verbatim} \end{code}

\noindent will cause this error.  Likewise, both equate and forced equate require an existing variable to copy data into.  Likewise, the comparison operator `\verb#==#' requires two arguments that are either constants or variables.  Code substitution and alias-comparisons both involve variables and can cause this error.\\




\paragraph{Not composite (\#36)\\\\}

Cicada expected a composite variable (i.e. one defined using curly braces), but was given a primitive variable instead.  All of the `step' operators -- `\verb#.#', `\verb#[]#', `\verb#[^]#', `\verb#[+]#', etc. -- must start from some composite variable.  For example, the following generates a not-composite error:

\begin{code} \begin{verbatim}
a :: double
print(a.b)
\end{verbatim} \end{code}

\noindent This error can also be thrown by a number of built-in Cicada functions such as \verb#top()# and \verb#transform()#, which expect certain arguments to be composite.\\




\paragraph{Out of memory (\#1)\\\\}

Cicada was not able to allocate memory while it was running a script.  Any memory error will cause this message:  for example, if the computer is out of memory, or if the memory manager for some other reason refuses to allocate a block of the requested size.  Cicada is not particularly well-designed to recover from run-time memory errors -- or at the very least, it has not been well-tested in this regard -- so it is recommended that the program be restarted if this error occurs.

The usual cause of a memory error is frequent creation and removal of variables within a loop.  Due to Cicada's incomplete garbage collection the deleted variables often do not get erased from memory until the loop is finished and the command prompt is brought up again.  Calling \verb#springCleaning()# periodically within the loop will force complete garbage collection.\\




\paragraph{Out of range (\#2)\\\\}

A number was used that was not within expected bounds.  This error is often thrown as a warning.  One common cause of this is that the user assigned a value too large or too negative for a given type, for example

\begin{code} \begin{verbatim}
(a::char) = 400
\end{verbatim} \end{code}

\noindent This warning is \emph{not} caused by rounding-off errors:  for example, we can assign the value 1.9 to an integer variable, and Cicada will quietly round it off to 1 without raising any warning flag.

\verb#transform()# can throw at out-of-range error (an actual error, not a warning) if some element of the character-positions list (optional 6th argument) is not within [1, \emph{num\_chars}].  It can also be caused by certain defective numbers passed to \verb#newCompiler()#:  a negative number of commands or precedence levels (2nd/4th arguments); a precedence level outside of bounds; an operator direction other than \verb#l_to_r# or \verb#r_to_l#; or an argument number or jump-to number in the bytecode (e.g. `\verb#a5#' or `\verb#j4#') beyond the number of arguments/jump positions (or outside the range 1-9).  Finally, this error can be thrown by the linked list routines if a nonexistent/nonsensical element number of a list is passed (although \texttt{InsertElements()} allows the insertion point to be one greater than the top element).  Remember that linked list indices begin at 1, not 0.\\




\paragraph{Overflow (\#7)\\\\}

The compiler tried to read a numeric constant that was larger than the maximum that will fit in a double-precision variable.  For negative numbers this means that the number was less than the most negative allowed number.  For example, writing the number \verb#5e999# causes this error.\\




\paragraph{Overlapping alias (\#42)\\\\}

The user tried to do resize an array some of whose elements are also aliased elsewhere.  For example:

\begin{code} \begin{verbatim}
a :: [5] int
b := @a[<2, 4>]

a[+3]
\end{verbatim} \end{code}

\noindent Resizing one member (`\verb#a#') does not affect any aliases (`\verb#b#'), so there would be a contradiction in the array if the resize were allowed.  An alias to the array variable (as opposed to certain indices of the integer variable), as in

\begin{code} \begin{verbatim}
c := @a
\end{verbatim} \end{code}

\noindent does not have this problem.\\




\paragraph{Recursion depth too high (\#48)\index{recursion}\\\\}

Too many nested functions are being run.  In order to avoid blowing the program stack, Cicada sets a limit to the number of nested functions that can be run inside one another.  This limit is set in the \verb#glMaxRecursions# variable at the top of bytecd.c -- Cicada comes with it set to 100.  So if we have \verb#f1# call \verb#f2# which then calls \verb#f3#, then there is no problem because the total depth is only 4 (the three functions plus the calling script).  On the other hand, if we try\\

\begin{code} \begin{verbatim}
f :: { f2 :: this }
\end{verbatim} \end{code}

\noindent then we will immediately get this error because defining `\verb#f#' requires an infinite level of recursion.  (\verb#f# creates \verb#f2# which creates its own \verb#f2#, etc.)\\




\paragraph{Return flag (\#50)\\\\}

\index{return@\texttt{return}|(}This error code is used internally to cause Cicada to fall out of a function when it hits a \verb#return# statement.  Since returning from functions is a perfectly legitimate thing to do, the error code is always set to 0 (no error) after the function has been escaped.  Writing \verb#throw(50)# in a script is the same as writing \verb#return#.\index{return@\texttt{return}|)}




\paragraph{Right-hand argument expected (\#14)\\\\}

An operator requiring a right-hand argument does not have one.  For example,

\begin{code} \begin{verbatim}
a = 5 +
\end{verbatim} \end{code}

\noindent causes an error because the \verb#+# operator requires a number or expression to the left \emph{and} the right.\\




\paragraph{Self reference (\#47)\\\\}

A variable with an alias to itself was given to an operation in which self-aliases are not allowed.  It is fine for a variable to have aliases to itself, but we cannot sensibly, say, copy data to that variable since it has an infinite depth.  For example, if we define:

\begin{code} \begin{verbatim}
me :: { self := @this }
\end{verbatim} \end{code}

\noindent then \verb#me# contains \verb#me.self#, which contains \verb#me.self.self#, etc.  Therefore if we try to use this variable, or any enclosing variable, in an equate, comparison, forced equate, or the built-in functions \verb#print_string()#, \verb#read_string#, \verb#size()#, \verb#load()# or \verb#save()#, we will get this error.\\




\paragraph{String expected (\#37)\\\\}

A built-in Cicada function requiring a string argument was passed something that was manifestly not a string.  Currently unused.\\




\paragraph{Target was deleted (\#39)\\\\}

A member was removed while it was being aliased.  One has to try hard to get this error.\\




\paragraph{Thrown-to error (\#43)\\\\}

This causes a message ``Error was thrown in ...".  It is an error produced by a \verb#trap(;; ...)# call where the two (or three) semicolons re-throw some error in its arguments as a `thrown-to' error.  This enables tracing back of errors through nested functions.\\




\paragraph{[ Token ] expected (\#11)\\\\}

A multi-token command (like `\verb#while#' followed by `\verb#do#') was missing one of its parts.  So a typical error message would be

\begin{code} \begin{verbatim}
> while true

Error:  'do' expected
\end{verbatim} \end{code}

\noindent Notice that the error message contains the name of the token that is missing.\\





\paragraph{Type mismatch (\#17)\\\\}

A member or variable does not have the expected type.  This error can occur either when data is being copied or compared, when a variable or member is having its type altered (e.g. via the define operator), or when a built-in function is run with the wrong argument types.

When two variables are copied or compared, Cicada requires that they have identical structures with the proviso that numeric types are interchangeable.  So if (any part of) the first variable is composite, the (corresponding part of) the second variable must also be composite, have the same number of (non-hidden) members, and each array member must have the same number of indices.  Here are some commands that don't work:

\begin{code} \begin{verbatim}
{ string, int } = { int, string }
{ [5] int } = { [4] int }
string = char
\end{verbatim} \end{code}

\noindent and nor does substituting specific \verb#int#-, \verb#char#- and \verb#string#-typed variables work.  Numeric members in one variable must correspond to numeric variables in the other, strings with strings, Booleans with Booleans.

Cicada is also fastidious about redefining members and variables:  it doesn't care about the structure of the variables, but it does require that their old types exactly match or be compatible with the new types.  A type can only change by being updated, using the inheritance operator.  Redefining a variable as a different numeric type, as in

\begin{code} \begin{verbatim}
myNum :: int
myNum :: double
\end{verbatim} \end{code}

\noindent will cause this error, even though copying/comparing different numeric types (e.g. \verb#{ int } = { double }#) is legal.

One composite type can be changed (specialized) into another only if all of the existing $N$ codes are also the first $N$ codes in the new type, in the same order.  Thus if we define \verb#var1# to be of type \verb#a:b#, then we can specialize it into \verb#a:b:c# but not \verb#c:a:b# or \verb#b:a:c#.\\




\paragraph{Underflow (\#8)\\\\}

A number was encountered which was so small that it was read as zero.  \verb#1e-400# will do the trick on most machines.\\




\paragraph{Unequal data sizes (\#40)\\\\}

Cicada was not able to perform a forced equate because the byte-sizes of the left- and right-hand arguments were different.  For example, the following fails:

\begin{code} \begin{verbatim}
(a :: double) =! (b :: int)
\end{verbatim} \end{code}

\noindent even though a normal equate would have worked in this situation.

Before throwing this error, the forced-equate operator explores two options for making the data fit.  1) If the final step into the left-hand variable involved a \verb#[]# operator it tries to resize that last member.  2) If the left-hand variable contains a string, that string can soak up excess bytes from the right-hand argument.  If after (1) and (2) the data on the right still cannot fit into the variable on the left, then this error is thrown.  If both (1) and (2) apply, Cicada may not able to figure out how to resize the array correctly in which case the user must resize the array manually.\\





\paragraph{Unexpected token (\#10)\\\\}

The compiler encountered a token that usually follows another token, but didn't.  For example, writing a \verb#do# without a \verb#while# will cause this error.\\




\paragraph{Unknown command (\#9)\\\\}

The compiler encountered some mysterious symbol which it cannot recognize as an operator.  For example, the following will cause this error

\begin{code} \begin{verbatim}
a = %
\end{verbatim} \end{code}

\noindent because a percent sign has no use in Cicada.\\




\paragraph{Variable has no member (\#24)\\\\}

A step was attempted into a variable without a member.  For example \verb#{}[]# will cause this error.  This error is also thrown if we use the \verb#top# keyword (which is different from the \verb#top()# function!) anywhere outside of array brackets.\\




\paragraph{Variable has no parent (\#33)\\\\}

A pathname tried to step to \verb#parent# or \verb#\# when it was already at the beginning of the search path.  Just typing \verb#parent# at the command prompt will cause this error.\\




\paragraph{Wrong number of arguments (\#45)\\\\}

A built-in Cicada function was called with the wrong number of arguments.  For example, the following expression will cause this error

\begin{code} \begin{verbatim}
top(a, b)
\end{verbatim} \end{code}

\noindent because \verb#top()# accepts only a single argument.\\






% --------------- INDEX --------------

\addcontentsline{toc}{section}{Index}
\printindex

\end{document}

