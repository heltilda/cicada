"|*\n"
" *  terminal.cicada\n"
" *  This file, which is loaded by default when Cicada starts up,\n"
" *  runs an interactive workspace session for the user\n"
" *  \n"
" *  Cicada\n"
" *  Copyright (C) 2017 Brian C. Ross\n"
" *  \n"
" *  Permission is hereby granted, free of charge, to any person obtaining a copy\n"
" *  of this software and associated documentation files (the \"Software\"), to deal\n"
" *  in the Software without restriction, including without limitation the rights\n"
" *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
" *  copies of the Software, and to permit persons to whom the Software is\n"
" *  furnished to do so, subject to the following conditions:\n"
" *  \n"
" *  The above copyright notice and this permission notice shall be included in all\n"
" *  copies or substantial portions of the Software.\n"
" *  \n"
" *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
" *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
" *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
" *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
" *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
" *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
" *  SOFTWARE.\n"
" *|\n"
"\n"
"\n"
"\n"
"| *******  Definitions  *******\n"
"\n"
"\n"
"errCode :: counter :: memberCounter :: memID :: loopMember :: memTop :: pmTop :: numAllNames :: int\n"
"cicadaCode :: scriptOneLine :: opPositions :: bytecodeString :: string\n"
"protectedMembers :: [] int\n"
"allNames :: [] string\n"
"moreInput :: bool\n"
"toPrint :: *\n"
"\n"
"compiledCode :: search_path :: go_path :: { }\n"
"\n"
"calculator_print :: { ; $print(args[1], \"\\n\") }\n"
"\n"
"printl :: {  code, $print(args, \"\\n\")  }\n"
"concat :: {  s :: string; $print_string(s, 1, args), args[1] = s  }\n"
"\n"
"passed := 0\n"
"\n"
"\n"
"\n"
"    | Set up the user's workspace, and make aliases to a few variables from terminal.cicada\n"
"\n"
"workspace :: {}     | our pseudo-workspace for the interactive session\n"
"\n"
"(workspace.calculator :: *) = @calculator_print\n"
"workspace.ans :: *\n"
"workspace.go_path := @go_path\n"
"workspace.allNames := @allNames\n"
"\n"
"(top_of_path :: *) = @go_path[+1] = @workspace\n"
"\n"
"\n"
"\n"
"    | Run predefined objects here and in the workspace\n"
"\n"
"$load(1, cicadaCode)\n"
"$compile(1, cicadaCode, \"defs.cicada\", opPositions, numAllNames, bytecodeString)\n"
"$transform(bytecodeString, compiledCode, { }, \"defs.cicada\", cicadaCode, opPositions)\n"
"\n"
"this_is_the_terminal := true\n"
"(this<<compiledCode#0)()\n"
"(workspace<<compiledCode#0)()\n"
"\n"
"allNames[^numAllNames]\n"
"$getMemberNames(1, allNames, 0)\n"
"\n"
"trap(\n"
"    cicadaCode = load(3)\n"
"    bytecodeString = compile(cicadaCode, opPositions, allNames; filename = \"user script\")\n"
"    transform(bytecodeString, compiledCode; codePath :: { }, errInfo = { \"defs.cicada\", cicadaCode, opPositions })\n"
"    (workspace<<compiledCode#0)()\n"
")\n"
"\n"
"\n"
"\n"
"| *******  Main program  *******\n"
"\n"
"\n"
"    | the main loop\n"
"\n"
"while true  do (\n"
"    \n"
"    \n"
"        | read in the user input...\n"
"        | and keep reading it in as long as the user ends with a '&' (line-continuation) character\n"
"    \n"
"    cicadaCode = \"\"\n"
"    $print(\"\\n\\n> \")\n"
"    loop\n"
"        if trap(scriptOneLine = input()) /= passed  then scriptOneLine = \"\"        | some control characters throw input() a NULL\n"
"        \n"
"        if size(scriptOneLine) == 0  then moreInput = false\n"
"        else if scriptOneLine[size(scriptOneLine)] == '&'  then (\n"
"            moreInput = true\n"
"            scriptOneLine =! scriptOneLine[<1, size(scriptOneLine)-1>]   )\n"
"        else  moreInput = false\n"
"        \n"
"        concat(cicadaCode, scriptOneLine)\n"
"    until not moreInput\n"
"    printl()\n"
"    \n"
"    \n"
"        | compile what the user types into bytecode\n"
"    \n"
"    if trap( ; bytecodeString = compile(cicadaCode, opPositions, allNames) ) == passed  then (\n"
"        \n"
"        \n"
"            | if go_path has changed, then we need to update our 'search path'\n"
"            | (the stack of objects where we look for member names)\n"
"        \n"
"        search_path[^top(go_path)]\n"
"        \n"
"        if trap(\n"
"            for counter in <1, top(go_path)-1>  (\n"
"            if search_path[counter+1] /= @go_path[counter]  then (\n"
"                if type(go_path[counter]) < 5  then throw(1)\n"
"                search_path[counter+1] = @go_path[counter]\n"
"            ))\n"
"            if top_of_path /= @go_path[top]  then (\n"
"                if type(go_path[top]) /= 5  then throw(1)\n"
"                top_of_path = @go_path[top]        )\n"
"        ) /= passed  then (\n"
"            search_path[^1]\n"
"            go_path[^1] = @top_of_path = @workspace\n"
"            go_path()\n"
"            printl(\"Problem with path; resetting to root..\")\n"
"        )\n"
"        \n"
"        \n"
"            | mark pre-existing 'token' members (so we don't print or remove them after running the command)\n"
"        \n"
"        pmTop = 0\n"
"        protectedMembers[^0]\n"
"        memTop = top(top_of_path)\n"
"        \n"
"        for loopMember in <1, memTop>  (\n"
"        if member_ID(top_of_path, loopMember) <= 0  then (\n"
"            pmTop = that + 1\n"
"            protectedMembers[+pmTop] = member_ID(top_of_path, loopMember)\n"
"        ))\n"
"        \n"
"        \n"
"            | 'transform' the bytecode (i.e. load it from a string variable into memory)\n"
"        \n"
"        errCode = trap( ; transform(bytecodeString, compiledCode; codePath = @search_path))\n"
"        if errCode == passed  then (\n"
"            \n"
"            \n"
"                | finally, run the code\n"
"            \n"
"            errCode = trap( ; (top_of_path<<compiledCode#0)() )\n"
"            \n"
"            \n"
"                | if the user typed 'exit', then let him leave\n"
"            \n"
"            if errCode == 51  then (  printl(), exit  )\n"
"            \n"
"            \n"
"                | We have some clean-up to do.  For example, when the user types \"my_function()\" a token of the\n"
"                | return variable is created in the workspace (owing to a 'prefix' added by the compiler),\n"
"                | which will never be used again but nonetheless would keep the variable's data alive forever,\n"
"                | even if it was removed from all members of the script.  There is also a hidden args variable.\n"
"                | We remove these useless members to prevent them from slowing things down and wasting memory.\n"
"            \n"
"            \n"
"                | 1)  print out any 'prefix variables' (the calculator function), and\n"
"                | 2)  remove those variables (to keep the workspace free of single-use prefix variables from command-prompt entries)\n"
"            \n"
"            for memberCounter in <1, top(top_of_path)>  (\n"
"                memID = member_ID(top_of_path, memberCounter)\n"
"                \n"
"                if memID <= 0  then ( {\n"
"                    \n"
"                    pmTop = top(protectedMembers)\n"
"                    for loopMember in <1, pmTop>  (\n"
"                    if protectedMembers[loopMember] == memID  then (\n"
"                        return\n"
"                    ))\n"
"                    \n"
"                    \n"
"                        | remove before printing to avoid self-reference errors (think 'print(q)' when pwd == root.q)\n"
"                    \n"
"                    toPrint = @top_of_path[memberCounter]\n"
"                    \n"
"                    remove top_of_path[memberCounter]\n"
"                    \n"
"                    if trap(size(toPrint)) == passed  then (\n"
"                        trap(workspace.ans = @toPrint)              | trap():  ans variable may be broken\n"
"                        if toPrint /=@ *  then (\n"
"                            trap(workspace.calculator(toPrint))     | calculator:  ditto\n"
"                    )   )\n"
"                    \n"
"                    toPrint = @nothing\n"
"                    \n"
"                    memberCounter = that - 1\n"
"            })  )\n"
"            \n"
"            \n"
"                | 3) remove hidden variables from the working directory, then 4) do a general clean up\n"
"            \n"
"            springCleaning(top_of_path)\n"
"            springCleaning()\n"
"            \n"
"            \n"
"                | Finally, if the user -- for some reason -- has left the workspace and then resized a member on his search path,\n"
"                | he won't be able to do hardly anything including get back to root.  Help him out of this.\n"
"            \n"
"            if errCode == 29  then (                            | incomplete_variable_err\n"
"                if trap(top_of_path[top+1] :: *) == passed  then remove top_of_path[top]\n"
"                else  (\n"
"                    printl(\"You look stuck; am sending you back to root...\")\n"
"                    search_path[^1]\n"
"                    go_path[^1] = @top_of_path = @workspace    \n"
"                    go_path()\n"
"    )   )   )   )\n"
")"
